
\section*{Общая характеристика работы}

\newcommand{\actuality}{\underline{\textbf{\actualityTXT}}}
\newcommand{\progress}{\underline{\textbf{\progressTXT}}}
\newcommand{\aim}{\underline{{\textbf\aimTXT}}}
\newcommand{\tasks}{\underline{\textbf{\tasksTXT}}}
\newcommand{\novelty}{\underline{\textbf{\noveltyTXT}}}
\newcommand{\influence}{\underline{\textbf{\influenceTXT}}}
\newcommand{\methods}{\underline{\textbf{\methodsTXT}}}
\newcommand{\defpositions}{\underline{\textbf{\defpositionsTXT}}}
\newcommand{\reliability}{\underline{\textbf{\reliabilityTXT}}}
\newcommand{\probation}{\underline{\textbf{\probationTXT}}}
\newcommand{\contribution}{\underline{\textbf{\contributionTXT}}}
\newcommand{\publications}{\underline{\textbf{\publicationsTXT}}}

\input{common/characteristic} % Характеристика работы по структуре во введении и в автореферате не отличается (ГОСТ Р 7.0.11, пункты 5.3.1 и 9.2.1), потому её загружаем из одного и того же внешнего файла, предварительно задав форму выделения некоторым параметрам

%\underline{\textbf{Объем и структура работы.}} Диссертация состоит из~введения, четырех глав, заключения и~приложения. Полный объем диссертации \textbf{ХХХ}~страниц текста с~\textbf{ХХ}~рисунками и~5~таблицами. Список литературы содержит \textbf{ХХX}~наименование.

%\newpage
\section*{Содержание работы}
Во \underline{\textbf{введении}} обосновывается актуальность
исследований, проводимых в~рамках данной диссертационной работы,
формулируется цель, ставятся задачи работы, излагается научная новизна
и практическая значимость представляемой работы.
В~первой главе приводится обзор научной литературы по изучаемой проблеме, во второй главе описывается теоретические основы метода, доказывается его корректность в некоторых предположениях.
В третьей главе описывается схема реализации и архитектура разработанного инструмента.
В четвертой главе представлены результаты апробации на частных примерах: как на множестве тестовых примеров, так и на реальном системном коде.

\underline{\textbf{Первая глава}} посвящена обзору существующих методов поиска ошибок использования различных примитивов синхронизации в многопоточном программном обеспечении.
В разделе 1 рассматриваются различные методы статической верификации (англ. software model checking).
Такие методы основаны на том, что автоматически строится некоторая формальная модель программы, а затем эта модель проверяется на соответствие заданным свойствам.
Такие методы являются достаточно точными при условии, что модель достаточно хорошо соответствует исходной программе.
Одним из важных минусов таких методов являются высокие требования к ресурсам.
Другим минусом статической верификации является то, что на реальном программном обеспечении достаточно сложно достигнуть высокого уровня соответствия модели и исходной программы, что приводит к большому количеству ложных срабатываний.
К плюсам можно отнести возможность формального доказательства, что в программе отсутствуют дефекты определенного типа, опять же, при условии адекватности построенной модели.

В разделе 2 рассматриваются методы статического анализа.
Эти методы похожи на те, которые были рассмотрены в предыдущем разделе, однако, в отличие от методов проверки моделей, методы статического анализа не ставят целью возможность доказательства отсутствия ошибок в программе.
Основной задачей таких методов является нахождение как можно большего числа ошибок при наименьших затратах ресурсов. 
Многие из методов статического анализа являются корректными, то есть способны не пропускать ошибки, но в этом случае процент ложных срабатываний будет слишком большой.
Большое количество ложных срабатываний сильно затрудняет ручной анализ предупреждений, поэтому зачастую применяются различные фильтры, которые сокращают число ложных сообщений об ошибках.
Однако такие фильтры являются лишь неточными эвристиками, которые снижают корректность метода в целом и способны привести к пропуску реальной ошибки.

В разделе 3 рассматриваются методы динамического анализа.
Такие методы применяются для поиска ошибок синхронизации во время работы программы, поэтому одна из основных характеристик таких методов - это замедление целевой программы. 
Одной из характерных особенностей данного метода является возможность гарантировать, что обнаруженное предупреждение является реальной ошибкой, а не ложной. 
Однако, такая возможность доступна, если поиск ошибок производится только на тех путях, которые были получены при конкретном выполнении программы.
Перебрать все варианты выполнения даже небольшой программы невозможно за разумное время, поэтому применяются различные механизмы анализа множества путей, похожих на те, которые возникают при реальном выполнении.
Такой подход значительно ускоряет процесс анализа, но приводит к получению ложных предупреждений. 
Тем не менее, процент ложных предупреждений у инструментов, реализующих методы динамического анализа, обычно значительно ниже, чем у тех, что основаны на других подходах.

В разделе 4 подводятся основные итоги обзора и делаются выводы.
Результаты обзора позволяют заключить, что основные усилия сейчас сосредаточены на анализе пользовательских приложений, 
системное программное обеспечение является слишком объемным и слишком сложным для применения общецелевых методов.
Применение методов динамического анализа к системному программному обеспечению осложняется тем, что требуется трудоемкая настройка тестового окружения, в том числе аппаратуры.
Кроме того, методы динамического анализа не способны обеспечить гарантию отсутствия ошибок.
Методы статического анализа успешно применяются к любым объемам кода любой сложности. 
В случае применения таких методов к большому объему сложного кода будет получено огромное количество предупреждений.
Анализ этих предупреждений вручную может потребовать большого количества времени.
Методы статической верификации способны дать гарантию отсутствия дефектов определенного типа, в некоторых разумных предположениях, и, что важно, заранее известных.
Однако, такие методы не способны в настоящее время успешно применяться к большим объемам исходного кода.

Таким образом, можно заключить, что в настоящее время отсутствуют такие методы анализа больших объемов системного кода, в том числе, операционных систем, которые могут обеспечить высокий уровень надежности.
Данная работа посвящена описанию разработанного метода поиска состояний гонки, который может применяться к реальным программным системам.

\underline{\textbf{Вторая глава}} посвящена описанию теории разработанного метода проверки многопоточных программ.
Основная идея заключается в том, что каждый поток в программе анализируется независимо от остальных.
В этом случае удастся избежать комбинаторного взрыва состояний, который бы неизбежно присутствовал, если бы анализ проводился с учетом всех взаимодействий между потоками.
Для того, чтобы обеспечить достаточно высокую точность метода, поток анализируется в некотором окружении, которое формируется другими потоками. 
Уровень точности окружения, который требуется для анализа, может гибко настраиваться.

Метод с раздельным анализом потоков может внутри себя использовать уже существующие техники и подходы, например, такие как CEGAR.
В этом случае необходимо предложить обобщенный алгоритм анализа программ, частным случаем которого уже будут как обычные подходы к анализу последовательных программ, так и различные подходы к анализу многопоточных программ, в частности, предложенный подход с раздельным анализом потоков. 

Для того чтобы доказать корректность предложенного подхода, необходимо определить формальную семантику программы, то есть ее математическую модель.
С помощью предложенного подхода строится некоторая абстракцию этой математической модели. 
Адекватность такой абстракции определяется тем, что каждый из возможных поведений модели должен присутствовать и в абстракции.
Таким образом, ошибка не может быть пропущена.
Именно в этом смысле далее используется термин корректность анализа (англ. soundness).

В разделе 1 описана семантика многопоточных программ. 
Формальная модель программы определяется, как множество конкретных состояний программы, которые описываются значениями переменных каждого из потоков, а также глобальных переменных, статусом примитивов синхронизации и информацией об активных потоках.
Далее описывается семантика всех поддерживаемых операторов программы, то есть задаются правила преобразования конкретных состояний операторами программы.
В число поддерживаемых операторов входят операторы сравнения (англ. assumption), присваивания (англ. assignment),
кроме того, специальные операторы работы с примитивами синхронизации: захват блокировки и ее освобождение, а также операции с потоками: создание потока (thread\_create) и ожидания завершения потока (thread\_join).
В заключении даны определения ошибки в программе, в частности, определение состояния гонки по данным.

В разделе 2 описан обобщенный алгоритм анализа программы, который оперирует абстрактными состояниями программы, то есть такими, которым может соответствовать некоторое множество конкретных.
Обычно для доказательства отсутствия ошибок в программе не требуется строить абстракцию с большим уровнем точности, так как многие детали модели являются ненужными. 
В этом случае множество абстрактных состояний оказывается значительно меньше, чем множество конкретных состояний.
 
Одним из важных особенностей предложенного обобщенного алгоритма является то, что его абстрактные состояния являются частичными, то есть множество конкретных состояний программы, соответствующее некоторому частичному абстрактному состоянию, может зависить не только от этого состояния, но и от других частичных состояний. 
Этот алгоритм оперирует адаптивным статическим анализом (англ., configurable program analysis, CPA), который задается следующими операторами: $transfer$, $prec$, $merge$, $stop$, $update$, $frontier$.
Для того чтобы обеспечить корректность работы алгоритма, каждый из этих операторов должен удовлетворять определенным условиям.

Алгоритм с частичными состояниями является расширением классического алгоритма, используемого в теории CPA, который рассматривает переходы только из каждого абстрактного состояния по-отдельности.
Основным отличием расширенного алгоритма с частичными состояниями является возможность рассмотрения переходов из любого множества абстрактных состояний. 
Это позволяет наложить более слабые условия на операторы анализа, чем этого требует оригинальный алгоритм.
Новые слабые условия позволяют применять более эффективные техники анализа, чем это было раньше.
После этого доказывается основная теорема, которая позволяет гарантировать корректость анализа, если его операторы удовлетворяют поставленным условиям.

В разделе 3 представлен алгоритм с раздельным анализом потоков, который позволяет применять различные техники анализа программы (CPA).
Этот алгоритм является частным случаем общего алгоритма, и оперирует двумя типами объектов: абстрактными состояниями и некоторыми вспомогательными объектами, которые далее будут называться эффектами окружения.
Из абстрактного состояния возможны как обычные переходы на основании операторов программы, так и переходы "по окружению", которые описываются эффектами окружения.
Переходы "по окружению" моделируют изменение состояния отдельного потока в результате действий другого потока.
Для этого алгоритма описаны условия на его операторы $transfer$, $prec$, $merge$, $stop$, а также представлен общий вид операторов $update$, $frontier$, которые не зависят от используемых CPA.
Кроме того, вводится новый оператор $compatible$, который определяет возможность применения перехода "по окружению" к текущему состоянию.
Для каждого оператора показано соответствие поставленных условий тем, которые требуются общим алгоритмом.
После этого определены дополнительные условия на оператор $transfer$ и представлены доказательства корректности этих условий.

Также в этом разделе представлен частный случай алгоритма, который использует анализы, состояния которых инвариантны к преобразованиям окружения.
Важным следствием для такого алгоритма является то, что переходы "по окружению" могут быть опущены, так как они не могут изменить абстрактное состояние анализа.
Это позволяет значительно повысить скорость анализа, однако снижает точность, так как теряется точная информации о том, какие именно действия могут совершить другие активные потоки и приходится учитывать любой вариант их действия.

В разделе 4 представлены описания различных CPA, которые могут быть использованы совместно друг с другом.
\begin{itemize}
\item LocationCPA. Этот служебный анализ отвечает за правильную последовательность применения операторов программы. 
\item PredicateCPA. Предикатный анализ позволяет строить предикатную абстракцию на основе некоторого множества предикатов. 
Требуемые предикаты извлекаются автоматически с помощью процесса уточнения и запросов к внешнему компоненту -- решателю (англ. solver).
\item ThreadCPA. Анализ потоков определяет какие из операций текущего потока могут выполняться параллельно с другими операциями других потоков.
\item LockCPA. Анализ примитивов синхронизации позволяет определить те точки программы, которые защищены некоторыми примитивами синхронизации, что не позволяет выполнять параллельно эти участки кода.
\end{itemize}

Кроме того, описан служебный анализ CompositeCPA, позволяющий использовать несколько различных анализов вместе.
Для каждого анализа представлено формальное определение всех его операторов и доказано, что эти операторы удовлетворяют поставленным условиям корректности.

\underline{\textbf{Третья глава}} посвящена описанию реализации разработанного метода поиска состояний гонки. Далее будем называть инструмент, реализующий предложенный метод, CPALockator. В этой же главе представлены решения, которые используются для эффективного анализа программного обеспечения.

В разделе 1 представлена общая архитектура инструмента, описаны используемые компоненты: анализ разделяемых данных, который используется как предварительный анализ и основной анализ, основанный на комбинации LockCPA, ThreadCPA и PredicateCPA.
Кроме того в этом разделе представлены описания служебных CPA, которые используются  для оптимизации работы всего инструмента: BAMCPA и UsageCPA.
BAMCPA обеспечивает модульный анализ по функциям, то есть результаты анализа функции могут быть переиспользованы в дальнейшем, если эта функция встретится еще раз.
UsageCPA определяет и сохраняет информацию о доступах к памяти, сортируя их, и обеспечивает эффективный доступ к ним.

Конфигурация инструмента CPALockator позволяет настраивать инструмент для конкретного исходного кода.
Например, можно определить функции выделения памяти, что означает, что выделенная ими память является точно локальной.
Также имеется возможность аннотировать различные функции, которые могут вызвать сложности у инструмента, например, функции работы со списками.
В этом случае доступ к отдельным служебным полям, например, $next$, будет считаться, как доступ ко всему списку.

В разделе 2 описаны структуры данных, которые используются для оптимизации работы с большим множеством доступов к памяти, которые были обнаружены в программе.
Здесь описаны используемые контейнеры, которые накапливают в себе информацию о доступах к памяти в процессе анализа: локальные контейнеры, контейнеры для отдельных функций и глобальный контейнер, который содержит в себе полное множество информации.
Также описано устройство структуры данных, используемой при уточнении результатов, которое позволяет применять эффективную навигацию по множеству всех доступов к памяти.

В разделе 3 описан процесс уточнения полученных результатов.
Так как полученная абстракция программы может является аппроксимацией сверху множества состояний программы, возможны ситуации, при которых некоторые важные детали не будут учтены. 
Это приведет к тому, что будет выдано ложное сообщение об ошибке. 
Процесс уточнения позволяет повысить степень уверенности в том, что найденная ошибка является истинной.
Например, может быть проверена локальная достижимость каждого из путей, участвующих в состоянии гонки.
Этот процесс требует достаточно большого количества ресурсов, однако может быть прерван в любой момент.

В разделе 4 представлено описание формата результатов, которое основано на формате witness, уже применяющегося в других инструментах статической верификации.
В этом разделе описан механизм построения трассы, приводящей к состоянию гонки, а также показана возможность их визуализации.

%Можно сослаться на свои работы в автореферате. Для этого в файле
%\verb!Synopsis/setup.tex! необходимо присвоить положительное значение
%счётчику \verb!\setcounter{usefootcite}{1}!. В таком случае ссылки на
%работы других авторов будут подстрочными.
%\ifnumgreater{\value{usefootcite}}{0}{
%Изложенные в третьей главе результаты опубликованы в~\cite{vakbib1, vakbib2}.
%}{}

В \underline{\textbf{четвертой главе}} приведены результаты экспериментов.
Результаты демонстрируют возможности инструмента CPALockator по его гибкой настройки.
В качестве набора небольших программ был выбран открытый тестовый набор sv-comp, на нем CPALockator показал достаточно точные результаты. 
Было получено некоторое количество ложных предупреждений об ошибке, но ни одной реальной ошибки не было пропущено, что подтверждает корректность разработанного метода.
При этом, конечно, другие методы статической верификации способны выдавать меньшее количество ложных предупреждений на таком наборе небольших рукописных программ.
Для проверки масштабируемости инструмента были выбраны несколько модулей операционной системы Linux с заранее известными ошибками.
Более половины из этих ошибок были успешно обнаружены инструментами, при этом в оставшихся случаях верификация завершилась из-за нехватки вычислительных ресурсов.
Если снизить еще снизить требования к точности, все реальные ошибки успешно обнаруживаются, хотя при этом появляется некоторое количество ложных предупреждений.

Гибкая настройка требований к ресурсам позволяет использовать инструмент для проверки достаточно больших программных систем, содержащих сотни тысяч строк кода и проводить их анализ за минуты.
При необходимости для каждой конкретной задачи можно выбрать свой баланс между качеством и требуемыми ресурсами, в зависимости от поставленной цели. 

В \underline{\textbf{заключении}} приведены основные результаты работы, которые заключаются в следующем:
\input{common/concl}


%\newpage
%При использовании пакета \verb!biblatex! список публикаций автора по теме
%диссертации формируется в разделе <<\publications>>\ файла
%\verb!../common/characteristic.tex!  при помощи команды \verb!\nocite! 

\ifdefmacro{\microtypesetup}{\microtypesetup{protrusion=false}}{} % не рекомендуется применять пакет микротипографики к автоматически генерируемому списку литературы
\ifnumequal{\value{bibliosel}}{0}{% Встроенная реализация с загрузкой файла через движок bibtex8
  \renewcommand{\bibname}{\large \authorbibtitle}
  \nocite{*}
  \insertbiblioauthor           % Подключаем Bib-базы
  %\insertbiblioother   % !!! bibtex не умеет работать с несколькими библиографиями !!!
}{% Реализация пакетом biblatex через движок biber
  \ifnumgreater{\value{usefootcite}}{0}{
%  \nocite{*} % Невидимая цитата всех работ, позволит вывести все работы автора
  \insertbiblioauthorcited      % Вывод процитированных в автореферате работ автора
  }{
  \insertbiblioauthor           % Вывод всех работ автора
%  \insertbiblioauthorgrouped    % Вывод всех работ автора, сгруппированных по источникам
%  \insertbiblioauthorimportant  % Вывод наиболее значимых работ автора (определяется в файле characteristic во второй section)
  \insertbiblioother            % Вывод списка литературы, на которую ссылались в тексте автореферата
  }
}
\ifdefmacro{\microtypesetup}{\microtypesetup{protrusion=true}}{}

