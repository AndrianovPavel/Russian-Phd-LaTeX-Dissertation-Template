\chapter{Реализация}
\label{chapter_implementation}

\section{Введение} \label{sect_impl_introduction}

При переходе от теории к практике становится важным уделять большее внимание эффективности применяемых алгоритмов.
В этом разделе будут описаны оптимизации теоретически разработанных алгоритмов, которые позволяют применять их для реальных программных систем. 

Первая такая оптимизация касается хранения достижимых состояний. В теории для определения состояния гонки необходимо было для каждой пары достигнутых состояний проверить наличие обращения к одинаковой разделяемой памяти. Такой простой алгоритм был совершенно не эффективен. Количество различных состояний может превышать десять миллионов. Поэтому необходимы очень эффективные алгоритмы хранения и поиска пары состояний образующих состояние гонки. В подразделе~\ref{sect_impl_storage} будут описаны соответствующие оптимизации.

Процесс уточнения построенной абстракции может занимать достаточно много времени даже при решении задачи достижимости. При поиске состояний гонки может быть необходимо уточнить абстракцию сразу для нескольких обнаруженных состояний гонки. Уточнение абстракции последовательно становится очень неэффективным. В подразделе~\ref{sect_impl_refinement} описан процесс уточнения абстракции и применяемые оптимизации.

Важной задачей, на которую многие академические инструменты не обращают внимания, является понятное и наглядное представление результатов верификации. Это особенно важно для описания ошибок, связанных с параллельным выполнением нескольких потоков, так как при этом не достаточно указать только строку или переменную, в которой возможно наличие ошибки. Необходимо представить полную трассу выполнения потоков, выделив некоторые важные события, например, создание потоков, захват примитивов синхронизации и одновременные доступы к разделяемой памяти. В подразделе~\ref{sect_impl_visualiztion} будут описан алгоритм печати трассы.

\section{Обзор инструмента} \label{sect_impl_storage}

Описание анализов

Картинка

Пример работы 

\section{Оптимизации хранения данных} \label{sect_impl_storage}

\subsection{Block Abstraction Memoization} \label{subsect_impl_bam}

В процессе анализа используется оптимизация, использующая абстрактные блоки (англ. Block Abstraction Memoization, BAM). 
Эта оптимизация позволяется переиспользовать результаты, полученные в процессе анализа.
Например, если функция уже была проанализирована, и та же самая функция вызывается второй раз, анализировать ее заново не обязательно, если контекст ее вызова тот же самый.
Абстрактными блоками, на границах которых производится кэширование результатов, могут быть как функции, так и тела циклов. 

Каждый анализ описывает специальный механизм выделения существенной части из своего абстрактного состояния. Это операция reduce. 
При входе анализом в новый абстрактный блок выполняется операция reduce. Полученное "уменьшенное" состояние ищется в кэше.
В случае, если результат уже присутствует к кэше, то есть анализ для данного состояния уже проводился ранее, выполняется операция expand, которая на основе полного исходного состояния и неполного результирующего состояния строит полное результирующее состояние. 
Если же фиксируется промах в кэше, это значит, что нужно провести анализ и сохранить его результат. 

\subsection{Накопление результатов в процессе анализа} \label{subsect_impl_storage}

Для каждого доступа к переменной формируется специальная структура данных, содержащая информацию об этом доступе. 
Будем использовать обозначение $Usage$ для этой структуры данных.

Основной задачей для сохранения результатов в процессе анализа является не обеспечение быстрого доступа и быстрого поиска, а удобство применения оптимизации BAM. 
Для решения этой задачи была разработана многоуровневая система контейнеров. 
Как только встречается доступ в разделяемую переменную, формируется $Usage$, который добавляется в небольшой контейнер, связанный с абстрактым состоянием. 
В том состоянии, которое соответствует абстрактному состоянию предикатного анализа, все $Usage$ из временного контейнера переносятся в следующий контейнер, соответствующий абстрактному блоку. Это происходит только если соответствующее состояние предикатного анализа не является тождественным false. В случае, если в запуске не используется предикатный анализ, переносить $Usage$ в верхний контейнер можно в любой момент.

При выходе из абстрактного блока выполняется операция expand для получившегося состояния, в том числе и для контейнера.
Операция expand для контейнера заключается в применении операции expand для каждого элемента $Usage$.
В основном это применение операции expand к информации в $Usage$, например, к множеству захваченных примитивов синхронизации. 
После применения операции expand ко всему множеству $Usage$, полученное множество $Usage$ добавляется в контейнер внешнего абстрактного блока.
Таким образом, информация о всех $Usage$ собирается снизу вверх по графу вызовов до самого main. 
Одной из проблем являются бесконечные циклы. Если цикл не имеет выхода, это значит, что информация из контейнера, соответствующего этому абстрактному блоку, не будет добавлена в контейнер, соответствующий функции main.

После завершения анализа, то есть при выходе из самого последнего (верхнего) абстрактного блока, информация из соответствующего контейнера добавляется в глобальный контейнер.

\subsection{Устройство глобального контейнера} \label{subsect_impl_global_storage}

Задачей глобального контейнера является обеспечение быстрого поиска состояний гонки среди всех добавленных состояний. 


Устройство уточненных состояний

Пример 

\section{Реализация уточнения} \label{sect_impl_refinement}

Два варианта уточнения 

Схема основного варианта

Оптимизированный вариант?

\section{Печать и визуализация} \label{sect_impl_visualiztion}

Формат витнесов

Структура графа пути

Так размещается таблица:

\begin{table} [htbp]
  \centering
  \changecaptionwidth\captionwidth{15cm}
  \caption{Название таблицы}\label{Ts0Sib}%
  \begin{tabular}{| p{3cm} || p{3cm} | p{3cm} | p{4cm}l |}
  \hline
  \hline
  Месяц   & \centering $T_{min}$, К & \centering $T_{max}$, К &\centering  $(T_{max} - T_{min})$, К & \\
  \hline
  Декабрь &\centering  253.575   &\centering  257.778    &\centering      4.203  &   \\
  Январь  &\centering  262.431   &\centering  263.214    &\centering      0.783  &   \\
  Февраль &\centering  261.184   &\centering  260.381    &\centering     $-$0.803  &   \\
  \hline
  \hline
  \end{tabular}
\end{table}

\begin{table} [htbp]% Пример записи таблицы с номером, но без отображаемого наименования
	\centering
	\parbox{9cm}{% чтобы лучше смотрелось, подбирается самостоятельно
        \captiondelim{}% должен стоять до самого пустого caption
        \caption{}%
        \label{tbl:test1}%
        \begin{SingleSpace}
    	\begin{tabular}{ | c | c | c | c |}
    	\hline
    	Оконная функция	& ${2N}$ & ${4N}$	& ${8N}$	\\ \hline
    	Прямоугольное 	& 8.72 	 & 8.77		& 8.77		\\ \hline
    	Ханна		& 7.96 	 & 7.93		& 7.93		\\ \hline
    	Хэмминга	& 8.72 	 & 8.77		& 8.77		\\ \hline
    	Блэкмана	& 8.72 	 & 8.77		& 8.77		\\ \hline
    	\end{tabular}%
    	\end{SingleSpace}
	}
\end{table}

Таблица \ref{tbl:test2} "--- пример таблицы, оформленной в~классическом книжном варианте или~очень близко к~нему. \mbox{ГОСТу} по~сути не~противоречит. Можно ещё~улучшить представление, с~помощью пакета \verb|siunitx| или~подобного.

\begin{table} [htbp]%
    \centering
	\caption{Наименование таблицы, очень длинное наименование таблицы, чтобы посмотреть как оно будет располагаться на~нескольких строках и~переноситься}%
	\label{tbl:test2}% label всегда желательно идти после caption
    \renewcommand{\arraystretch}{1.5}%% Увеличение расстояния между рядами, для улучшения восприятия.
    \begin{SingleSpace}
	\begin{tabular}{@{}@{\extracolsep{20pt}}llll@{}} %Вертикальные полосы не используются принципиально, как и лишние горизонтальные (допускается по ГОСТ 2.105 пункт 4.4.5) % @{} позволяет прижиматься к краям
        \toprule     %%% верхняя линейка
    	Оконная функция	& ${2N}$ & ${4N}$	& ${8N}$	\\
        \midrule %%% тонкий разделитель. Отделяет названия столбцов. Обязателен по ГОСТ 2.105 пункт 4.4.5 
    	Прямоугольное 	& 8.72 	 & 8.77		& 8.77		\\
    	Ханна		& 7.96 	 & 7.93		& 7.93		\\
    	Хэмминга	& 8.72 	 & 8.77		& 8.77		\\
    	Блэкмана	& 8.72 	 & 8.77		& 8.77		\\
        \bottomrule %%% нижняя линейка
	\end{tabular}%
   	\end{SingleSpace}
\end{table}

%\newpage
%============================================================================================================================

\clearpage