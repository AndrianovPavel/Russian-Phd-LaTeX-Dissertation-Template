\chapter{Реализация}
\label{chapter_implementation}

\section{Введение} \label{sect_impl_introduction}

При переходе от теории к практике становится важным уделять большее внимание эффективности применяемых алгоритмов.
В этом разделе будут описаны оптимизации теоретически разработанных алгоритмов, которые позволяют применять их для реальных программных систем. 

Первая такая оптимизация касается хранения достижимых состояний. В теории для определения состояния гонки необходимо было для каждой пары достигнутых состояний проверить наличие обращения к одинаковой разделяемой памяти. Такой простой алгоритм был совершенно не эффективен. Количество различных состояний может превышать десять миллионов. Поэтому необходимы очень эффективные алгоритмы хранения и поиска пары состояний образующих состояние гонки. В подразделе~\ref{sect_impl_storage} будут описаны соответствующие оптимизации.

Процесс уточнения построенной абстракции может занимать достаточно много времени даже при решении задачи достижимости. При поиске состояний гонки может быть необходимо уточнить абстракцию сразу для нескольких обнаруженных состояний гонки. Уточнение абстракции последовательно становится очень неэффективным. В подразделе~\ref{sect_impl_refinement} описан процесс уточнения абстракции и применяемые оптимизации.

Важной задачей, на которую многие академические инструменты не обращают внимания, является понятное и наглядное представление результатов верификации. Это особенно важно для описания ошибок, связанных с параллельным выполнением нескольких потоков, так как при этом не достаточно указать только строку или переменную, в которой возможно наличие ошибки. Необходимо представить полную трассу выполнения потоков, выделив некоторые важные события, например, создание потоков, захват примитивов синхронизации и одновременные доступы к разделяемой памяти. В подразделе~\ref{sect_impl_visualiztion} будут описан алгоритм печати трассы.

\section{Обзор инструмента} \label{sect_impl_storage}

Описание анализов

LockCPA

ThreadCPA

PredicateCPA
%Тоже сделать частью Usage?

UsageCPA

BAMCPA

Картинка

Пример работы 

\section{Оптимизации хранения данных} \label{sect_impl_storage}

\subsection{Block Abstraction Memoization} \label{subsect_impl_bam}

В процессе анализа используется оптимизация, использующая абстрактные блоки (англ. Block Abstraction Memoization, BAM). 
Эта оптимизация позволяется переиспользовать результаты, полученные в процессе анализа.
Например, если функция уже была проанализирована, и та же самая функция вызывается второй раз, анализировать ее заново не обязательно, если контекст ее вызова тот же самый.
Абстрактными блоками, на границах которых производится кэширование результатов, могут быть как функции, так и тела циклов. 

Каждый анализ описывает специальный механизм выделения существенной части из своего абстрактного состояния. Это операция reduce. 
При входе анализом в новый абстрактный блок выполняется операция reduce. Полученное "уменьшенное" состояние ищется в кэше.
В случае, если результат уже присутствует к кэше, то есть анализ для данного состояния уже проводился ранее, выполняется операция expand, которая на основе полного исходного состояния и неполного результирующего состояния строит полное результирующее состояние. 
Если же фиксируется промах в кэше, это значит, что нужно провести анализ и сохранить его результат. 

\subsection{Накопление результатов в процессе анализа} \label{subsect_impl_storage}

Для каждого доступа к переменной формируется специальная структура данных, содержащая информацию об этом доступе. 
Будем использовать обозначение $Usage$ для этой структуры данных.

Основной задачей для сохранения результатов в процессе анализа является не обеспечение быстрого доступа и быстрого поиска, а удобство применения оптимизации BAM. 
Для решения этой задачи была разработана многоуровневая система контейнеров. 
Как только встречается доступ в разделяемую переменную, формируется $Usage$, который добавляется в небольшой контейнер, связанный с абстрактым состоянием. 
В том состоянии, которое соответствует абстрактному состоянию предикатного анализа, все $Usage$ из временного контейнера переносятся в следующий контейнер, соответствующий абстрактному блоку. Это происходит только если соответствующее состояние предикатного анализа не является тождественным false. В случае, если в запуске не используется предикатный анализ, переносить $Usage$ в верхний контейнер можно в любой момент.

При выходе из абстрактного блока выполняется операция expand для получившегося состояния, в том числе и для контейнера.
Операция expand для контейнера заключается в применении операции expand для каждого элемента $Usage$.
В основном это применение операции expand к информации в $Usage$, например, к множеству захваченных примитивов синхронизации. 
После применения операции expand ко всему множеству $Usage$, полученное множество $Usage$ добавляется в контейнер внешнего абстрактного блока.
Таким образом, информация о всех $Usage$ собирается снизу вверх по графу вызовов до самого main. 
Одной из проблем являются бесконечные циклы. Если цикл не имеет выхода, это значит, что информация из контейнера, соответствующего этому абстрактному блоку, не будет добавлена в контейнер, соответствующий функции main.

После завершения анализа, то есть при выходе из самого последнего (верхнего) абстрактного блока, информация из соответствующего контейнера добавляется в глобальный контейнер.

\subsection{Устройство глобального контейнера} \label{subsect_impl_global_storage}

Задачей глобального контейнера является обеспечение быстрого поиска состояний гонки среди всех добавленных состояний. 
На верхнем уровне контейнер содержит отображение из идентификатора переменной в специальное множество, содержащее $Point$. $Point$ - это срез информации, содержащейся в $Usage$, которая может повлиять на наличие состояние гонки.
Например, информация о номере строки исходного кода является лишней для определения состояния гонки. 
Для получения исходной информации имеется отображение из $Point$ во множество всех $Usage$, которые он представляет.
При построении $Point$ необходимая информация извлекается из $Usage$.
Каждый анализ сам определяет, является ли его информация необходимой для определения состояния гонки. 
Так, в текущей конфигурации используется информация из состояний ThreadCPA и LockCPA. 
При этом сохраняются не полные состояния анализа, а некоторые усеченные варианты, содержащие только необходимую информацию. 
Опять же, какой вариант состояния требуется сохранить для вычисления состояния гонки, определяется сам анализ.

Далее из множества $Point$ строится лес. При этом все элементы узлы одного дерева являются покрытыми корнем этого дерева. А все корни деревьев упорядочены таким образом, чтобы первыми элементами стояли те, которые с наибольшей вероятностью образуют состояние гонки.

\subsection{Устройство уточненных состояний} \label{subsect_impl_refined_usages}

\subsection{Пример представления данных} \label{subsect_impl_example}

\section{Реализация уточнения} \label{sect_impl_refinement}

Уточнение абстракции по контрпримерам используется для того, чтобы исключить недостижимые пути из абстракции.
В классическом варианте CEGAR используется при решении задачи достижимости.
Когда найдено ошибочное состояние, начинается процесс уточнения: строится контрпример и проверяется, возможен ли такой сценарий в исходной программе. В случае, если такой путь является недостижимым из-за неточности абстракции, она уточняется таким образом, чтобы исключить такой путь из абстракции. 

При поиске состояний гонки дело усложняется тем, что ошибкой является не одно состояние, а пара. При этом каждый из путей сам по себе не является ошибкой.
Кроме того, обычно требуется обнаружить не первое состояние гонки в программе, а все потенциальные состояния гонки. 
Таким образом, возможны две вариации процедуры уточнения абстракции.

\begin{enumerate}
\item Уточнение производится в процессе анализа. При обнаружении пары состояний, составляющих состояние гонки, оба пути проверяются на достижимость. Если найденная ошибка подтверждается, она отмечается, как подтвержденная и анализ продолжается.
Этот вариант уточнения очень похож на классический вариант: при обнаружении ошибки абстракция уточняется до тех пор, пока ошибка либо не подтвердится, либо не опровергнется.
Такой подход обладает существенным недостатком: для корректного завершения анализа, требуется построить очень точную абстракцию. 
В случае, если анализируемый код содержит сотни тысяч строк кода, построение точной абстракции требует колоссального времени. 
Более эффективно в этом случае гибко задавать ограничения на ресурсы, чтобы иметь возможность завершить анализ в любой момент, хотя это и повлечет за собой некоторое снижение точности. 
Это позволяет сделать второй подход к уточнению.

\item Уточнение всех путей производится в тот момент, когда абстракция полностью построена. Все обнаруженные состояния гонки проверяются на истинность, и, в случае необходимости, абстракция перестраивается. 
Существенным недостатком этого подхода является большой объем лишней работы в том случае, если неточность абстракции затрагивает множество состояний гонки.
Тогда проверка каждой из них будет давать один и тот же результат.
Однако, возможно применение некоторых оптимизаций, которые позволяют сократить время на такую бесполезную работу. 
\end{enumerate}

Схема основного варианта

Оптимизированный вариант?

\section{Печать и визуализация} \label{sect_impl_visualiztion}

Формат витнесов

Структура графа пути

Так размещается таблица:

\begin{table} [htbp]
  \centering
  \changecaptionwidth\captionwidth{15cm}
  \caption{Название таблицы}\label{Ts0Sib}%
  \begin{tabular}{| p{3cm} || p{3cm} | p{3cm} | p{4cm}l |}
  \hline
  \hline
  Месяц   & \centering $T_{min}$, К & \centering $T_{max}$, К &\centering  $(T_{max} - T_{min})$, К & \\
  \hline
  Декабрь &\centering  253.575   &\centering  257.778    &\centering      4.203  &   \\
  Январь  &\centering  262.431   &\centering  263.214    &\centering      0.783  &   \\
  Февраль &\centering  261.184   &\centering  260.381    &\centering     $-$0.803  &   \\
  \hline
  \hline
  \end{tabular}
\end{table}

\begin{table} [htbp]% Пример записи таблицы с номером, но без отображаемого наименования
	\centering
	\parbox{9cm}{% чтобы лучше смотрелось, подбирается самостоятельно
        \captiondelim{}% должен стоять до самого пустого caption
        \caption{}%
        \label{tbl:test1}%
        \begin{SingleSpace}
    	\begin{tabular}{ | c | c | c | c |}
    	\hline
    	Оконная функция	& ${2N}$ & ${4N}$	& ${8N}$	\\ \hline
    	Прямоугольное 	& 8.72 	 & 8.77		& 8.77		\\ \hline
    	Ханна		& 7.96 	 & 7.93		& 7.93		\\ \hline
    	Хэмминга	& 8.72 	 & 8.77		& 8.77		\\ \hline
    	Блэкмана	& 8.72 	 & 8.77		& 8.77		\\ \hline
    	\end{tabular}%
    	\end{SingleSpace}
	}
\end{table}

Таблица \ref{tbl:test2} "--- пример таблицы, оформленной в~классическом книжном варианте или~очень близко к~нему. \mbox{ГОСТу} по~сути не~противоречит. Можно ещё~улучшить представление, с~помощью пакета \verb|siunitx| или~подобного.

\begin{table} [htbp]%
    \centering
	\caption{Наименование таблицы, очень длинное наименование таблицы, чтобы посмотреть как оно будет располагаться на~нескольких строках и~переноситься}%
	\label{tbl:test2}% label всегда желательно идти после caption
    \renewcommand{\arraystretch}{1.5}%% Увеличение расстояния между рядами, для улучшения восприятия.
    \begin{SingleSpace}
	\begin{tabular}{@{}@{\extracolsep{20pt}}llll@{}} %Вертикальные полосы не используются принципиально, как и лишние горизонтальные (допускается по ГОСТ 2.105 пункт 4.4.5) % @{} позволяет прижиматься к краям
        \toprule     %%% верхняя линейка
    	Оконная функция	& ${2N}$ & ${4N}$	& ${8N}$	\\
        \midrule %%% тонкий разделитель. Отделяет названия столбцов. Обязателен по ГОСТ 2.105 пункт 4.4.5 
    	Прямоугольное 	& 8.72 	 & 8.77		& 8.77		\\
    	Ханна		& 7.96 	 & 7.93		& 7.93		\\
    	Хэмминга	& 8.72 	 & 8.77		& 8.77		\\
    	Блэкмана	& 8.72 	 & 8.77		& 8.77		\\
        \bottomrule %%% нижняя линейка
	\end{tabular}%
   	\end{SingleSpace}
\end{table}

%\newpage
%============================================================================================================================

\clearpage