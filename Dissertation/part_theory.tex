\chapter{Теория}
\label{chapter_theory}

\section{Основные определения}
В этом разделе представлены основные определения параллельной программы и достижимых конкретных состояний в программе.

Будем рассматривать простой императивный язык программирования, в котором поддерживаются операторы присваивания (assignment), проверки условия (assumption), захват и освобождение примитивов синхронизации (acquire/release) и создание потоков (thread\_create)\footnote{Реализация основана на инструменте \cpachecker, который работает с программами на языке Си}.

Параллельная программа представляется автоматом потока управления (англ. Control Flow Automaton, CFA), который состоит из множества вершин $L$  и множества соединяющих их ребер $G$ .
Множество $L$ - это множество всех точек программы (англ. program location), множество $G \subseteq L \times Ops \times L$, где $Ops$ - это множество всех операций программы.
Так, отдельная дуга $g \in G, g = (l_1, op, l_2)$ моделирует операцию $op$, которая выполняется в программе, когда управление переходит из точки $l_1$ в точку $l_2$.
Операция создания нового потока создает новый поток с идентификатором из множества $T$ и новый поток начинает свое выполнение из некоторой точки программы из множества $L$.
Множество всех переменных программы, которые встречаются в операциях $assignment$ и $assumption$ обозначается как $X$.
Будем считать, что переменные принимают только значения лежащие в $\mathbb{Z}$.
Подмножество $X$, которое содержит все локальные переменные программы, обозначается как $X^{local}$, а подмножество, содержащее все глобальные переменные, -  $X^{global}$. 
%(to simplify presentation all threads have the same set of local variables) 
Операции захвата и освобождения примитивов синхронизации определены над множеством специальных переменных $S: S \cap X = \emptyset$.
Далее мы будем называть примитив синхронизации, связанный с переменной $s \in S$ блокировкой $s$.
Переменные из множества $S$ принимают значения из $\mathcal{T}=T \cup \{\bot_T\}$.
При этом, $s \mapsto t, t \in T$ означает, что блокировка $s$ захвачена потоком $t$, а $s \mapsto \bot_T$ означает, что эта блокировка не захвачена.

\emph{Конкретным состоянием} параллельной программы называется четверка $(c_{pc}, c_l, c_g, c_s)$, где
\begin{enumerate}
\item Отображение $c_{pc}: T \to L$ является частичной функцией из идентификаторов потока во множество точек программы.
Каждое такое состояние задает точку в программе, в которой находится каждый из потоков.
\item Отображение $c_l: T \to C^{local}$ является частичной функций из множества идентификаторов потока во множество присваиваний локальным переменным их значений. $C^{local}: X^{local} \to \mathbb{Z}$ - отображение, которое задает каждой переменной из $X^{local}$ ее значение из $\mathbb{Z}$.
\item $c_g: X^{global} \to \mathbb{Z}$ задает значения глобальных переменных программы.
\item $c_s: S \to \mathcal{T}$ задает значения блокировок. 
\end{enumerate}
Множество всех возможных конкретных состояния программы обозначим через $C$.

Отображения $c_{pc}$ и $c_l$ представляют локальные части конкретного состояния для каждого потока, а $c_g$ и $c_s$ представляют глобальную часть конкретного состояния, не зависящую от потока.
Обозначим $dom$ область определения частичной функции, например, $dom(c_{pc})=\{ t \mid \exists (t, l) \in c_{pc} \land t \in T \land l \in L \}$.
Будем использовать обозначение $\qdot$ для замены параметра, который является несущественным.
Например, предыдущее определение может быть записано следующим образом $dom(c_{pc})=\{ t \mid \exists (t, \qdot) \in c_{pc} \land t \in T\}$.

Каждое состояние $c=(c_{pc}, c_l, c_g, c_s)\in C$ должно удовлетворять условию $dom(c_{pc})=dom(c_l)$, которое означает, что области определения локальных частей состояния находятся в консистентном состоянии.
Будем использовать обозначение $dom(c)$, как область значения локальных частей состояния, то есть $dom(c)=dom(c_{pc})=dom(c_l)$.

Под отношением переходов, помеченным дугой $g$ будем понимать $\tc{g,t} \subseteq C \times G \times T \times C$, где дуга $g \in G$, а идентификатор потока $t \in T$.
Переход  $c_1 \tc{g,t} c_2, c_1, c_2 \in C$ моделирует переход программы из состояния $c_1$ в состояние $c_2$ при выполнении потоком $t \in T$ операции на дуге $g \in G$.
Для полноты будем считать, что существует специальный $\varepsilon$-переход из каждого состояния в себя:
$\forall c \in C, t \in T: c \tc{\varepsilon, t} c$.

Определим множество конкретных переходов $\mathcal{T}=C\times G \times T$.
Конкретный переход $\tau \in \mathcal{T}$ -- это тройка $\tau = (c, g, t)$. 
Будем писать $\tau_1 \tcarrow \tau_2$, если $\exists c_3 \in C: c_1 \tc{g_1, t_1} c_2 \tc {g_2, t_2} c_3$.

Для всех $c=(c_{pc}, c_l, c_g, c_s), c'=(c'_{pc}, c'_l, c'_g, c'_s) \in C$, $g = (l, \cdot, l')\in G$, $t\in T$ любой переход $c \tc{g, t} c'$ должен удовлетворять следующим требованиям:
\begin{enumerate}
\item Переход начинается в состоянии $c$: $t\in dom(c_{pc}) \land c_{pc}(t)=l$.
\item При выполнении операции поток $t$ переходит в точку $l'$: $c'_{pc}(t)=l'$.
\item Каждый переход $c \tc{g,t} c'$ может изменить только локальную часть состояния, которая соответствует потоку $t$ и, возможно, глобальную часть состояния, то есть локальные части других потоков остаются неизменны.
Формально
$\forall t'\in T: (t'\neq t) \land (t \in dom(c_{pc})\cap dom(c'_{pc})) \Rightarrow c'_{pc}(t')=c_{pc}(t') \land c'_l(t')=c_l(t')$.
\end{enumerate}

Полное отношение переходов $\tcarrow$ определяется как объединение по всехм переходам: 
$\tcarrow = \displaystyle\bigcup_{g \in G,t \in T} \tc{g,t}$.
Будем обозначать $c \tc{g, t} c'$, если $(c, g, t, c') \in \tcarrow$, и
$c \tc{g} c'$, если $\exists t\in T: c \tc{g,t} c'$, и 
$c \tcarrow c'$, если $\exists g\in G: c \tc{g} c'$. 
%A set $r \subseteq C$ is called region.
%A concrete state $c_n$ is reachable from a region $r$, denoted by $c_n \in Reach_{\tcarrow}(r)$, if there exists a sequence of concrete states $\langle c_0, c_1, ..., c_n \rangle$ such that $c_0 \in r$ and $\forall i : 1 \leq i \leq n : c_{i-1} \tcarrow c_i$.

%define regular semantics
Обозначим через $eval(c, t, expr)$ значение выражения $expr$ над переменными из $X^{local} \cup X^{global}$ и со значениями этих переменных из конкретного состояния $c \in C$ для потока с идентификатором $t \in T$. %TODO need more?

Далее определим семантику операций в программе.

\subsection{Проверка условия}
Для дуги $g = (l, assume(expr), l') \in G$, $t\in T$, $l, l' \in L$ существует переход $c \tc{g, t} c'$, $c=(c_{pc}, c_l, c_g, c_s)$, $c'=(c'_{pc}, c'_l, c'_g, c'_s) \in C$ в том и только в том случае, если
\begin{itemize}
\item $dom(c)=dom(c')$ -- переход не меняет множество активных потоков;
\item $eval(c, t, expr) \neq 0$ -- значение проверяемого выражение не равно нулю.
\end{itemize}

\subsection{Присваивание}
Для дуги $g = (l, assign(x, expr), l') \in G$, $t\in T$, $l, l' \in L$ существует переход $c \tc{g, t} c'$, $c=(c_{pc}, c_l, c_g, c_s)$, $c'=(c'_{pc}, c'_l, c'_g, c'_s) \in C$ в том и только в том случае, если
\begin{itemize}
\item $dom(c)=dom(c')$ -- переход не меняет множество активных потоков;
\item 
\begin{align}
c'_l(t)(x')=
\begin{cases}
eval(c, t, expr)& \text{, если $x' = x$} \\
c_l(t)(x') & \text{, если $x' \in X^{local} \land x'\neq x$}
\end{cases} \nonumber
\end{align}
\item
\begin{align}
c'_g(x')=
\begin{cases}
eval(c, t, expr)& \text{, если $x' = x$} \\
c_g(x') & \text{, если $x' \in X^{global} \land x'\neq x$}
\end{cases} \nonumber
\end{align}
\item $c'_s = c_s$ -- блокировки не меняют свои значения.
\end{itemize}

%define acquire|release operations
\subsection{Операции с примитивами синхронизации}
Используем похожее определение на то, которое было дано в~\cite{TAR}. 
Предполагаем, что операция $acquire(s)$ в потоке $t \in T$, где $s\in S$ - блокировка, имеет следующую семантику: 
если $s \mapsto \bot_T$ в предыдущем состоянии, тогда $s \mapsto t$ в следующем состоянии, и эта операция (сравнение и изменение состояния блокировки) производится атомарно за один переход.
%This encoding is essential to prove absence of data races by thread-modular analysis as described in~\cite{}. %qader
%For example, if you use semantics $if$ $(s==0)$ $s=1$ then thread-modular approach will not work.

Формально, для дуги $g = (l, acquire(s), l') \in G$ и $t\in T$, $l, l' \in L$ существует переход
$c \tc{g, t} c'$, $c=(c_{pc}, c_l, c_g, c_s)$, $c'=(c'_{pc}, c'_l, c'_g, c'_s) \in C$
тогда и только тогда, когда 
\begin{itemize}
\item $dom(c)=dom(c')$ -- переход не меняет множество активных потоков;
\item $c'_l=c_l$ -- переход не меняет значения локальных переменных;
\item $c'_g = c_g$ -- переход не меняет значения глобальных переменных;
\item $c_s(s) = \bot_T \land c'_s(s)=t \land \forall s'\in S: s'\neq s \Rightarrow c'_s(s')=c_s(s')$ -- никакие другие блокировки не меняют свое значение.
\end{itemize}

Предполагаем, что операция $release(s)$ в потоке $t \in T$ имеет следующую семантику:
если в начальном состоянии блокировка $s \in S$ была захвачена тем же потоком, то есть $s \mapsto t$, то в следующем состоянии эта блокировка освобождается, то есть $s \mapsto \bot_T$. Операция проходит атомарно.

Формально, для дуги $g = (l, release(s), l')\in G$ и $t\in T$, $l, l' \in L$ существует переход
$c \tc{g, t} c'$, $c=(c_{pc}, c_l, c_g, c_s)$, $c'=(c'_{pc}, c'_l, c'_g, c'_s) \in C$ тогда и только тогда, когда 
\begin{itemize}
\item $dom(c)=dom(c')$ -- переход не меняет множество активных потоков;
\item $c'_l(t)=c_l(t)$ -- переход не меняет значения локальных переменных;
\item $c'_g = c_g$ -- переход не меняет значения глобальных переменных;
\item $c_s(s)=t \land c_s'(s)=\bot_T \land \forall s'\in S: s'\neq s \Rightarrow c'_s(s')=c_s(s')$ -- никакие другие блокировки не меняют свое значение
\end{itemize}

%define thread_create
\subsection{Создание потоков}
Определим семантику $thread\_create(l_\nu)$ таким образом, чтобы текущий поток при выполнении этого оператора перешел в следующую точку программы после $thread\_create$, а новый поток создается с новым идентификатором $\nu \in T$, который добавляется в локальную часть состояния.
Созданный поток начинает свое выполнение из точки программы $l_\nu \in L$.

Заметим, что такое определение позволяет поддерживать анализ программ с неограниченным количеством потоков, так как $thread\_create$ может встречаться в цикле.

Для дуги $g = (l, thread\_create(l_\nu), l')$ существует переход
$c \tc{g, t} c'$, $c=(c_{pc}, c_l, c_g, c_s)$, $c'=(c'_{pc}, c'_l, c'_g, c'_s) \in C$, $\nu \in T$ тогда и только тогда
\begin{itemize}
\item $\nu \notin dom(c) \land dom(c') = dom(c) \cup \{ \nu\}$ -- поток с идентификатором $\nu$ добавляется во множество потоков;
\item $c'_{pc}(t)=l'$ -- счетчик команд в родительском потоке переходит на следующую команду $l'$;
\item $c'_{pc}(\nu)=l_\nu$ --  счетчик команд в дочернем потоке устанавливается в начальную позицию $l_\nu$;
\item $c'_l(\nu)=\emptyset$ -- локальные переменные созданного потока не инициализированы;
\item $c'_l(t)=c_l(t) \land c'_g = c_g \land c'_s = c_s$ -- все остальные части конкретного состояния остаются без изменений.
\end{itemize}

%TODO example
%For example, consider an edge $g = (thread\_create)$ of thread creation: 
%$(2, c_1^1, c_1^2, c_1^g) \tc{g, 1} (3, c_2^1, c_1^2, c_1^3, c_1^g)$, where the $c_1^3$ is local state of the new thread.

%TODO we demonstrate reachability on data race conditions
%interesting -- requires at least two threads

\subsection{Ошибка в программе}

Во многих методах статической верификации используется понятие ошибочного состояния. 
Такие методы решают задачу достижимости и пытаются доказать, что заданное ошибочное состояния недостижимо.
Примером такого определения является использование конструкций типа assert. 
В случае нарушения логического условия, записанного в качестве параметра, инструмент фиксирует ошибку.

Такое определение ошибки является достаточно общим, так как позволяет сформулировать различные свойства программы, которые требуется верифицировать. 
Еще одной важной особенностью является то, что такое определение с одинаковым успехом может применяться как к последовательным программам, так и к параллельным. 

Состояние гонки обычно определяются с помощью такой конструкции, как последовательность

\begin{small}
\begin{lstlisting}
variable = expression;
assert(variable == expression);
\end{lstlisting}
\end{small}

Основным минусом такого подхода является то, что при поиске состояний гонки  реальных программах не известно, какая именно переменная может модифицироваться из нескольких потоков, а значит, придется расставлять assert после каждой записи в переменную. 
Поэтому, хотя такое определение ошибки тоже имеет место и поддерживается в предлагаемой теории, дадим более практичное определение.

\begin{defn}
\label{raceDef}
Определим \textbf{состояние гонки} как конкретное состояние $c$ такое, что $\exists c_1, c_2 \in C$, $g_1, g_2 \in G$, $t_1, t_2 \in T$, $t_1 \neq t_2 : c \tc{g_1, t_1} c_1 \land c \tc{g_2, t_2} c_2$ и операции $g_1, g_2$ выполняются над одной и той же глобальной переменной $x \in X^{global}$ и хотя бы одна операция является присваиванием (то есть $assign(x, expr)$).
\end{defn}

%Note, that acquire/release operations are special ones and operate on lock variables only.


\section{Адаптивный статический анализ с абстрактными переходами}
\label{sect_cpata}

\newcommand{\update}{update}
\newcommand{\frontier}{frontier}

В классической теории~\cite{BeyerCPA07,Beyer08}, абстрактное состояние представляет собой множество конкретных состояний программы.
В предлагаемом расширении теории абстрактное состояние является частичным, то есть оно может не представлять ни одного состояния программы.
Поэтому функция конкретизации, которая предоставляет соответствие между абстрактными состояниями и конкретными, в расширенной теории отличается от классической: она определяется на множестве абстрактных элементов.
Это является следствием того, что полное конкретное состояние может быть получено только из нескольких частичных состояний, описывающих потоки по-отдельности.

Частичными также являются и абстрактные переходы.
Поэтому анализ не может гарантировать, что 
Поэтому анализ не может гарантировать, что последующие конкретные переходы будут достижимы за один шаг оператора transfer.
В общем случае для этого может понадобиться $k$ шагов. Для подхода с отдельным анализом потоков $k=2$: анализ выполняет обычный переход в потоке, а затем распространяет его на все остальные потоки в качестве перехода в окружении. Это требует двух итераций алгоритма.

Определим формально \emph{адаптивный статический анализ с абстрактными переходами} для параллельных программ $\mathbb{D}=(D$, $\Pi$, $\tatarrow$, $merge$, $stop$, $prec$).
Он состоит из абстрактного домена $D$, 
множество точности $\Pi$, 
отношения переходов $\tatarrow$,
оператора слияния $merge$, оператор останова $stop$, функции уточненения $prec$.
Несмотря на то, что сам операторы остались теми же, что и в классической версии теории, они претерпели некоторые изменения.
Эти операторы будут подробно рассмотрены далее.

\begin{itemize}

\item \emph{Абстрактный домен}  $D=(\mathcal{T}, \mathcal{E},\conc{\cdot})$ определяется множеством $\mathcal{T}$ конкретных переходов ($\mathcal{T} \subseteq C \times G \times T$), полурешеткой $\mathcal{E}$ абстрактных переходов и функцией конкретизации $\conc{\cdot}$.
Полурешетка 
$\mathcal{E}=(E, \top, \bot, \sqsubseteq, \sqcup)$ состоит из (возможно, бесконечного) множества $E$ элементов абстрактного домена, верхнего элемента $\top \in E$, нижнего элемента $\bot \in E$, частичного порядка $\sqsubseteq \subseteq E \times E$ и функции $\sqcup:E \times E \rightarrow E$ (оператор объединения состояний).
Функция $\sqcup$ возвращает наименьший элемент решетки, который больше, чем каждый из двух ее аргументов, а символы $\top$ и $\bot$ обозначают наибольший и наименьший элемент решетки $E$ соответственно. 

Функция конкретизации $\conc{\cdot}: 2^E \rightarrow 2^\mathcal{T}$ отображает каждое множество абстрактных переходов $R \subseteq E$ на множество его значений, то есть на множество конкретных состояний программы, которое оно представляет.
Основным отличием от классической функции конкретизации – это определение на множестве абстрактных элементов.
Это объясняется тем, что суммарное знание для множества частичных состояний может быть больше, чем знание для одного частичного состояния, то есть,  
$$\forall R\subseteq E: \conc{R} \supseteq \bigcup_{e\in R}{\conc{\{e\}}}$$

Для корректности анализа программы абстрактный домен должен удовлетворять следующим требованиям:

\begin{equation}
\label{cpa_conc_eq_0}
\forall R \subseteq \overline{R} \subseteq E: \conc{R} \subseteq \conc{\overline R}
\end{equation}

\begin{equation}
\label{cpa_conc_eq_2}
\forall e, e' \in E, R \subseteq E : e \sqsubseteq e' \implies \conc{R \cup e} \subseteq \conc{R \cup e'}
\end{equation}

\item Множество \emph{точности} $\Pi$ определяет уровень детализации абстрактного домена. 
Анализ использует элементы из $\Pi$, чтобы определять различный уровень точности для различных абстрактных элементов.
Пара $(e, \pi)$ называется абстрактным элементом $e$ с точностью $\pi$.
Операторы на абстрактном домене параметризуются уровнем точности.

Для $R \subseteq E \times \Pi$ обозначаем
$\conc{R} = \conc{\bigcup_{(e,\pi)\in R}\{e\}}$.

\item Отношение переходов $\tatarrow: E\times \Pi \times 2^{E\times \Pi} \times E $ определяет для каждого частичного перехода $e$ с точностью $\pi$ и множества достигнутых частичных переходов $\widehat{R}$ следующие возможные абстрактные переходы $e'$.
Будем писать $(e, \pi) \tat{\widehat{R}} e'$, если $(e, \pi, \widehat{R}, e') \in \tatarrow$.

%TODO: do we need g,t on the arrow? 
%and $e \tatarrow (e', \pi)$ if $\exists g \in G, t \in T: e \tat{g,t} (e', \pi)$.

Обозначим $Reach^k$ как
\begin{equation}
\label{reach_k}
\begin{aligned}
& \forall R \subseteq E: Reach^0(R) = R \\
& \forall k\ge 1: Reach^{k+1}(R) = \bigcup_{e \in Reach^{k}(R)}{\{e' \mid e \tatarrow e'\}} \cup Reach^{k}(R) \\
\end{aligned}
\end{equation}

Далее мы будем писать $Reach(R) = Reach^1(R)$. 

Легко показать следующие утверждения, которые понадобятся в дальнейшем:
% \begin{equation}
% \label{cpa_reach_dist_1}
% \forall k \ge 1, A,B \subseteq E: \\
% Reach^k(A \cup B) =  Reach^k(A) \cup Reach^k(B)
% \end{equation}
%
% \begin{equation}
% \label{cpa_reach_dist_2}
% \forall k \ge 1, A,B \subseteq E, A \subseteq B: \\
% Reach^k(A) \subseteq  Reach^k(B)
% \end{equation}

Требование к отношению переходов в классическом CPA~\cite{Beyer08} является слишком строгим.
В некоторых случаях, в частности, при анализе многопоточных программ, более эффективным является аппроксимировать переходы из $\conc{\widehat{R}}$  в несколько шагов:
\begin{itemize}
\item применение переходов из частичных состояний по отдельности;
\item применение некоторых шагов позже, например, переходов по окружению.
\end{itemize}

Требованием к отношению переходов является аппроксимация сверху множества конкретных переходов:
\begin{equation}
\label{cpa_transfer_eq}
\begin{aligned}
& \exists k \ge 1: \forall R \subseteq E \times \Pi:\\
& \conc{Reach^k(R)} \supseteq \bigcup_{\tau \in \conc{R}}{\{\tau' \mid \tau \tcarrow \tau'\}}  \\
\end{aligned}
\end{equation}

Таким образом, условие~\ref{cpa_transfer_eq} ослабляет требования на оператор $transfer$ по сравнению с классической теорией CPA.
Оно означает, что анализ может получить все конкретные переходы не за один шаг абстрактного перехода, а после $k$ шагов.
Для анализа каждого потока по-отдельности мы далее увидем, что $k=2$.

%--------------------------------

\item Оператор слияния состояний $merge: E \times E \times \Pi \rightarrow E$ ослабляет второй параметр, используя информацию от первого параметра, и возвращает новое абстрактное состояние с точностью, которая передавалась, как третий параметр.
Оператор \emph{merge} должен удовлетворять следующим требованиям:
\begin{equation}
\label{cpa_merge_eq}
\begin{aligned}
&\forall e, e' \in E, \pi \in \Pi : &e' \sqsubseteq merge(e, e', \pi)
\end{aligned}
\end{equation}

\item Оператор останова $stop: E \times 2^{E \times \Pi} \times \Pi \rightarrow \mathbb{B}$ проверяет, является ли абстрактный переход, передаваемый, как первый параметр с точностью, передаваемой как третий параметр, покрытым множеством абстрактных переходов, которые передаются вторым параметром.
%Оператор останова может, например, проходить по элементам из множества $R$, который передается как второй параметр и искать такой элемент, который больше ($\sqsubset$), чем проверяемый элемент.
%, or -- if $D$ is a powerset domain\footnote{A powerset domain is an abstract domain s.t. $\tconc{e \sqcup e'}{t} = \tconc{e}{t} \cup \tconc{e'}{t}$} -- can join the elements of $R$ to check if $R$ subsumes the first parameter. 
Оператор останова должен удовлетворять следующему требованию:
\begin{equation}
\label{cpa_stop_eq}
\begin{aligned}
&\forall e \in E, R \subseteq E, \pi \in \Pi:\\
&stop(e, R, \pi) \implies\forall \hat R \subseteq E: \conc{\{e\}\cup \hat R} \subseteq \conc{R \cup \hat R}
\end{aligned}
\end{equation}

\item Функция настройки точности $prec:E \times \Pi \times 2^{E \times \Pi} \rightarrow E \times \Pi$ вычисляет новое абстрактное состояние и новую точность для данного абстрактного состояния и множества асбтрактных состояний.
Эта функция может производить ослабление абстрактного состояния.
Она должна удовлетворять следующему требованию:

\begin{equation}
\label{cpa_prec_eq}
\begin{aligned}
& \forall e, e' \in E, \pi, \pi' \in \Pi, R \subseteq E \times \Pi:\\
& (e', \pi') = prec(e, \pi, R) \implies e \sqsubseteq e'
\end{aligned}
\end{equation}

\end{itemize}

В целом, множество точности $\Pi$, оператор останова $stop$, оператор объединения $merge$, оператор настройки точности $prec$ остаются такими же, как и в классической теории CPA.

%end of CPA definition
\section{Алгоритм с частичными состояниями}

Алгоритм~\ref{cpata_algorithm_ps} представляет основной алгоритм, который вычисляет множество достижимых абстрактных переходов.
Он также не претерпел никаких изменений относительно классической теории CPA за исключением расширения оператора transfer.
 
\begin{algorithm}
% Plain Algorithm
 \KwData{
 адаптивный статический анализ с частичными состояниями $\mathbb{D}$,
 {начальный абстрактный переход $e_0$ с точностью $\pi_0 \in \Pi$},
 {множество $reached$ элементов из $E \times \Pi$},
 {множество $waitlist$ элементов из $2^{E \times \Pi}$}
 }
\KwResult{множество достижимых состояний $reached$}
 $waitlist := \{(e_0, \pi_0)\}$\;
 $reached := \{(e_0, \pi_0)\}$\;

 \While{$waitlist \neq \emptyset$}{
  pop $(e, \pi)$ from $waitlist$\;  
  \For{$e'$ in $(e, \pi) {\color{blue} \tat{reached}} e')$ }{
   $(\widehat{e}, \widehat{\pi})=prec(e',\pi,reached)$\;
   \For{each $(e'', \pi'') \in reached$}{
    $e_{new} = merge(\widehat{e}, e'', \widehat{\pi})$\;
    \If{$e_{new} \neq e''$}{
     $waitlist := waitlist \setminus \{(e'',\pi'')\} \cup \{(e_{new},\pi'')\}$\;
     $reached := reached \setminus \{(e'',\pi'')\} \cup \{(e_{new},\pi'')\}$\;
    }
   }
   \If{$!stop(\widehat{e}, reached, \widehat{\pi})$}{
    $waitlist := waitlist \cup \{(\widehat{e}, \widehat{\pi})\}$\;
    $reached := reached \cup \{(\widehat{e}, \widehat{\pi})\}$\;
   }
  }
 }%repeat

% Thin about the caption
 \caption{Algorithm $CPA(\mathbb{D}, e_0, \pi_0)$}
 \label{cpata_algorithm_ps}
\end{algorithm} 
 
\begin{thrm}
\label{thrm_soundness}
(Soundness) Для заданного адаптивного статического анализа с частичными состояниями $\mathbb{D}$ и начального абстрактного состояния $e_0$ с точностью $\pi_0$, алгоритм $CPA$ вычисляет множество абстрактных состояний, которое аппроксимирует сверху множество достижимых конкретных состояний:

$$\conc{CPA_{PS}(\mathbb{D}, e_0, \pi_0)} \supseteq Reach_{\tcarrow}(\conc{\{e_0\}})$$

\end{thrm}

Доказательство состоит из двух частей. Сначала доказывается, что алгоритм~\ref{cpata_algorithm_ps_without_waitlist} без использов
ания структуры waitlist аппроксимирует сверху множество достижимых конкретных состояний. Вторым шагом показывается, что алгоритм~\ref{cpata_algorithm_ps} эквивалентен алгоритму~\ref{cpata_algorithm_ps_without_waitlist}.

\begin{algorithm}[H]
% General Algorithm without waitlist
 \KwData{
 адаптивный статический анализ с частичными состояниями $\mathbb{D}$,
 {начальное абстрактное состояние $e_0$ с точностью $\pi_0 \in \Pi$},
 {множество $reached$ из элементов $E \times \Pi$}
 }
\KwResult{множество достижимых абстрактных состояний $reached$}
 $reached := \{e_0,\pi_0\} $\;
 
 \For{each $e \in reached$ }{
  \For{each $e'$: $e \tat{reached} (e', \pi')$ }{
   $(\widehat{e}, \widehat{\pi})=prec(e',\pi',reached)$\;
   \For{each $(e'', \pi'') \in reached$}{
    $e_{new} = merge(\widehat{e}, e'', \widehat{\pi})$\;
    \If{$e_{new} \neq e''$}{
     $reached := reached \setminus{\{(e'', \pi'')\}} \cup \{(e_{new}, \widehat{\pi})\}$\;
    }
   }
   \If{$!stop(\widehat{e}, reached, \widehat{\pi})$}{
    $reached := reached \cup \{(\widehat{e}, \widehat{\pi})\}$\;
   }
  }
 }%repeat

 \caption{$\overline{CPA}(\mathbb{D}, e_0, \pi_0)$}
 \label{cpata_algorithm_ps_without_waitlist}
\end{algorithm}

\begin{proof}
Нужно доказать, что $\conc{\overline{CPA}(\mathbb{D}, e_0, \pi_0)} \supseteq Reach_{\tcarrow}(\conc{\{e_0\}})$.
Определим рекурсивную функцию $\overline{CPA}_n(\mathbb{D}, e_0, \pi_0)$, которая будет вычислять множество достижимых состояний алгоритма на n-той итерации.
 Обозначим ее для краткости $reached_n \equiv \overline{CPA}_n(\mathbb{D}, e_0, \pi_0)$.

 \begin{equation}
 \label{cpa_recursive_algorithm}
 \begin{aligned}
 & reached_0 = \{e_0\} \\
 & s_n = \{e' \mid e \in reached_n \land e \tat{reached_n} e'\} \\
 & s'_n = \{\widehat{e} \mid \widehat{e} = prec(e',\pi',reached_n) \land e' \in s_n\} \\
 & \widehat{s}_n = \{\overline{e} \mid \exists e^1 \in reached_n, \widehat{e} \in s'_n \ldotp \overline{e} = merge(\widehat{e}, e^1, \pi))\} \\
 & \widehat{s}^1_n = reached_n \setminus \widehat{s}_n \\
 & \widehat{s}^2_n = \widehat{s}_n \setminus reached_n \\
 & \tilde{s}_n = \{e \mid e \in s' \land !(stop(e, reached_n, \pi))\} \\
 & reached_{n+1} = reached_n \setminus \widehat{s}^1_n \cup \widehat{s}^2_n \cup \tilde{s}_n = \widehat{s}_n \cup \tilde{s}_n\\
 \end{aligned}
 \end{equation}

Покажем, что 
 \begin{equation}
 \label{algorithm_lemma_1}
 \begin{aligned}
 \conc{reached_{n+1} \cup \hat{R}} \supseteq \conc{Reach(reached_n) \cup \hat{R}} \end{aligned}
 \end{equation}

 \begin{align*}
 & \conc{reach_{n+1} \cup \hat{R}} = (def.) = \conc{reached_n \setminus \widehat{s}^1_n \cup \widehat{s}^2_n \cup \tilde{s}_n \cup \hat{R}} \supseteq \\
 & (eq.~\ref{cpa_conc_eq_2},\ref{cpa_merge_eq}) \supseteq \conc{reached_n  \cup \tilde{s}_n \cup \hat{R}}  
  \supseteq (eq.~\ref{cpa_conc_eq_2},\ref{cpa_stop_eq})\\
  & \supseteq \conc{reached_n  \cup s'_n \cup \hat{R}}  \supseteq (eq.~\ref{cpa_conc_eq_2},\ref{cpa_prec_eq}) \supseteq \conc{reached_n  \cup s_n \cup \hat{R}} =\\
  &= (def.~\ref{reach_k}) = \conc{Reach(reached_n) \cup \hat{R}}
 \end{align*}
 
 Теперь докажем по индукции, что 
 
 \begin{equation}
 \label{algorithm_invariant_1}
 \begin{aligned}
 \forall k \in \mathbb{N}, \conc{reach_{n+k} \cup \hat{R}} \supseteq \conc{Reach^k(reached_n) \cup \hat{R}}
 \end{aligned}
 \end{equation}
 
 При $k=0$ отношение тривиально: $\conc{reach_{n} \cup \hat{R}} \supseteq \conc{reached_n \cup \hat{R}}$.
 Пусть теперь инвариант~\ref{algorithm_invariant_1} выполнен при некотором $k$, рассмотрим его при $k+1$:
 \begin{align*}
 & \conc{reach_{n+k+1} \cup \hat{R}} \supseteq (eq.~\ref{algorithm_lemma_1}) \supseteq \conc{Reach(reached_{n+k}) \cup \hat{R}} = \\
 & = (def.) = \conc{reached_{n+k} \cup \{e' \mid e \tat{reached_{n+k}} e' \land e \in reached_{n+k}} \cup \hat{R}\} \\
 & \supseteq (eq.~\ref{algorithm_invariant_1}) \supseteq \conc{Reach^k(reached_n) \cup \\
 & \{e' \mid e \tat{reached_{n+k}} e' \land e \in reached_{n+k}\} \cup \hat{R}} \supseteq (eq.~\ref{cpa_new_transfer_req}) \\
 & \supseteq \conc{Reach^k(reached_n) \cup \{e' \mid e \tat{Reach^k(reached_n)} e' \land e \in Reach^k(reached_n)\} \\ 
 & \cup \hat{R}} = (def.~\ref{reach_k}) = \conc{Reach^{k+1}(reached_n) \cup \hat{R}}
 \end{align*}

Таким образом, мы имеем,
\begin{equation}
 \label{algorithm_invariant_2}
 \begin{aligned}
 \conc{reach_{n+k}} \supseteq \conc{Reach^k(reached_n)} \supseteq (eq.~\ref{cpa_transfer_eq}) \supseteq \bigcup_{\tau \in \conc{reached_n}}{\{\tau' \mid \tau \tcarrow \tau'\}}
 \end{aligned}
 \end{equation}


Когда алгоритм заканчивает свое выполнение (доходит до неподвижной точки) $reached_n = reached_{n+1}$. 
Обозначим финальное множество, как $Reached = lim_{n \rightarrow \infty}(reached_n)$.
Нам остается доказать, что $\bigcup_{\tau \in \conc{Reached}}{\{\tau' \mid \tau \tcarrow \tau'\}} \supseteq Reach_{\tcarrow}(\conc{\{e_0\}})$.


Покажем, что $\forall \{\tau_i\} \in \mathcal{T}: \tau_0 \in \conc{\{e_0\}} \land \forall 1 \leq k \leq N: \tau_{k} \tcarrow \tau_{k+1} \implies \forall 1 \leq k \leq N: \tau_k \in \conc{Reached}$ по индукции.
Алгоритм~\ref{cpata_algorithm_ps_without_waitlist} не удаляет состояния, поэтому $e_0 \in Reached \lor e_0 \sqsubseteq e' \in Reached$.
Таким образом, $ \tau_0 \in \conc{Reached}$, то есть, базис индукции выполнен.
Предположим, что утверждение выполнено для некоторого $n \in \mathbb{N}$:

\begin{align}
& \forall 1 \leq k \leq n: \tau_k \in \conc{Reached} \nonumber \\ 
& \forall \tau \in \conc{Reached}: \{\tau' \mid \tau \tcarrow \tau'\} \subseteq (eq.~\ref{cpa_transfer_eq}) \subseteq \conc{Reach^k(Reached)} = \\
& = \conc{Reached} \implies \tau_{k+1} \in \{\tau' \mid \tau \tcarrow \tau'\} \subseteq \conc{Reached} \nonumber
\end{align}

Так, мы показали, что $\conc{\overline{CPA}(\mathbb{D}, e_0, \pi_0)} \supseteq Reach_{\tcarrow}(\conc{\{e_0\}})$.


Теперь нам нужно показать, что алгоритм использующий очередь состояний ($waitlist$) эквивалентен алгоритму без нее, то есть, что $\forall e \in \overline{CPA}(\mathbb{D}, e_0, \pi_0) \exists e' \in CPA(\mathbb{D}, e_0, \pi_0): e \sqsubseteq e'$.

Заметим, что итерации алгоритмов абсолютно одинаковые, поэтому изменения полученных состояний являются эквивалентными.
Единственным отличием является то, что $CPA(\mathbb{D}, e_0, \pi_0)$ итерируется по очереди состояний, а $\overline{CPA}(\mathbb{D}, e_0, \pi_0)$ -- по всем возможным подмножествам R.
Два алгоритма могут быть синхронизированы следующим образом: они начинают с одного и того же начального множества $reached$. 
Каждая итерация алгоритма $CPA(\mathbb{D}, e_0, \pi_0)$ повторяется алгоритмом $\overline{CPA}(\mathbb{D}, e_0, \pi_0)$. 
Так как они выполняют одинаковые действия и модифицируют множество $reached$ одинаково, получаемое множество $reached$ будет совпадать у обоих алгоритмов.
Когда $CPA(\mathbb{D}, e_0, \pi_0)$ заканчивает выполнение, $\overline{CPA}(\mathbb{D}, e_0, \pi_0)$ продолжает выполнять все оставшиеся итерации.

Теперь нужно показать, что рассмотренных итераций алгоритма $CPA(\mathbb{D}, e_0, \pi_0)$ будет достаточно для построения финального множества $reached$.

По аналогии с предыдущим пунктом нам потребуется рекурсивное определение функций $reached_n$ и $waitlist_n$:
 \begin{equation}
 \label{cpa_recursive_algorithm_2}
 \begin{aligned}
 & reached_0 = \{e_0\} \\
 & waitlist_0 = \{e_0\} \\
 & e_n = get(waitlist_n) \text{ выдает первое состояние в очереди} \\
 & s_n = \{e'_n \mid e_n \tat{reached_n} e'_n\} \\
 & s'_n = \{\widehat{e}_n \mid \widehat{e}_n = prec(e'_n,\pi',reached_n) \land e'_n \in s_n\} \\
 & \widehat{s}_n = \{\overline{e_n} \mid \exists e^1_n \in reached_n, \widehat{e}_n \in s'_n \ldotp \overline{e_n} = merge(\widehat{e}_n, e^1_n, \pi))\} \\
 & \widehat{s}^1_n = reached_n \setminus \widehat{s}_n \\
 & \widehat{s}^2_n = \widehat{s}_n \setminus reached_n \\
 & \tilde{s}_n = \{e_n \mid e_n \in s'_n \land !(stop(e_n, reached_n, \pi))\} \\
 & reached_{n+1} = reached_n \setminus \widehat{s}^1_n \cup \widehat{s}^2_n \cup \tilde{s}_n = \widehat{s}_n \cup \tilde{s}_n\\
 & waitlist_{n+1} = waitlist_n \setminus \{e_n\} \setminus \widehat{s}^1_n \cup \widehat{s}^2_n \cup \tilde{s}_n
 \end{aligned}
 \end{equation}

Докажем следующий инвариант для всех итераций алгоритмов.

\begin{equation}
\label{cpa_algorithm_equivalance_invariant}
\begin{aligned}
& \forall e \in reached_n: \\
& e \in waitlist_n \lor (\forall \widehat{R} \subseteq E : \conc{\{e' \mid e \tat{reached_n} e'\} \cup reached_n \cup \widehat{R}} \subseteq \conc{reached_n \cup \widehat{R}}) 
\end{aligned}
\end{equation}

Этот инвариант означает, что для любого перехода из $reached_n$ либо он находится в $waitlist_n$, либо все следующие переходы тоже находятся в $reached_n$, то есть в процессе анализа переходы не теряются.

Докажем инвариант~\ref{cpa_algorithm_equivalance_invariant} по индукции.
Для начального шага инвариант выполнен: $reached_0 = \{e_0\} \land waitlist_0 = \{e_0\} \implies e_0 \in waitlist_0$.
Пусть теперь инвариант выполнен для некоторой итерации $k$. Рассмотрим следующую итерацию $k+1$ и возьмем случайный переход $e \in reached_{k+1}$.
Возможны четыре варианта:

\begin{enumerate}
\item $e \in (reached_{k+1} \setminus reached_n) \setminus \{e_n\}$. Для этого состояния ничего не меняется, для него был выполнен инвариант на предыдущей итерации, и будет выполнен на этой.
\item $e = e_k$. На прошлой итерации инвариант был выполнен, так как $e_k \in waitlist_k$, но $e_k \notin waitlist_{k+1}$.
По определению $reached_{k+1} = reached_k \setminus \widehat{s}^1_k \cup \widehat{s}^2_k \cup \tilde{s}_k$ и $\conc{reached_{k+1} \cup \widehat{R}} = \conc{reached_k \setminus \widehat{s}^1_k \cup \widehat{s}^2_k \cup \tilde{s}_k \cup \widehat{R}} \supseteq (eq.~\ref{cpa_merge_eq}) \supseteq \conc{reached_k \cup \tilde{s}_k \cup \widehat{R}} \supseteq (eq.~\ref{cpa_stop_eq}) \supseteq \conc{reached_k \cup s'_k \cup \widehat{R}} \supseteq (eq.~\ref{cpa_prec_eq}) \supseteq \conc{reached_k \cup \{e' \mid e \tat{reached_k} e'\} \cup \widehat{R}}$. Откуда следует $\conc{\{e' \mid e \tat{reached_{k+1}} e'\} \cup reached_{k+1} \cup \widehat{R}} \subseteq \conc{reached_{k+1} \cup \widehat{R}})$.
\item $e \in \widehat{s}^2_{k+1}$. По определению $waitlist_{k+1}$ это означает, что $\widehat{s}^2_{k+1} \subseteq waitlist_{k+1} \implies e \in waitlist_{k+1}$. А значит, инвариант выполнен.
\item $e \in \tilde{s}_k$. Опять же, по определению $waitlist_{k+1}$ это означает, что $\tilde{s}_k \subseteq waitlist_{k+1} \implies e \in waitlist_{k+1}$. А значит, инвариант выполнен.
\end{enumerate}

Инвариант~\ref{cpa_algorithm_equivalance_invariant} выполнен на всех итерациях алгоритма $CPA(\mathbb{D}, e_0, \pi_0)$, включая последнюю, в которой $waitlist_k = \emptyset$, $reached_k = Reached$, поэтому $\conc{\{e' \mid e \tat{Reached} e'\} \cup Reached} \subseteq \conc{Reached}$.
Отсюда следует, что все остальные операции алгоритма $\overline{CPA}(\mathbb{D}, e_0, \pi_0)$ являются бесполезными.
Действительно, пусть $\overline{CPA}(\mathbb{D}, e_0, \pi_0)$ нашел переход $e \in Reached: e \tat{Reached} e' \land e' \notin Reached$.
Используя инвариант мы получаем, что $\conc{\{e'\} \cup Reached} \subseteq \conc{Reached}$. 
То есть, этот абстрактный переход не дает новых конкретных переходов.
Отсюда следует, что

$\conc{\overline{CPA}(\mathbb{D}, e_0, \pi_0)} \subseteq (req.~\ref{cpa_conc_eq_2}) \subseteq \conc{CPA(\mathbb{D}, e_0, \pi_0)}$

Мы доказали следующее неравенство:

$$Reach_{\tcarrow}(\conc{\{e_0\}}) \subseteq \conc{\overline{CPA}(\mathbb{D}, e_0, \pi_0)} \subseteq \conc{CPA(\mathbb{D}, e_0, \pi_0)}$$

\end{proof}

\section{Классический адаптивный статический анализ}
\label{sect_classic_cpa}

В этой части показывается, что классическая теория адаптивного статического анализа может быть представлена, как частный случай теории адаптивного статического анализа с частичными состояниями.

Для этого мы предоставим реализацию операторов алгоритма с частичными состояниями
$\mathbb{R}=(D_R$, $\Pi_R$, $\tatarrow_R$, $merge_R$, $stop_R$, $prec_R$, $\update_R$, $\frontier_R)$
через классические операторы~\cite{Beyer08}: %precision adjustment
$\mathbb{C} = (D_C$, $\Pi_C$, $\tatarrow_C$, $merge_C$, $stop_C$, $prec_C)$.

{\textbf 1.}
Классический домен $D_C=(C,\mathcal{E}_C, \conc{\cdot}_C)$, в котором
$\mathcal{E}_C=(E_C, \top_C, \bot_C, \sqsubseteq_C, \sqcup_C)$.

Определим $D_R$ как $(C,\mathcal{E}_R, \conc{}_R)$, где 
$\mathcal{E}_R = (E_C, \top_C, \bot_C, \sqsubseteq_C)$ (то есть, $E_R=E_C$).

\begin{equation}
\label{cpa_classic_conc_eq}
\begin{aligned}
\forall R\subseteq E_C: \conc{R}_R = \bigcup_{e\in R}{\conc{e}_C}
\end{aligned}
\end{equation}
(конкретизация множества является объединением конкретизации элементов).

{\textbf 2.} $\Pi_R=\Pi_C$

{\textbf 3.} Отношение переходов.
Переход $\hat R \tatarrow_R (e', \pi)$ есть в том и только в том случае, если
$\hat R = \{e\} \land e \tatarrow_C (e',\pi)$.
По определению~\ref{reach_k}, $$Reach(R) = \bigcup_{\widehat{R} \subseteq R}{\{(e', \pi') \mid \widehat{R} \tatarrow (e', \pi')\}} = \bigcup_{\widehat{e} \in R}{\{(e', \pi') \mid \widehat{e} \tatarrow_C (e', \pi')\}}$$

Заметим, что классический анализ требует
\begin{equation}
\label{cpa_classic_transfer_eq}
\begin{aligned}
& \forall e \in E, \pi \in \Pi: \\
& \bigcup_{e \tatarrow_C (e', \pi)}{\conc{e'}} \supseteq \bigcup_{c \in \conc{e}}{\{c' \mid c \tcarrow c'\}}
\end{aligned}
\end{equation}

\begin{proof}
Покажем, что требование~\ref{cpa_transfer_eq} выполнено при $k = 1$.

\begin{align}
& \conc{Reach(R)} = \bigcup_{e\in Reach(R)}{\conc{e}_C} = \bigcup_{e \in R, e \tatarrow (e', \pi')}{\conc{e'}} \supseteq (req.~\ref{cpa_classic_transfer_eq}) \supseteq \nonumber \\
& \supseteq \bigcup_{e \in R} {\bigcup_{c \in \conc{e}}{\{c' \mid c \tcarrow c'\}}} = (def.~\ref{cpa_classic_conc_eq}) = \bigcup_{c \in \conc{R}}{\{c' \mid c \tcarrow c'\}} \nonumber
\end{align}
\end{proof}

{\textbf 4.} $merge_R = merge_C$

{\textbf 5.} $stop_R = stop_C$

{\textbf 6.} $prec_R = prec_C$

{\textbf 7.}
$\update_R(waitlist, reached, e, \pi, e', \pi')=$ 
$waitlist \setminus \{\{(e, \pi)\}\} \cup \{\{(e', \pi')\}\}$

\begin{proof}
Покажем, что $\update_R$ удовлетворяет условию~\ref{cpa_update_transfer_eq}.

$$ W' = W \setminus \{\{(e, \pi)\}\} \cup \{\{(e', \pi')\}\}$$

Предположим, что 
$\forall \overline{R} \subseteq R: \overline{R} \in W \lor (\forall e \in Reach^w(\{\overline{R}\}) \exists e' \in R: e \sqsubseteq e')$ 
и покажем, что
$\forall \overline{R} \subseteq R': \overline{R} \in W \lor (\forall e \in Reach^w(\{\overline{R}\}) \exists e' \in R': e \sqsubseteq e')$

Возьмем случайное множество $\overline{R} \subseteq R'$. Возможны три варианта:

\begin{itemize}
\item $|\overline{R}| > 1$. Это означает, что $Reach^w(\{\overline{R}\}) = \emptyset \subseteq R$.
\item $\overline{R} = \{\overline{e}\} \land \overline{e} \neq e'$.
\begin{itemize}
\item $e \notin Reach(\{\overline{R}\})$. Для этого $\overline{e}$ начальное предположение также выполнено.
\item $e \in Reach(\{\overline{R}\})$. После выполнения $update$ $e \notin R$, но $\exists e' \in R: e \sqsubseteq e'$ и инвариант выполнен.
\end{itemize}
\item $\overline{R} = \{e'\}$. $\{\{(e', \pi')\}\} \in W'$ по определению оператора $update$.
\end{itemize}

\end{proof}


{\textbf 8.} 
$\frontier_R(reached, e, \pi)=$
$\{\{(e, \pi)\}\}$

\begin{proof}
Покажем, что $\frontier_R$ удовлетворяет условию~\ref{cpa_frontier_transfer_eq}.
Нам нужно показать, что
$\forall \widehat{R} \subseteq R \cup \{e\} \land e \in \widehat{R}: \widehat{R} \subseteq frontier(R, e, \pi) \lor Reach^w(\{\widehat{R}\}) \subseteq R \cup \{e\}$. 
Возьмем случайное множество $\widehat{R} \in R \cup \{e\} \land e \in \widehat{R}$. Возможны два варианта:

\begin{itemize}
\item $|\overline{R}| > 1$. Это означает, что $Reach^w(\{\overline{R}\}) = \emptyset \subseteq R$.
\item $\overline{R} = \{(e, \pi)\}$. $\{(e, \pi)\} \in \{\{(e, \pi)\}\} = frontier(R, e, \pi)$.
\end{itemize}

Требование выполнено.

\end{proof}

\newcommand{\IR}{IR}
\newcommand{\epp}{\mathrel{\bigoplus}}
\newcommand{\conctm}[1]{\conc{#1}_{TM}}

\section{Адаптивный статический анализ с раздельным рассмотрением потоков}
\label{sect_tm_with_io}

В этом разделе определяется анализ с раздельным рассмотрением потоков (thread-modular analysis) $\mathcal{TM}$ с частичными абстрактными состояниями $E$ и эффектами окружения $\IR$.

$\mathcal{TM}=(D_{TM},$ $\Pi_{TM}, \tatarrow_{TM},$ $merge^E_{TM}, stop^E_{TM},$ $merge^I_{TM}, stop^I_{TM},$ $prec^E_{TM}, prec^I_{TM},$ $compatible_{TM})$.

{\textbf 1.}
Абстрактный домен $D_{TM} = (C, \mathcal{E}, \mathcal{I}, \epp)$.

Полурешетка $\mathcal{E}=(E, \sqcup^E, \sqsubseteq^E, \top^E, \bot^E)$ частичных состояний.

Полурешетка 
$\mathcal{I}=(\IR, \sqcup^I, \sqsubseteq^I, \top^I, \bot^I)$ эффектов окружения.
Обозначим пустой эффект $\varepsilon=\bot^I$, который не меняет ничего, и всегда имеется переход $e \tat{\varepsilon} (e, \pi))$.
$\tau$ будет обозначать переход в потоке.
Он не является эффектом окружения, то есть $\tau \notin IR$, а необходим только для обозначения перехода.
Для удобства будем обозначать расширенное множество $\overline{IR} = \IR \cup \{\tau\}$.

Проверка совмествности состояний $compatible^E: 2^E \to Bool$ возвращает $true$, если частичные состояния могут быть частями одного состояния.
Оператор \emph{compatible} используется для удобства.

Функция конкретизации суммирует совместные состояния
$\epp: 2^{E \times T} \to 2^C$.

Требования

\begin{equation}
\label{cpa_tm_abstract_domain_2}
\begin{aligned}
& \forall e \sqsubseteq e' \in E, e_1, \dots e_n \in E, t_0,t_1,\dots,t_n \in T, t_i \neq t_j : \\
& \epp 
\begin{pmatrix}
\begin{pmatrix}
e \\
t_0 
\end{pmatrix}& ,
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}&,
\dots& ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\end{pmatrix} 
\subseteq \epp
\begin{pmatrix}
\begin{pmatrix}
e' \\
t_0 
\end{pmatrix}& ,
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}&,
\dots& ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\end{pmatrix} 
\end{aligned}
\end{equation}

Обозначим
\begin{equation}
\begin{aligned}
\forall R\subseteq E: \conctm{R} = 
\bigcup_{k}
{\bigcup_{e_1,\dots,e_k \in R \cap E}{
\bigcup_{
\begin{array}{c}
t_1,\dots,t_k \in T \\
t_i \neq t_j
\end{array}
} {
\epp
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}&,
\dots& ,
\begin{pmatrix}
e_k \\
t_k 
\end{pmatrix}
\end{pmatrix} 
}
}
}
\end{aligned}
\end{equation}

Такое определение необходимо для потенциально бесконечных конкретных состояний, которые успешно поддерживаются с помощью конечных абстрактных состояний.
%Such complicated definition is needed for potentially infinite concrete states, which are successfully hold with finite abstract states. Do not replace with sets!

Покажем, что при выполнении~\ref{cpa_tm_abstract_domain_2} требования \ref{cpa_conc_eq_0}, \ref{cpa_conc_eq_2} выполнены.

\begin{proof}

\begin{align}
\conctm{R} = \bigcup_{k}{\bigcup_{
e_1,\dots,e_k \in R \cap E}{ 
\bigcup_{
\begin{array}{c}
t_1,\dots,t_k \in T \\
t_i \neq t_j
\end{array}
} {
\epp
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}&,
\dots& ,
\begin{pmatrix}
e_k \\
t_k 
\end{pmatrix}
\end{pmatrix} 
}
}
} \subseteq \nonumber \\
\subseteq \bigcup_{k}{\bigcup_{
e_1,\dots,e_k \in \overline{R} \cap E}{
\bigcup_{
\begin{array}{c}
t_1,\dots,t_k \in T \\
t_i \neq t_j
\end{array}
} {
\epp
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}&,
\dots& ,
\begin{pmatrix}
e_k \\
t_k 
\end{pmatrix}
\end{pmatrix} 
}
}
} = \conctm{\overline{R}} \nonumber
\end{align}

Предположим, что $e \sqsubseteq e' \in E$
\begin{align}
\conctm{R \cup e} = \bigcup_{k}{\bigcup_{
e_1,\dots,e_k \in R \cap E \cup \{e\}}{
\bigcup_{
\begin{array}{c}
t_1,\dots,t_k \in T \\
t_i \neq t_j
\end{array}
} {
\epp
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}&,
\dots& ,
\begin{pmatrix}
e_k \\
t_k 
\end{pmatrix}
\end{pmatrix} 
}
}
} \subseteq (req.~\ref{cpa_tm_abstract_domain_2}) \subseteq \nonumber \\
\subseteq \bigcup_{k}{\bigcup_{
e_1,\dots,e_k \in R \cap E \cup \{e'\}}{
\bigcup_{
\begin{array}{c}
t_1,\dots,t_k \in T \\
t_i \neq t_j
\end{array}
} {
\epp
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}&,
\dots& ,
\begin{pmatrix}
e_k \\
t_k 
\end{pmatrix}
\end{pmatrix} 
}
}
} = \conctm{R \cup \{e'\}} \nonumber
\end{align}
\end{proof}

{\textbf 2.}
$\Pi_{TM}$ множество точности.

{\textbf 3.}
Отношение переходов
$\tatarrow: E\times \overline{IR} \times G \times \{E\cup IR\} \times \Pi$
сопоставляет каждое состояния $e$ и некоторый эффект окружения $i$ с новым состоянием $e'$ и точностью $\pi$. 

Будем использовать обозначение $e \tat{i, g} (e', \pi)$ для $(e, i, g, e', \pi) \in \tatarrow$
и $e \tat{i} (e', \pi)$ если $\exists g \in G: e \tat{i, g} (e', \pi)$.

Переход в потоке $\tau$ получает следующее состояние $e': e \tat{\tau} e'$ и эффект окружения $i': e \tat{\tau} i'$, который представляет переход по окружении.

Отношение переходов должно удовлетворять следующему условию:
\begin{equation}
\label{transfer_tm_ir}
\begin{aligned}
& \forall R \subseteq E:\\
& 
\left[\!\left[
\begin{array}{c}
R\\
\bigcup_{e\in R}{\{e' \mid e \tat{\tau} e'\}}\\
\bigcup_{e,\hat e\in R}{\{e'' \mid e \tat{\tau} i' \land \hat e \tat{i'} e''\}}\\
\end{array}
\right]\!\right]_{TM}
\supseteq \bigcup_{c \in \conctm{R}}{\{c' \mid c \tcarrow c'\}}
\end{aligned}
\end{equation}
Отношение переходов аппроксимирует сверху все переходы из множества достижимости применением
\begin{enumerate}
\item перехода в потоке ($e \tat{\tau} e'$) и 
\item перехода в окружении, полученного на основе перехода в потоке ($i': e \tat{\tau} i'$ ), к другим достижимым состояниям $\hat e \tat{i'} e''$.
\end{enumerate}

Требование~\ref{cpa_transfer_eq} очевидно выполнено для $k = 2$.

Теперь представим более сильное условие.
\begin{equation}
\label{transfer_tm_ir_stronger}
\begin{aligned}
& \forall c, c' \in C, g \in G, t \in T, c \tc{g,t} c' \\
& g \neq thread\_create:\\
& \exists t_1, \dots, t_n \in T, t_i \neq t_j: \\
& c \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\end{pmatrix} \implies 
c' \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_n' \\
t_n 
\end{pmatrix}
\end{pmatrix}, \\
&\forall 1 \leq k \leq n, e_k \tat{i'} e_k' \land i' \in \begin{cases}
\{\tau\}, &\text{$t_k = t$}\\
\{i' \mid e_k \tat{\tau} i'\},  &\text{$t_k \neq t$}
\end{cases}\\
& g = thread\_create:\\
& \exists t_1, \dots, t_n \in T, t_i \neq t_j: \\
& c \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\end{pmatrix} \implies 
c' \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_{n+1}' \\
t_{n+1} 
\end{pmatrix}
\end{pmatrix}, \\
&\forall 1 \leq k \leq n, e_k \tat{i'} e_k' \land i \in \begin{cases}
\{\tau\}, &\text{$t_k = t$}\\
\{i' \mid e_k \tat{\tau} i'\},  &\text{$t_k \neq t$}
\end{cases} \\
& e_k \tat{\tau} e_{n+1} \land k: t_k = t
\end{aligned}
\end{equation}

Такое условие является значительно строже, чем~\ref{transfer_tm_ir}, и задает правила преобразования абстрактных состояний, что потребуется при доказательстве корректности комбинации различных видов анализа, так как состояния всех используемых видов анализа должны меняться согласованно.

{\textbf 4.}
Оператор слияния для частичных состояний $merge^E_{TM}: E \times E \times \Pi \rightarrow E$ ослабляет второй параметр, используя информацию от первого параметра и возвращает новое абстрактное состояние с точностью, передаваемой, как третий параметр.
Оператор слияния должен удовлетворять следующему требованию:
\begin{equation}
\label{cpa_merge_tm_e_eq}
\begin{aligned}
&\forall e, e' \in E, \pi \in \Pi :\\
&e' \sqsubseteq^E merge^E_{TM}(e, e', \pi)
\end{aligned}
\end{equation}

{\textbf 5.}
Оператор слияния для эффектов окружения $merge^I_{TM}: \IR \times \IR \times \Pi \rightarrow \IR$ ослабляет второй параметр, используя информацию от первого параметра и возвращает новое абстрактное состояние с точностью, передаваемой, как третий параметр.
Оператор слияния должен удовлетворять следующему требованию:
\begin{equation}
\label{cpa_merge_tm_i_eq}
\begin{aligned}
&\forall i, i' \in IR, \pi \in \Pi :\\
&i' \sqsubseteq^I merge^I_{TM}(i, i', \pi)
\end{aligned}
\end{equation}

{\textbf 6.} Оператор останова для частичных состояний $stop^E_{TM}: E \times 2^{E} \times \Pi \rightarrow \mathbb{B}$ проверяет, является ли абстрактное состояние, передаваемое как первый параметр с точностью, передаваемой как третий параметр, покрытым множеством абстрактных состояний, передаваемым как второй параметр.

Оператор останова должен удовлетворять следующему условию:
\begin{equation}
\label{cpa_stop_tm_e_eq}
\begin{aligned}
&\forall e \in E, R \subseteq E, \pi \in \Pi:\\
&stop^E_{TM}(e, R, \pi) \implies\forall \hat R \subseteq E: \conctm{\{e\}\cup \hat R} \subseteq \bigcup_{R'\subseteq R}{\conc{R' \cup \hat R}}
\end{aligned}
\end{equation}

{\textbf 7.} Оператор останова для эффектов окружения $stop^I_{TM}: \IR \times 2^{\IR} \times \Pi \rightarrow \mathbb{B}$ проверяет, является ли эффект окружения, передаваемый как первый параметр с точностью, передаваемой как третий параметр, покрытым множеством эффектов окружения, передаваемым как второй параметр.

Оператор останова должен удовлетворять следующему условию:
\begin{equation}
\label{cpa_stop_tm_i_eq}
\begin{aligned}
&\forall i \in \IR, I \subseteq \IR, \pi \in \Pi:\\
&stop^I_{TM}(i, I, \pi) \implies\exists i'\in I: i \sqsubseteq^I i'
\end{aligned}
\end{equation}

{\textbf 8.} Оператор настройки точности для состояний $prec_{TM}:E \times \Pi \times 2^{E \times \Pi} \rightarrow E \times \Pi$ вычисляет новое абстрактное состояние и новую точность для данного абстрактного состояния, точности и множества абстракных состояний.

Оператор настройки точности должен удовлетворять следующим требованиям:
\begin{equation}
\label{prec_tm_e_equation}
\begin{aligned}
& \forall e, e' \in E, \pi, \pi' \in \Pi, R \subseteq E \times \Pi:\\
& (e', \pi') = prec^E_{TM}(e, \pi, R) \implies e \sqsubseteq^E e'
\end{aligned}
\end{equation}

{\textbf 9.} Оператор настройки точности для эффектов окружения $prec_{TM}:\IR \times \Pi \times 2^{\IR \times \Pi} \rightarrow \IR \times \Pi$ 
вычисляет новый эффект окружения и новую точность для данного эффекта окружения, точности и множества эффектов окружения.

Оператор настройки точности должен удовлетворять следующим требованиям:
\begin{equation}
\label{prec_tm_i_equation}
\begin{aligned}
& \forall i, i' \in \IR, \pi, \pi' \in \Pi, R \subseteq \IR \times \Pi:\\
& (i', \pi') = prec^I_{TM}(i, \pi, R) \implies i \sqsubseteq^I i'
\end{aligned}
\end{equation}

{\textbf 10.} $compatible_{TM}: E \times \IR \to \mathbb{B}$.
Оператор проверки совмествности должен удовлетворять следующему требованию:
\begin{equation}
\label{compatible_tm_equation}
\begin{aligned}
& \forall e \in E, i \in \IR:\\
& \exists e': e \tat{i} e' \implies compatible_{TM}(e,i)
\end{aligned}
\end{equation}

\subsection{Реализация $\mathbb{R}$}
\SetKwProg{Fn}{Function}{}{}

В этом разделе представлена реализация анализа с раздельным рассмотрением потоков 
$\mathcal{TM}=(D_{TM},$ $\Pi_{TM}, \tatarrow_{TM},$ $merge^E_{TM}, stop^E_{TM},$ $merge^I_{TM}, stop^I_{TM},$ $prec^E_{TM},prec^I_{TM},$ $compatible_{TM})$.
в общей теории анализа с частичными состояниями
$\mathbb{R}=(D_R$, $\Pi_R$, $\tatarrow_R$, $merge_R$, $stop_R$, $prec_R$, $\update_R$, $\frontier_R)$


{\textbf 1.} Абстрактный домен $D_R = (C_R,\mathcal{E}_R,\conc{\cdot}_R)$, where $\mathcal{E}_R=(E_R,\top_R, \bot_R, \sqsubseteq_R)$ определяется как
\begin{itemize}
\item $C_R = C$,
\item $E_R = E \cup \IR \cup \{\tau\}$,
\item $\top_R: \top^E \sqsubseteq \top_R \land \top^I \sqsubseteq \top_R \land \tau \sqsubseteq \top_R$,
\item $\bot_R = \bot^R \sqsubseteq \bot_E \land \bot^R \sqsubseteq \bot_I \land \bot^R \sqsubseteq \tau$,
\item $e_1 \sqsubseteq_R e_2, e_1, e_2 \notin \{top^E, top^I, top^R, \bot_E, \bot_I, \bot_R, \tau\}$
\begin{itemize}
\item если $e_1,e_2 \in E$, тогда $e_1 \sqsubseteq^E e_2$,
\item если $e_1,e_2 \in \IR$, тогда $e_1 \sqsubseteq^I e_2$,
\item false в ином случае.
\end{itemize}
\item Функция конкретизации 
$\forall R\subseteq E: \conc{R}_R = \conctm{R}$
\end{itemize}

{\textbf 2.} Множество точности $\Pi_R = \Pi_{TM}$.

{\textbf 3.} Отношение переходов $\tatarrow_{R}$
Переход $R \tatarrow_{R} e'$ существует, если $R = \{e, i\}, e \in E, i \in \tilde{\IR}: e \tat{i}_{TM} e'$.

Для формулы~\ref{reach_k} 

\begin{equation}
\label{cpa_tm_transfer}
\begin{aligned}
& Reach(R) = R \cup \bigcup_{e \in R \cap E, i \in R \cap \tilde{\IR}}{\{(e', \pi') \mid e \tat{i}_{TM} (e', \pi')\}}
\end{aligned}
\end{equation}

{\textbf 4.}
$\hat e = merge_{R}(e,e', \pi)$
\begin{itemize}
\item если $e,e' \in E$, то $\hat e = merge^E_{TM}(e, e', \pi)$,
\item если $e,e' \in \IR$, то $\hat e = merge^I_{TM}(e, e', \pi)$,
\item $\hat e = e'$ в ином случае.
\end{itemize}

{\textbf 5.}
$stop_{R}(e,R, \pi)=$
\begin{itemize}
\item если $e \in E$, то $stop^E_{TM}(e, R\cap E, \pi)$,
\item если $e \in IR$, то $stop^I_{TM}(e, R\cap IR, \pi)$,
\item в ином случае true.
\end{itemize}

{\textbf 6.}
$prec_{R}(e,\pi, R)=$
\begin{itemize}
\item если $e \in E$ то $prec^E_{TM}(e, \pi, R\cap E)$,
\item если $e \in \IR$, $prec^I_{TM}(e, \pi, R\cap IR)$,
\item в ином случае $(e, \pi)$.
\end{itemize}

{\textbf 7.} %update
%----------------------------
Оператор update представлен на алгоритме~\ref{cpatm_ir_update}.
Его суть заключается в удалении всех пар, содержащих старое состояние $e$, и добавлении всех возможных новых пар, содержащих состояние $e'$.
\begin{algorithm}
  \Fn{$\update_R(w, R, e, \pi, e', \pi'))$}{
    $w' := w$\;
    \If {$e,e'\in E$} {
        //удаляем старые состояния\;
        $w' = w' \setminus \{\{(e,\pi),\cdot\}\}$\;
        //добавляем переход в потоке\;
        $w' = w' \cup \{\{(e',\pi'),(\tau, \pi')\}\}$\;
        \For{each $(i,\pi_i) \in R, i \in \IR$}{
            \If {$compatible_{TM}(e',i)$}{
                //применяем эффект окружения\;
                $w' = w' \cup \{\{(e',\pi'),(i,\pi_i)\}\}$\;
            }
        }
    }
    \If {$e,e'\in \IR$} {
    	Let $i=e, i'=e'$\;
    	//удаляем старый эффект окружения\;
        $w' = w' \setminus \{\{\cdot,(i, \pi)\}\}$\;
        \For{each $(\hat e,\hat \pi) \in R, \hat e \in E$}{
            \If {$compatible_{TM}(\hat e, i')$}{
                //добавляем новый переход по окружению\;
                $w' = w' \cup \{\{(\hat e, \hat \pi), (i, \pi')\}\}$\;
            }
        }        
    }
    \Return{$w'$}\;
  } %update
 \caption{Реализация оператора $\update_R$}
 \label{cpatm_ir_update}
\end{algorithm}

Докажем, что алгоритм~\ref{cpatm_ir_update} удовлетворяет условию~\ref{cpa_update_transfer_eq}.
Рассмотрим $e,e' \in E$. Для другого случая $i,i' \in \IR$ доказательство будет тем же самым. 
Для упрощения выкладок опустим точность абстрактных состояний $\pi$.

\begin{proof}

%Reference to the algorithm, should be requirement?
Заметим, что в соответствии с алгоритмом~\ref{cpata_algorithm_ps} $e \in R$. Обозначим
\begin{align}
\widehat{R} & = R \setminus \{e\} \nonumber \\
R' & = R \setminus \{e\} \cup \{e'\} = \widehat{R} \cup \{e'\} \nonumber \\
W' & = update(W, R, e, \pi, e', \pi') = \nonumber \\
& = W \setminus \{\{e, i\} \mid i \in R \cap \tilde{IR} \land compatible_{TM}(e, i)\} \nonumber \\
& \cup \{\{e', i\} \mid i \in R \cap \tilde{IR} \land compatible_{TM}(e', i)\}  \nonumber \\
\hat{W} & = W \setminus \{\{e, i\} \mid i \in R \cap \tilde{IR} \land compatible_{TM}(e, i)\} \nonumber \\
W & \subseteq \hat{W} \cup \{\{e, i\} \mid i \in R \cap \tilde{IR} \land compatible_{TM}(e, i)\} \nonumber
\end{align}

Предположим
$\forall \overline{R} \subseteq R: \overline{R} \in W \lor (\forall e \in Reach^w(\{\overline{R}\}) \exists e' \in R: e \sqsubseteq e'$ 
(предусловие~\ref{cpa_update_transfer_eq}) и покажем, что
$\forall \overline{R} \subseteq R': \overline{R} \in W \lor (\forall e \in Reach^w(\{\overline{R}\}) \exists e' \in R': e \sqsubseteq e')$
Возьмем случайное множество $\widehat{R} \subseteq R'$. Возможны три варианта:

\begin{itemize}
\item $|\widehat{R}| \neq 2$. Эо означает $Reach^w(\{\widehat{R}\}) = \emptyset \subseteq R$.
\item $\widehat{R} = \{(\overline{e}, i)\} \land \overline{e} \neq e' \land i \in IR$. Для этого $\overline{e}$ начальное условие выполнено:
\begin{itemize}
\item $e \notin Reach^w(\widehat{R})$ - предположение не изменяется
\item $e \in Reach^w(\widehat{R}) \implies \exists e' \in R': e \sqsubseteq e'$ 
\end{itemize}
\item $\widehat{R} = \{e', i\}$. $\{\{e', i\}\} \in W'$ по определению оператора $update$.
\end{itemize}

\end{proof}

{\textbf 8.} %frontier
Оператор $frontier$ предствлен на алгоритме~\ref{cpatm_ir_frontier}.
\begin{algorithm}
  \Fn{$\frontier_R(w, R, e, \pi))$}{
    $w' := w$\;
    \If {$e \in E$} {
        //применяем переход в потоке\;
        $w' = w' \cup \{\{(e,\pi), (\tau,\pi)\}\}$\;
        \For{each $(i, \pi_i) \in R, i \in I$}{
            \If {$compatible_{TM}(e,i)$}{
                //применяем переход по окружению\;
                $w' = w' \cup \{\{(e,\pi),(i, \pi_i)\}\}$\;
            }
        }
    }
    \If {$e\in \IR$} {
    	//Пусть $i=e$\;
        \For{each $(\hat e,\hat \pi) \in R, \hat e \in E$}{
            \If {$compatible_{TM}(\hat e, i)$}{
                //применяем переход по окружению\;
                $w' = w' \cup \{\{(\hat e, \hat \pi), (i, \pi)\}\}$\;
            }
        }        
    }
    \Return{$w'$}\;
  } %frontier
 \caption{Реализация оператора $\frontier_R$}
 \label{cpatm_ir_frontier}
\end{algorithm}

Докажем, что алгоритм~\ref{cpatm_ir_frontier} удовлетворяет условию~\ref{cpa_frontier_transfer_eq}.
Рассмотрим случай $e \in R$. Доказательство для другого случая будет полностью таким же.
Также, как и при доказательстве корректности оператора $update$ опустим точность $\pi$ из математических выкладок.
Нам нужно показать, что
$\forall \widehat{R} \subseteq R \cup \{e\} \land e \in \widehat{R}: \widehat{R} \subseteq frontier(R, e, \pi) \lor Reach^w(\{\widehat{R}\}) \subseteq R \cup \{e\}$. 
Возьмем случайное множество $\widehat{R} \in R \cup \{e\} \land e \in \widehat{R}$. Возможны два варианта.

\begin{itemize}
\item $|\overline{R}| \neq 2$. Это означает $Reach^w(\{\overline{R}\}) = \emptyset \subseteq R$.
\item $\overline{R} = \{e, i\} \land i \in IR$.
\begin{itemize}
\item $compatible_{TM}(e, i)$. $\forall i \in IR: \{e, i\} \in frontier(R, e, \pi)$ по определению оператора $frontier$.
\item $compatible_{TM}(e, i) = false$. $Reach^w(\{\overline{R}\}) = \emptyset \subseteq R$.
\end{itemize}
\end{itemize}

Требование выполнено.

\subsection{Анализ, инвариантный к эффектам окружения}

Анализ $\mathcal{TM}$ будем называть инвариантным к эффектам окружения, если $\forall e \in E, i \in IR: e \tat{i} e$.
В этом случае применение эффектов окружения является бессмысленным.

Покажем, как такой анализ сводится к общему анализу с раздельным рассмотрением потоков.
Анализ, инвариантный к эффектам окружения, задается похожим образом, что и классический анализ:
$\mathcal{ITM}=(D_{ITM},$ $\Pi_{ITM}, \tatarrow_{ITM},$ $merge^E_{ITM}, stop^E_{ITM},$ $prec^E_{ITM})$.
При этом $merge^I_{ITM}(e,e',\pi)=e'$, $stop^I_{ITM}(e,R,\pi)=true$, $prec^I_{ITM}(i, \pi) = i$. 
Легко проверить, что определенные таким образом операторы удовлетворяют условиям~\ref{cpa_merge_tm_i_eq},~\ref{cpa_stop_tm_i_eq},~\ref{prec_tm_i_equation} соответственно.

Нужно заметить, что такой анализ не сводится к классическому анализу, так как по-прежнему $\forall R\subseteq E_C: \conc{R}_R \neq \bigcup_{e\in R}{\conc{e}_C}$.
Кроме того, часто может быть определен нетривиальное множество $IR_{ITM}$ и нетривиальный оператор $compatible^{TM}$. 
Это означает, что несмотря на то, что эффектны окружения этого вида анализа не могут изменить его состояние, сам он способен влиять на применение эффектов окружения на другие типы анализов, которые не являются инвариантными к эффектам окружения.

Если все используемые при анализе программы виды анализа инвариантны к эффектам окружения, это позволяет значительно повысить скорость работы, за счет применения только переходов в потоке.
При этом, как правило, теряется точность анализа, так как анализ полностью абстрагируется от поведения других потоков.

\section{Анализ с раздельным рассмотрением потоков без абстракции}

В этом разделе покажем, что в представленную теорию укладывается классический алгоритм проверки моделей, описанный в~\cite{ThreadModular03}.

Определим анализ с раздельным рассмотрением потоков с эффектами окружения, как
$\mathbb{Q}=(D_{Q},$ $\Pi_{Q}, \tatarrow_{Q},$ $merge^E_{Q}, stop^E_{Q},$ $merge^I_{Q}, stop^I_{Q},$ $prec^E_{Q},prec^I_{Q},$ $compatible_{Q})$.

Также как и в алгоритме~\cite{ThreadModular03} применение анализа возможно только к программам с ограниченным количеством точек создания потоков. Далее предполагаем, что программа имеет ограниченное количество потоков, которые отличаются точками в программе, обозначающих начало потока, например, для $thread\_create(pc_\nu)$ будет всегда создан поток с идентификатором $pc_\nu$.

{\textbf 1.} 
$D_Q=(C_Q, \mathcal{E}_Q,\mathcal{I}_Q, \epp_Q)$.\\

\begin{itemize}
\item $C_Q=C$ -- все конкретные состояния программы.\\

\item $\mathcal{E}_Q=(E_Q, \top^E_Q, \bot^E_Q, \sqsubseteq^E_Q, \sqcup^E_Q)$ определен над $E_Q=\mathcal{R}$, где
$\mathcal{R}$ множество всех проекций конкретных состояний на некоторый поток:
$\mathcal{R} \subseteq T\times L\times C^{local} \times c_g \times c_s$.

\item $\mathcal{I}_Q=(I_Q, \top^I_Q, \bot^I_Q, \sqsubseteq^I_Q, \sqcup_Q)$ определен над $I_Q=\mathcal{G}$ ($\tau=\bot^I_Q$), где
$\mathcal{G}$ содержит эффекты окружения на глобальные части состояния
$\mathcal{G} \subseteq T\times c_g \times c_s \times c_g \times c_s$.

\item Для состояний $\forall e_1, \dots, e_j \in E_Q$, где $e_i=(t_i,pc_i,l_i,gl_i,s_i)$ определено как
\begin{equation}
\label{compatible_tm_na}
\begin{aligned}
& compatible^E(\{e_1, \dots, e_j\}) \Leftrightarrow \forall i\ne k:t_i\ne t_k \land gl_i=gl_k \land s_i=s_k=\hat s\\
\end{aligned}
\end{equation}

Для совместных состояний $e_1,\dots,e_j$ можно определить $\hat{gl}=gl_i=gl_k$ и $\hat s=s_i=s_k$.

\begin{equation}
\label{epp_tm_na}
\begin{aligned}
& \forall e_1, \dots, e_j \in E_Q, e_i=(t_i,pc_i,l_i,gl_i,s_i)\\
& compatible^E(\{e_1,\dots,e_j\}) \implies \\
& \epp
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_j \\
t_j 
\end{pmatrix}
\end{pmatrix} = 
\left\lbrace\left(
\begin{array}{c}
\{t_1 \to pc_1,\dots,t_j \to pc_j\},\\
\{t_1\to l_1, \dots, t_j\to l_j\},\\
\hat{gl}, \hat s
\end{array}
\right)\right\rbrace
\\
\end{aligned}
\end{equation}

\item $\sqsubseteq_Q, \sqcup_Q$ определены как равенство соответствующих элементов, то есть\\
$e_1 \sqsubseteq^E_Q e_2$ iff $e_1 = e_2$, \\
а $e_2 \sqcup_Q e_2 = \top^E$.

\end{itemize}

{\textbf 2.} $\Pi_Q$ содержит один элемент, так как анализ не использует абстракцию.

{\textbf 3.}
Отношение переходов $\tatarrow_Q$ содержит переход $e \tat{i,g}_Q (e', \pi)$ если
\begin{itemize}
\item $i=\tau$ и есть переход на проекциях. Пусть
$e=(t, pc, l, gl, s)$ и есть
\begin{itemize}
\item $(\{t\to pc\}, \{t\to l\}, gl, s) \tc{g,t} (\{t\to pc'\}, \{t\to l'\}, gl', s'))$, где $g \ne thread\_create$, тогда \\
\begin{enumerate}
\item $e' = (t,pc',gl',s')$ (следующее состояние), 
\item и $e'=(t,gl,s,gl',s')$ (эффект окружения).
\end{enumerate}
\item или в случае $g=thread\_create(pc_\nu)$, $\nu=pc_\nu$, \\
$(\{t\to pc\}, \{t\to l\}, gl, s) \tc{thread\_create(pc_\nu), t} (\{t\to pc', \nu \to pc_\nu\}, \{t\to l,\nu \to l\}, gl, s))$, тогда \\
\begin{enumerate}
\item $e' = (t,pc',gl,s)$ (следующее состояние),
\item и $e' = (\nu,pc_\nu,gl,s)\}$ (новый поток).
\end{enumerate}
\end{itemize}
\item $i=(t, gl',s',gl'',s'')$, $e=(t, pc, l, gl, s)$. Если $compatible(e,i)$, тогда можно применить к данному состоянию эффект окружения $e'=(t, pc, l, gl'', s'')$.
\end{itemize}

{\textbf 4.}
$merge^E_Q(e_1,e_2,R) = e_2$.

{\textbf 5.}
$merge^I_Q(i_1,i_2,I) = i_2$.

{\textbf 6.}
$stop^E_Q(e,R,\pi)=\exists e' \in R: e \sqsubseteq e'$.

{\textbf 7.}
$stop^I_Q(i,I,\pi)=\exists i' \in I: i \sqsubseteq i'$.

{\textbf 8.}
$prec^E_Q(e,\pi)=(e,\pi)$ (точность и состояние никогда не изменяются).

{\textbf 9.}
$prec^I_Q(i,\pi)=(i,\pi)$ (точность и эффект окружения никогда не изменяются).

{\textbf 10.} 
$compatible_Q: \mathcal{R}\times\mathcal{G} \to \mathbb{B}$ определяется, как равенство глобальных частей состояний, $compatible_Q(e,i)$ для $e=(t,pc,gl,s)$ и $i=(t',gl',s',gl'',s'')$ есть $t=t' \land gl=gl' \land s=s'$.   

\section{Композиция различных видов анализа}
\label{sect_composite_analysis}

Пусть есть несколько различных видов анализа с раздельным рассмотрением потоков $\mathcal{TM}: \Delta_1, \dots, \Delta_n$. 
Композиция различных видов анализа может быть представлена, как отдельный анализ $\mathscr{C}=(D_{\mathscr{C}},$ $\Pi_{\mathscr{C}}, \tatarrow_{\mathscr{C}},$ $merge^E_{\mathscr{C}}, stop^E_{\mathscr{C}},$ $merge^I_{\mathscr{C}}, stop^I_{\mathscr{C}},$ $prec^E_{\mathscr{C}},prec^I_{\mathscr{C}},$ $compatible_{\mathscr{C}}$).
Каждый $\Delta_i$ реализует отдельный вид анализа. 
$\Delta_i=(D_{\Delta_i},$ $\Pi_{\Delta_i}, \tatarrow_{\Delta_i},$ $merge^E_{\Delta_i}, stop^E_{\Delta_i},$ $merge^I_{\Delta_i}, stop^I_{\Delta_i},$ $prec^E_{\Delta_i},prec^I_{\Delta_i},$ $compatible_{\Delta_i}$)

{\textbf 1.} $D_{\mathscr{C}} = D_{\Delta_1} \times \dots \times D_{\Delta_n}$

$compatible_{\mathscr{C}}(e_1,\dots, e_m) = 
compatible_1(e_1^1,\dots, e_m^1) \land \dots \land compatible_n(e_1^n,\dots, e_m^n)$

\begin{equation}
\label{composite_epp_def}
\begin{aligned}
\epp_{\mathscr{C}}
\begin{pmatrix}
\begin{pmatrix}
e_1' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m' \\
t_m 
\end{pmatrix}
\end{pmatrix} = 
\epp_{\Delta_1}
\begin{pmatrix}
\begin{pmatrix}
\widehat{e^1_1} \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
\widehat{e^1_m} \\
t_m 
\end{pmatrix}
\end{pmatrix} \cap \dots \\
 \dots \cap 
\epp_{\Delta_n}
\begin{pmatrix}
\begin{pmatrix}
\widehat{e^n_1} \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
\widehat{e^n_m} \\
t_m 
\end{pmatrix}
\end{pmatrix}  
\end{aligned}
\end{equation}

{\textbf 2.} $\Pi_{\mathscr{C}} = \Pi_{\Delta_1} \times \dots \times \Pi_{\Delta_n}$

{\textbf 3.}
Внутренние элементы $\Delta$ работают с графом потока управления, с двумя дополнительными операциями:~\footnote{Заметим, что в реализации \cpachecker уже присутствуют две дуги в ГПУ для каждого вызова функции: function summary и function entry. Поэтому вызов функции $thread\_create$ не требует изменений в ГПУ с точки зрения реализации.}
\begin{itemize}
\item $tc_{parent}$ представляет действие $thread\_create$ в родительском потоке, а
\item $tc_{child}$ представляет действие $thread\_create$ в дочернем потоке.
\end{itemize}

Для отношения переходов в композиции
\begin{equation}
\label{composite_transfer_eq}
\begin{aligned}
e \tat{i,g}_{\mathscr{C}} (e',\pi') \mbox{ with } g=(l,op,l' )\mbox{, where } e = (e_1, \dots e_n), e' = (e_1', \dots e_n')
\end{aligned}
\end{equation} 

\begin{itemize}
\item если $op=thread\_create(l_\nu)$, то рассматриваются два перехода в родительском и в дочернем потоке
\begin{enumerate}
\item $e_j \tat{i,(l,tc_{parent}(l_\nu),l')}_{\Delta_j} (e_j',\pi')$,
\item $e_j \tat{i,(l,tc_{child}(l_\nu),l')}_{\Delta_j} (e_j',\pi')$.
\end{enumerate}
\item иначе, $e_j \tat{i,g}_{\Delta_j} (e_j',\pi')$.
\end{itemize}

%For composition if we have a transfer 
%$e \tat{\tau,g} (e',\pi')$. then 
%we should always have a transfer to an inference object $i' \ne \bot^I$:
%$e \tat{\tau,g} (i',\pi')$.

Так как композитный анализ разбивает операцию $thread\_create$ на две дуги, требование~\ref{transfer_tm_ir_stronger} трансформируется в

\begin{equation}
\label{transfer_tm_ir_stronger_for_inner_1}
\begin{aligned}
& \forall c, c' \in C, g \in G, t \in T, c \tc{g,t} c' \\
& \exists t_1, \dots, t_m \in T: \forall p \neq q: t_p \neq t_q \\
& \exists k : 1 \le k \le m \land t_k = t \\
& c \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix} \implies \\
& \cdot g \neq thread\_create\\
& \exists e_1', \dots, e_m' \in E:\\
& c' \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m' \\
t_m 
\end{pmatrix}
\end{pmatrix} \\
& \mbox{ где } e_1', \dots, e_m' \mbox{ такие, что } \\
&\exists i_1, \dots, i_{k-1}, i_{k+1}, \dots, i_m: \\
&
\begin{cases}
\forall q \neq k: e_q \tat{i_q} \widehat{e_q} \land i_q \in \{i \mid e_k \tat{\tau} i\} \\
e_k \tat{\tau} e_k' 
\end{cases} \\
\end{aligned}
\end{equation}

\begin{equation}
\label{transfer_tm_ir_stronger_for_inner_2}
\begin{aligned}
& \cdot g = thread\_create:\\
& \exists e_1', \dots, e_{m+1}' \in E:\\
& c' \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_{m+1}' \\
t_{m+1} 
\end{pmatrix}
\end{pmatrix} \\
& \mbox{ где } e_1' \dots e_{m+1}' \mbox{ такие, что } \\
&\exists i_1, \dots, i_{k-1}, i_{k+1}, \dots, i_m: \\
&
\begin{cases}
\forall q \neq k: e_q \tat{i_q} e_q' \land i_q \in \{i \mid e_k \tat{\tau} i\} \\
e_k \tat{\tau, tc_{parent}} e_k' \\
e_k \tat{\tau, tc_{child}} e_{m+1}
\end{cases}\\
\end{aligned}
\end{equation}

\begin{equation}
\label{transfer_tm_ir_stronger_for_inner_3}
\begin{aligned}
& \cdot g = thread\_join(var,num):\\
& \exists r: t_r \notin dom(c) \land c_t(var, num) = t_r \\
& \exists e_1', \dots,e_{r-1}', e_{r+1}', e_m' \in E:\\
& c' \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1' \\
t_1 
\end{pmatrix}&,
\dots& ,
\begin{pmatrix}
e_{r-1}' \\
t_{r-1} 
\end{pmatrix},
\begin{pmatrix}
e_{r+1}' \\
t_{r+1} 
\end{pmatrix} ,
\dots& ,
\begin{pmatrix}
e_m' \\
t_m 
\end{pmatrix}
\end{pmatrix} \\
& \mbox{ где } e_1',\dots,e_{r-1}', e_{r+1}', \dots e_m' \mbox{ такие, что } \\
&\exists i_1, \dots, i_{k-1}, i_{k+1}, \dots, i_m: \\
&
\begin{cases}
\forall q \neq k \land q \neq r: e_q \tat{i_q} e_q' \land i_q \in \{i \mid e_k \tat{\tau} i\} \\
e_k \tat{\tau, tc_{parent}} e_k' \\
e_k \tat{\tau, tc_{child}} e_{m+1}
\end{cases}
\end{aligned}
\end{equation}

Теперь нужно показать, что требование~\ref{transfer_tm_ir_stronger} выполнено для $\mathscr{C}$, если требования~\ref{transfer_tm_ir_stronger_for_inner_1}~\ref{transfer_tm_ir_stronger_for_inner_2}~\ref{transfer_tm_ir_stronger_for_inner_3} выполнены для всех его внутренних элементов. 
Рассмотрим случайное конкретное состояние
$$c \in  \epp_{\mathscr{C}}
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$$
где $e_1=(e^1_1, \dots, e^n_1), \dots, e_m=(e^1_m, \dots, e^n_m)$.

По определению~\ref{composite_epp_def}, это означает что
$$\forall j: 1\le j \le n: c \in  \epp_{\Delta_j}
\begin{pmatrix}
\begin{pmatrix}
e^j_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e^j_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$$

Возьмем случайный переход
$ g \in G, t \in T, c \tc{g,t} c'$ и покажем, что 
$\exists e_1', \dots, e_m': e_j \tatarrow e_j'$ и
$c' \in  \epp_{\mathscr{C}}
\begin{pmatrix}
\begin{pmatrix}
e_1' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m' \\
t_m 
\end{pmatrix}
\end{pmatrix}$

%enumerate
{\textbf 1.} Сначала рассмотрим случай $g \neq thread\_create$

Используя требование~\ref{transfer_tm_ir_stronger_for_inner} для внутренних элементов, получаем, что 
\begin{equation}
\label{transfer_condition_for_inner}
\begin{aligned}
& \exists k : 1 \le k \le m \land t_k = t \\
& \forall j: 1\le j \le n: \\
& \exists t_1, \dots, t_n \in T, \forall p \neq q: t_p \neq t_q : \\
& c \in \epp_{\Delta_j}
\begin{pmatrix}
\begin{pmatrix}
e^j_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e^j_m \\
t_m 
\end{pmatrix}
\end{pmatrix} \implies \\
& \exists \widehat{e^j_1}, \dots, \widehat{e^j_m} \in E_j:
c' \in \epp_{\Delta_j}
\begin{pmatrix}
\begin{pmatrix}
\widehat{e^j_1} \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
\widehat{e^j_m} \\
t_m 
\end{pmatrix}
\end{pmatrix} \\
& \mbox{ where } \widehat{e^j_1} \dots \widehat{e^j_m} \mbox{ такие, что } \\
&\exists i^j_1, \dots, i^j_{k-1}, i^j_{k+1}, \dots, i^j_m: \\
&
\begin{cases}
\forall q \neq k: e^j_q \tat{i^j_q}_{\Delta_j} \widehat{e^j_q} \land i^j_q \in \{i \mid e^j_k \tat{\tau}_{\Delta_j} i\} \\
e^j_k \tat{\tau}_{\Delta_j} \widehat{e^j_k} 
\end{cases} 
\end{aligned}
\end{equation}

Заметим, что $k$ является одним и тем же, для всех внутренних элементов и $t_i \neq t_j$, поэтому можно объединить все внутренние состояния следующим способом:

\begin{align}
& \forall q: 1 \le q \le m: e_q' = (\widehat{e^1_q}, \dots, \widehat{e^n_q}) \nonumber \\
& \begin{cases}
& i_q = (i^1_q, \dots, i^n_q), \mbox{ if } q \neq k \\
& i_k = (\tau, \dots, \tau)
\end{cases} \nonumber
\end{align}

Используя определение~\ref{composite_transfer_eq} отношения перехода в композитном анализе, получаем:

\begin{equation}
\label{composite_transfer_eq_2}
\begin{aligned}
& e_1 \tat{i_1}_{\mathscr{C}} e_1', i_1 \in \{i' \mid e_k \tat{\tau}_{\mathscr{C}} i'\} \\
& \dots \\
& e_k \tat{\tau}_{\mathscr{C}} e_k', e_k \tat{\tau}_{\mathscr{C}} i'\\
& e_{k+1} \tat{i_{k+1}}_{\mathscr{C}} e_{k+1}', i_{k+1} \in \{i' \mid e_k \tat{\tau}_{\mathscr{C}} i'\} \\
& \dots \\
& e_m \tat{i_m}_{\mathscr{C}} e_m', i_m \in \{i' \mid e_k \tat{\tau}_{\mathscr{C}} i'\} 
\end{aligned}
\end{equation}

Теперь используем условие на внутренние элементы~\ref{transfer_condition_for_inner}

\begin{align}
& \forall j, c' \in  \epp_{\Delta_j}
\begin{pmatrix}
\begin{pmatrix}
\widehat{e^j_1} \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
\widehat{e^j_m} \\
t_m 
\end{pmatrix}
\end{pmatrix}
\implies (def.~\ref{composite_epp_def}) \implies
c' \in  \epp_{\mathscr{C}}
\begin{pmatrix}
\begin{pmatrix}
e_1' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m' \\
t_m 
\end{pmatrix}
\end{pmatrix} \nonumber \\
& \mbox{ where } e_1' \dots e_m' \mbox{ такие, что (условие~\ref{composite_transfer_eq_2})} \nonumber \\
&\exists i_1, \dots, i_m, k: 1 \le k \le m, t_k = t :\nonumber \\
& \begin{cases}
\forall q \neq k: e_q \tat{i_q}_{\mathscr{C}} e_q' \land i_q \in \{i \mid e_k \tat{\tau}_{\mathscr{C}} i\} \\
e_k \tat{\tau}_{\mathscr{C}} e_k' 
\end{cases} \nonumber 
\end{align}

Это как раз то, что нам нужно доказать. 

{\textbf 2.} Рассмотрим случай $g = thread\_create$.
Используем требования~\ref{transfer_tm_ir_stronger_for_inner} для внутренних элементов и получаем, 
\begin{equation}
\label{transfer_condition_for_inner_thread_create}
\begin{aligned}
& \exists k : 1 \le k \le m \land t_k = t \\
& \forall j: 1\le j \le n: \\
& \exists t_1, \dots, t_n \in T, \forall p \neq q: t_p \neq t_q : \\
& c \in \epp_{\Delta_j}
\begin{pmatrix}
\begin{pmatrix}
e^j_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e^j_m \\
t_m 
\end{pmatrix}
\end{pmatrix} \implies \\
& \exists \widehat{e^j_1}, \dots, \widehat{e^j_{m+1}} \in E_j:
c' \in \epp_{\Delta_j}
\begin{pmatrix}
\begin{pmatrix}
\widehat{e^j_1} \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
\widehat{e^j_{m+1}} \\
t_{m+1} 
\end{pmatrix}
\end{pmatrix} \\
& \mbox{ где } \widehat{e^j_1} \dots \widehat{e^j_{m+1}} \mbox{ такие, что } \\
&\exists i^j_1, \dots, i^j_m: \\
&
\begin{cases}
\forall q \neq k: e^j_q \tat{i^j_q}_{\Delta_j} \widehat{e^j_q} \land i^j_q \in \{i \mid e^j_k \tat{\tau}_{\Delta_j} i\} \\
e^j_k \tat{\tau, tc_{parent}}_{\Delta_j} \widehat{e^j_k} \\
e^j_k \tat{\tau, tc_{child}}_{\Delta_j} \widehat{e^j_{m+1}}
\end{cases} 
\end{aligned}
\end{equation}

Заметим, что $k$ является одинаковым для всех внутренних элементов и поэтому можно объединить все внутренние состояния следующим способом:

\begin{align}
& \forall q: 1 \le q \le m + 1: e_q' = (\widehat{e^1_q}, \dots, \widehat{e^n_q}) \nonumber \\
& \begin{cases}
& i_q = (i^1_q, \dots, i^n_q), \mbox{ if } q \neq k \\
& i_k = (\tau, \dots, \tau)
\end{cases} \nonumber
\end{align}

Используя определение~\ref{composite_transfer_eq} отношения переходов композитного анализа, получаем:

\begin{equation}
\label{composite_transfer_eq_3}
\begin{aligned}
& e_1 \tat{i_1}_{\mathscr{C}} e_1', i_1 \in \{i' \mid e_k \tat{\tau}_{\mathscr{C}} i'\} \\
& \dots \\
& e_k \tat{\tau}_{\mathscr{C}} e_k', e_k \tat{\tau}_{\mathscr{C}} i'\\
& e_k \tat{\tau}_{\mathscr{C}} e_{m+1}'\\
& e_{k+1} \tat{i_{k+1}}_{\mathscr{C}} e_{k+1}', i_{k+1} \in \{i' \mid e_k \tat{\tau}_{\mathscr{C}} i'\} \\
& \dots \\
& e_m \tat{i_m}_{\mathscr{C}} e_m', i_m \in \{i' \mid e_k \tat{\tau}_{\mathscr{C}} i'\}
\end{aligned}
\end{equation}

Теперь используем требование~\ref{transfer_condition_for_inner_thread_create}

\begin{align}
& \forall j, c' \in  \epp_{\Delta_j}
\begin{pmatrix}
\begin{pmatrix}
\widehat{e^j_1} \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
\widehat{e^j_m} \\
t_m 
\end{pmatrix}
\end{pmatrix}
\implies (def.~\ref{composite_epp_def}) \implies
c' \in  \epp_{\mathscr{C}}
\begin{pmatrix}
\begin{pmatrix}
e_1' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_{m+1}' \\
t_{m+1} 
\end{pmatrix}
\end{pmatrix} \nonumber \\
& \mbox{ где } e_1' \dots e_{m+1}' \mbox{ такие, что (условие~\ref{composite_transfer_eq_3})} \nonumber \\
&\exists i_1, \dots, i_m, k: 1 \le k \le m, t_k = t :\nonumber \\
& \begin{cases}
\forall q \neq k: e_q \tat{i_q}_{\mathscr{C}} e_q' \land i_q \in \{i \mid e_k \tat{\tau}_{\mathscr{C}} i\} \\
e_k \tat{\tau}_{\mathscr{C}} e_k' \\
e_k \tat{\tau}_{\mathscr{C}} e_{m+1}
\end{cases} \nonumber 
\end{align}

\qedsymbol

% TODO: Is it a requirement or follows from the other requirements?

{\textbf 4.}
Оператор слияния может определяться различными способами, в зависимости от требований к анализу.

Самый простой способ: использовать оператор $merge$ каждого из внутренних видов анализа.
$merge^E_{\mathscr{C}}(e_1,e_2,\pi) = (merge^E_{\Delta_1}(e_1^1, e_2^1,\pi), \dots, merge^E_{\Delta_n}(e_1^n, e_2^n,\pi))$.
В этом случае объединение состояний каждого из внутренних вариантов анализа производится независимо друг от друга.
Проверим условие~\ref{cpa_merge_tm_e_eq}.
Воспользуемся тем, что внутренние CPA удовлетворяют условию~\ref{cpa_merge_tm_e_eq}, то есть $\forall i: e_2^i \sqsubseteq^E merge^E_{\Delta_i}(e_1^i, e_2^i,\pi)$.
По определению решетки $\mathscr{C}$ это означает, что $(e_2^1, \dots, e_2^n) = e_2 \sqsubseteq merge^E_{\mathscr{C}}(e_1,e_2,\pi)$.

Такой простой вариант объединения состояний не очень эффективен, например, состояния различных потоков не всегда имеет смысл обединять.
Для этого возможно объединение состояний, если состояния некоторого вида анализа равны. 

\begin{align}
merge^E_{\mathscr{C}}(e_1,e_2,\pi) =
& \begin{cases}
(e_1^1, merge^E_{\Delta_1}(e_1^2, e_2^2,\pi), \dots, merge^E_{\Delta_n}(e_1^n, e_2^n,\pi)), \mbox{ если } e_1^1 = e_2^1 \\
e_2, \mbox{ иначе }
\end{cases} \nonumber
\end{align}

В таком примере первый анализ определяет, что можно объединять остальные состояния, если его состояния совпадают.
Проверим условие~\ref{cpa_merge_tm_e_eq}.
Снова воспользуемся тем, что внутренние CPA удовлетворяют условию~\ref{cpa_merge_tm_e_eq}, то есть $\forall i: e_2^i \sqsubseteq^E merge^E_{\Delta_i}(e_1^i, e_2^i,\pi)$.
Заметим при этом, что это условие выполнено и для $i = 1$, так как $e_2^1 \sqsubseteq e_2^1$.
По определению решетки $\mathscr{C}$ это означает, что $(e_2^1, \dots, e_2^n) = e_2 \sqsubseteq merge^E_{\mathscr{C}}(e_1,e_2,\pi)$.

Другой вариант является согласованное объединение, которое выполняется, только если все внутренние CPA согласны объединить состояния, то есть результатом выполнения каждого внутреннего оператора $merge$ является нетривиальное состояние.

\begin{align}
merge^E_{\mathscr{C}}(e_1,e_2,\pi) =
& \begin{cases}
(merge^E_{\Delta_1}(e_1^1, e_2^1,\pi), \dots, merge^E_{\Delta_n}(e_1^n, e_2^n,\pi)),\\
\mbox{ если } \forall i, merge^E_{\Delta_i}(e_1^i, e_2^i,\pi) \neq e_2^i \\
e_2, \mbox{ иначе }
\end{cases} \nonumber
\end{align}

Доказательство условия~\ref{cpa_merge_tm_e_eq} полностью повторяет предыдущие два.

{\textbf 5.}

При объединении эффектов окружения возможны те же варианты, что и при объединении состояний:
\begin{itemize}
\item 
$merge^I_{\mathscr{C}}(i_1,i_2,\pi) = (merge^I_{\Delta_1}(i_1^1, i_2^1,\pi), \dots, merge^I_{\Delta_n}(i_1^n, i_2^n,\pi))$.

\item
\begin{align}
merge^I_{\mathscr{C}}(i_1,i_2,\pi) =
& \begin{cases}
(i_1^1, merge^I_{\Delta_1}(i_1^2, i_2^2,\pi), \dots, merge^I_{\Delta_n}(i_1^n, i_2^n,\pi)),\\
\mbox{ если } i_1^1 = i_2^1 \\
i_2, \mbox{ иначе }
\end{cases} \nonumber
\end{align}

\item
\begin{align}
merge^I_{\mathscr{C}}(i_1,e_2,\pi) =
& \begin{cases}
(merge^I_{\Delta_1}(i_1^1, i_2^1,\pi), \dots, merge^I_{\Delta_n}(i_1^n, i_2^n,\pi)),\\
\mbox{ если } \forall j, merge^I_{\Delta_i}(i_1^j, i_2^j,\pi) \neq i_2^j \\
i_2, \mbox{ иначе }
\end{cases} \nonumber
\end{align}

\end{itemize}

Доказательства условия~\ref{cpa_merge_tm_i_eq} полностью аналогичны доказательствам условия~\ref{cpa_merge_tm_e_eq} из предыдущего пункта.

{\textbf 6.}
$stop^E_{\mathscr{C}}(e,R,\pi)=\forall j \mbox{ } stop^E_{\Delta_j}(e_j, R_j, \pi)$, где $R_j = \{e_j \mid e \in R \land e = (\dots, e_j, \dots)\}$

Проверим условие~\ref{cpa_stop_tm_e_eq} для $\mathscr{C}$.
По условию~\ref{cpa_stop_tm_e_eq} для внутренних CPA выполнено $\forall 1 \le i \le n, \widehat{R_i} \subseteq E_i: \conc{\widehat{R_i} \cup \{e_i\}}_{TM} \subseteq \conc{R_i \cup \widehat{R_i}}_{TM}$.
Рассмотрим множество $\widehat{R} = \widehat{R_1} \times \dots \times \widehat{R_n} \subseteq E$. 
$\conc{\widehat{R} \cup \{e\}}_{TM} = \conc{\widehat{R_1} \cup \{e_1\}}_{TM} \cap \dots \cap \conc{\widehat{R_n} \cup \{e_n\}}_{TM} \subseteq \conc{R_1 \cup \widehat{R_1}}_{TM} \cap \dots \cap \conc{R_n \cup \widehat{R_n}}_{TM} = \conc{R \cup \widehat{R}}_{TM}$.

{\textbf 7.}
$stop^I_{\mathscr{C}}(i,R,\pi)=\forall j \mbox{ } stop^I_{\Delta_j}(i_j, R_j, \pi)$, где $R_j = \{i_j \mid i \in R \land i = (\dots, i_j, \dots)\}$
Доказательство условия~\ref{cpa_stop_tm_i_eq} полностью повторяет доказательство утверждения~\ref{cpa_stop_tm_e_eq} из предыдущего пункта.

{\textbf 8.}
$prec^E_{\mathscr{C}}(e,\pi)=(prec^E_{\Delta_1}(e_1, \pi_1), \dots, prec^E_{\Delta_n}(e_n, \pi_n)$. Условие~\ref{prec_tm_e_equation} выполнено для композитного анализа, если оно выполнено для каждого из внутренних видов анализа $\Delta_j$, так как по определению $e \sqsubseteq e' \iff \forall j: e_j \sqsubseteq e_j'$.

{\textbf 9.}
$prec^I_{\mathscr{C}}(i,\pi)=(prec^I_{\Delta_1}(i_1, \pi_1), \dots, prec^I_{\Delta_n}(i_n, \pi_n)$. Условие~\ref{prec_tm_i_equation} выполнено для композитного анализа, если оно выполнено для каждого из внутренних видов анализа $\Delta_j$, так как по определению $i \sqsubseteq i' \iff \forall j: i_j \sqsubseteq i_j'$.

{\textbf 10.} 
$compatible_{\mathscr{C}}(e, i) = compatible_{\Delta_1}(e_1, i_1) \land \dots \land compatible_{\Delta_n}(e_n, i_n)$

\section{Простой анализ потоков}
\label{sect_thread_analysis}
Определим анализ потоков, инвариантный к переходам по окружению, 
$\mathbb{T}=(D_{T},$ $\Pi_{T}, \tatarrow_{T},$ $merge^E_{T}, stop^E_{T},$ $prec^E_{T}, compatible_{T})$, который будет определять идентификаторы потоков.

Анализ потоков содержит те же ограничения, что и анализ, представленный в статье~\cite{ThreadModular03}, и его применение ограничено на программы с ограниченным количеством создаваемых потоков.
Предполагаем, что программа имеет ограниченное количество потоков, определяемые точками создания этих потоков, то есть $T\subseteq L$ и для $thread\_create(pc_\nu)$ всегда создается поток с идентификатором $pc_\nu$.
Заметим, что остальные виды анализа не ограничены количеством создаваемых потоков.

{\textbf 1.} Домен $D_T$ основан на решетке над множеством идентификаторов потоков $T$: 
$D_T = (C, \mathcal{E}, \mathcal{I}, \epp)$, где $\mathcal{E}=(E_T, \top^E, \bot^E, \sqsubseteq^E, \sqcup^E)$, $E_T=T \cup \{\bot^E,\top^E\}$, $\bot^E \sqsubseteq t \sqsubseteq^E \top^E$ и $t \neq t'$ $\Rightarrow$ $t \not\sqsubseteq^E t'$ для всех элементов $t, t'\in T$ 
(что означает $\bot^E \sqcup^E t = t$, $\top^E \sqcup t = \top^E$, $t \sqcup^E t' = \top^E$ для всех элементов $t,t'\in T$, $t\neq t'$), 
и 
\begin{itemize}
\item $\forall t_1, \dots, t_j \in T:$
\begin{equation}
\begin{aligned}
& compatible^E(\{t_1,\dots, t_j\}) = \forall k\ne m: t_k\ne t_m\\
\end{aligned}
\end{equation}

\item $\forall t_1, \dots, t_j \in T:$
\begin{equation}
\begin{aligned}
& \epp(t_1,\dots,t_j) = 
\begin{cases}
& \left\lbrace (c_{pc},c_l,c_g,c_s) \in C 
\left| 
\begin{array}{c}
dom(c_{pc}) = \{t_1, \dots, t_j\}\\
dom(c_l) = \{t_1, \dots, t_j\}\\
\end{array}
\right.
\right\rbrace, \\
& \mbox{if } compatible^E(\{t_1,\dots, t_j\})\\
& \emptyset \mbox{ else}
\end{cases}
\end{aligned}
\end{equation}

\item $\mathcal{I}=\{\varepsilon\}$. 
\end{itemize}

{\textbf 2.} Множество точности не используется и состоит из одного элемента: $\Pi_T = \{\pi_0\}$.

{\textbf 3.} Отношение переходов $\tatarrow_T$ определяет переход $t \tat{\tau, g}_T (t', \pi)$ если $t=t'$ и $g=(\cdot,op,\cdot)$ и 
\begin{itemize}
\item $op \neq tc_{parent}$ и $op\neq tc_{child}$ (синтаксический дочерний элемент ГПУ без учета семантики операции $op$). 
\item $op=tc_{parent}(l_\nu)$, тогда $t \tat{\tau, g}_T (t, \pi)$,
\item $op=tc_{child}(l_\nu)$, тогда $t \tat{\tau, g}_T (l_\nu, \pi)$.
\end{itemize}

Переход $\top \tat{\tau, g}_T (\top, \pi)$ определен для всех $g\in G$.

$\forall t,i \in E_T: compatible^E(t,i) \implies t \tat{i, g}_T (t, \pi)$, потому что 
\begin{itemize}
\item эффекты окружения защищают переход от проверки неравенста идентификаторов потока в операторе $compatible$,
\item состояния являются {\em инвриантными к окружению}, i.e. ни один поток не может изменить идентификатор другого потока.
\end{itemize}

{\textbf 4.} Оператор слияния не объединяет абстрактные состояния: $merge^E_T(e, e', \pi) = e'$. Условие~\ref{cpa_merge_tm_e_eq} очевидно выполнено.

{\textbf 5.} Оператор останова для абстрактных состояний проверяет наличие абстрактного состояния во множестве достижимых состояний: $stop^E_T(e, R, \pi) = (e \in R)$.
Проверим условие~\ref{cpa_stop_tm_e_eq}.
Возьмем $\widehat{R} \subseteq E_T: \conc{\widehat{R} \cup e}_TM \subseteq \conc{\widehat{R} \cup e \cup R}_TM = \conc{\widehat{R} \cup R}_TM$.

{\textbf 6.} Точность состояний анализа никогда не меняется: $prec^E_T(e, \pi, R) = (e, \pi)$. Условие~\ref{prec_tm_e_equation} выполнено, так как $e \sqsubseteq e$.

{\textbf 7.} $compatible_T(e,i) \equiv compatible^E(e,i)$

%----------------------------------------------------
%----------------------------------------------------
%----------------------------------------------------
\section{Анализ точек программы}
\label{sect_location_analysis}

Определим анализ точек программы (Location Analysis), инвариантный к переходам по окружению,
$\mathbb{L}=(D_{L},$ $\Pi_{L}, \tatarrow_{L}, merge^E_{L}, stop^E_{L}, prec^E_{L}, compatible_{L})$, который отвечает за синтаксическую достижимость точек программы.
Классический вариант этого анализа описан в~\cite{Beyer08}.
Расширим его компоненты для возможности его применения в анализе с раздельным рассмотрением потоков.
 
{\textbf 1.} Абстрактный домент $D_L$ основан на плоской решетке над множеством точек программы $L$: 
$D_L = (C, \mathcal{E}, \mathcal{I}, compatible^E, \epp)$, с $\mathcal{E}=(E_L, \top^E, \bot^E, \sqsubseteq^E, \sqcup^E)$, $E_L= L \cup \{\bot^E,\top^E\}$, $\bot^E \sqsubseteq l \sqsubseteq^E \top^E$ and $l \neq l'$ $\Rightarrow$ $l \not\sqsubseteq^E l'$ для всех элементов $l, l' \in L$ 
(отсюда следует $\bot^E \sqcup^E l = l$, $\top^E \sqcup l=\top^E$, $ l\sqcup^E l' = \top^E$ для всех элементов $l,l'\in L$, $l\neq l'$), 
и
$\forall l_1, \dots, l_j \in L:$
\begin{equation}
\label{location_epp_def}
\begin{aligned}
\epp_{\mathbb{L}}
\begin{pmatrix}
\begin{pmatrix}
l_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
l_m \\
t_m 
\end{pmatrix}
\end{pmatrix} = 
\left\lbrace (c_{pc},c_l,c_g,c_s) \in C 
\left| 
\begin{array}{c}
t_1, \dots, t_m \in T\\
c_{pc} = 
\left\lbrace
\begin{array}{c}
t_1 \to l_1,\\
\dots\\
t_m \to l_m\\
\end{array}
\right\rbrace, \\
dom(c_l) = \{t_1, \dots, t_m\}\\
\end{array}
\right.
\right\rbrace\\
\end{aligned}
\end{equation}

$\mathcal{I}=(I_L, \top^I, \bot^I, \sqsubseteq^I, \sqcup^I)$ содержит один элемент ($I_L=\{\varepsilon\}$), так как состояния этого анализа {\em инвариантны к окружению}, то есть ни один поток не может изменить точку в программе, на которой находится другой поток.

{\textbf 2.} Множество точности содержит только один элемент $\Pi_L = \{\pi_0\}$, так как не подразумевается применение абстракции.

{\textbf 3.} Отношение переходов $\tatarrow_L$ содержит переход $l \tat{\tau, g}_L (l', \pi)$, где $g=(l_1,op,l_2)$, если $l_1 = l$ и
\begin{itemize}
\item $op \neq tc_{child}$ и $l' = l_2$ (следующее состояние в ГПУ без учета семантики операции $op$). 
\item $op=tc_{child}(l_\nu)$ и $l_2 = l_\nu$. 
\end{itemize}

Есть переход $\top \tat{\tau, g}_L (\top, \pi)$ для всех $g\in G$.

$\forall l \in E_L: l \tat{\varepsilon, g}_T (l, \pi)$, так как 
\begin{itemize}
\item эффект окружения $\varepsilon$ не ограничивает переход,
\item состояния {\em инвариантны к окружению}, то есть ни один поток не может изменить точку в программе, на которой находится другой поток.
\end{itemize}

Проверим условие~\ref{transfer_tm_ir_stronger_for_inner}.
Возьмем случайное состояние $c \in \epp
\begin{pmatrix}
\begin{pmatrix}
l_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
l_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$

По определению~\ref{location_epp_def} это означает 
$$ c_{pc} = 
\left\lbrace
\begin{array}{c}
t_1 \to l_1,\\
\dots\\
t_m \to l_m\\
\end{array}
\right\rbrace.$$

Рассмотрим случайный переход $c \tc{g,t} c'$. Если этот переход возможен на конкретных состояниях, это означает, что $\exists k : 1 \le k \le m \land t_k = t$. Зафиксируем это значение $k$ и будем рассматривать $\tau$-переходы из состояния $l_k$. Остальные состояния не изменятся, так как переход по пустому переходу окружения не меняют состояния.

%TODO thread\_join
Рассмотрим случай $g \neq thread\_create$. В этом случае $l_k' = l_2$ -- вершине ГПУ, в который направлена дуга $g$. Изменений других состояний нет. $$ c'_{pc} = 
\left\lbrace
\begin{array}{c}
t_1 \to l_1,\\
\dots,\\
t_k \to l_k'\\
\dots,\\
t_m \to l_m\\
\end{array}
\right\rbrace.$$ Это означает, что $$с' \in \begin{pmatrix}
\begin{pmatrix}
l_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
l_k' \\
t_k 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
l_m \\
t_m 
\end{pmatrix}
\end{pmatrix}.$$

Рассмотрим случай $g = thread\_create(l_\nu)$. В этом случае также $l_k' = l_2$ -- вершине ГПУ, в который направлена дуга $g$, а $l_{m+1} = l_\nu$. Здесь $l_k \tat{tc_{parent}} l_k'$, $l_k \tat{tc_{child}} l_\nu$. При этом переходе $$ c'_{pc} = 
\left\lbrace
\begin{array}{c}
t_1 \to l_1,\\
\dots,\\
t_k \to l_k'\\
\dots,\\
t_m \to l_m,\\
t_{m+1} \to l_{m+1}\\
\end{array}
\right\rbrace.$$ Это означает, что $$ с' \in \begin{pmatrix}
\begin{pmatrix}
l_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
l_k' \\
t_k 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
l_m \\
t_m 
\end{pmatrix}& ,
\begin{pmatrix}
l_\nu \\
t_{m+1} 
\end{pmatrix}
\end{pmatrix}$$.


{\textbf 4.} Оператор слияния не объединяет элементы: $merge^E_L(e, e', \pi) = e$. Очевидно, он удовлетворяет условию~\ref{cpa_merge_tm_e_eq}, так как $e \sqsubseteq e$.

{\textbf 5.} Оператор останова рассматривает состояния индивидуально: $stop^E_L(e, R, \pi) = (e \in R)$. Очевидно, он удовлетворяет условию~\ref{cpa_stop_tm_e_eq}, так как
\begin{align}
&\forall e \in E, R \subseteq E, \pi \in \Pi: \nonumber \\
& (e \in R) \implies \forall \widehat{R} \subseteq E: \{e\} \cup \widehat{R} \subseteq R \cup \widehat{R} \implies \nonumber \\
& \implies (eq.\ref{cpa_conc_eq_0}) \forall \widehat{R} \subseteq E: \conctm{\{e\}\cup \widehat{R}} \subseteq \conc{R' \cup \widehat{R}}
\end{align}

{\textbf 6.} Точность состояния никогда не изменяется: $prec^E_L(e, \pi, R) = (e, \pi)$.
Очевидно, он удовлетворяет условию~\ref{prec_tm_e_equation}, так как $e \sqsubseteq e$.

{\textbf 7.} $compatible(l,\varepsilon) = true$.

%----------------------------------------------------
%----------------------------------------------------
%----------------------------------------------------

\section{Анализ предикатов}
\label{sect_predicate_analysis}
Пусть $\mathscr{P}$ -- это множество предикатов над переменными программы в теории без кванторов $\mathscr{T}$.
Формула $\varphi$ является логической комбинацией предикатов из $\mathscr{P}$.

Пусть $v: X \to \mathbb{Z}$ является отображением из переменной в ее значение.
Определим $v \models \varphi$, где $v$ называется моделью $\varphi$.

Опредилим переименование переменных $\theta: X \to X'$, которое применимо к формулам $\theta(\varphi)$ и их моделям $\theta(v)$.
Обозначим
$$\theta_{X,i}= 
\left\lbrace\begin{array}{ll}
x \mapsto x\#i, & \mbox{ если } x \in X\\
x \mapsto x, &\mbox{ иначе}.\\
\end{array}
\right.
$$
и
$$\theta_{X,i}^{-1}= 
\left\lbrace\begin{array}{ll}
x\#i \mapsto x, & \mbox{ если } x \in X\\
x \mapsto x, &\mbox{ иначе}.\\
\end{array}
\right.
$$

Определим $(\varphi)^\pi$ -- логическую предикатную абстракцию формулы $\varphi$.

Определим $SP_{op}(\varphi)$ -- сильнейшее постусловие $\varphi$ и операции $op$.

Требование: $c \tc{op} c' \land (c_l, c_g) = v \models \varphi \implies (c_l', c_g') = v' \models SP_{op}(\varphi)$

Определим анализ предикатов (Predicate Analysis) $\mathbb{P}=(D_{P},$ $\Pi_{P}, \tatarrow_{P},$ $merge^E_{P}, stop^E_{P},$ $merge^I_{P}, stop^I_{P},$ $prec^E_{P},prec^I_{P},$ $compatible_{P})$, который отслеживает значение предикатов над переменными программы.

Он состоит из следующий компонентов.

{\textbf 1.} Абстрактный домен $D_{P}=(C, \mathcal{E}, \mathcal{I}, compatible^E, \epp)$:

\begin{itemize}
\item Полурешетка
$\mathcal{E}=(E, \top^E, \bot^E, \sqsubseteq^E, \sqcup^E)$, которая состоит из множества
$E = \mathcal{P}$, 
$\top^E = true$ и $\bot^E = false$.

Частичный порядок $\sqsubseteq^E \subseteq E \times E$ определяется как $e \sqsubseteq^E e' \Leftrightarrow e \implies e'$.
Объединение элементов $\sqcup^E: E \times E \to E$ определяет ближайший верхний по решетке элемент в соответствии с частичным порядком.

\item
Определим совместные частичные состояния как те, которые имеют общую глобальную часть ($X^{global}$).
Для этой цели мы переименуем локальные переменные каждого состояния, и поэтому у нас должно быть общее решение для глобальных переменных, если взять конъюнкцию всех состояний.

\begin{equation}
\begin{aligned}
& \forall e_1, \dots, e_j \in E \\
& compatible^E(\{e_1,\dots, e_j\}) = \\
& \exists v: v \models \theta_{X^{local},1}(e_1) \land \dots \land \theta_{X^{local},n}(e_n)
\end{aligned}
\end{equation}

Для совместных состояний $e_1, \dots, e_j \in E$ и для каждого решения 
$v \models \theta_{X^{local},1}(e_1) \land \dots \land \theta_{X^{local},n}(e_n)$
можно определить функцию $\hat v_g = v_{\mid X^{global}}$, представляющую общую глобальную часть состояния и функции $\hat v_1=\theta_{X^{local},1}^{-1}(v)_{\mid X^{local}}, \dots, \hat v_j=\theta_{X^{local},1}^{-1}(v)_{\mid X^{local}}$, представляющие локальные части.

Функция объединения $\epp: 2^(E \times T) \to 2^C$ сопоставляет каждому множеству абстрактных состояний сумму их совместных частичных состояний (мы рассматриваем локальную часть идивидуальных состояний $\hat v_i$ и общую глобальную часть $\hat v_g$).

\item Полурешетка
$\mathcal{I}=(I, \top^I, \bot^I, \sqsubseteq^I, \sqcup^I)$, которая состоит из двух формул $I=\mathscr{P}\times \mathscr{P}$.

Первая формула обозначает начальное состояние (используется для проверки совместности), а вторая формула представляет глобальные переменные, которые были изменены окружением.

При этом $\top^I=(true,true)$, $\bot^I=(false,false)$, 
$\sqsubseteq^I$ ($\sqcup^I$)  определяется применением  $\sqsubseteq^E$ ($\sqcup^E$) к первому и второму элементу пары.
\end{itemize}

{\textbf 2.} Множество точности $\Pi_P = 2^\mathscr{P}$ отвечает за точность абстрактного состояния и содержит в себе множество предикатов.

{\textbf 3.} Отношение переходов $e \tat{i,g}_C (e',\pi)$.

\begin{itemize}
\item Для $i=\tau$ переход $e \tat{\tau, g}_{P} (e', \pi)$ и $e \tat{\tau, g}_{P} (i', \pi)$, где $g = (\cdot, op, \cdot)$, существует, если
$$e'= 
\left\lbrace\begin{array}{ll}
(SP_{op}(e))^\pi, & \mbox{ если } op=assign(w, expr) \lor op=assume(expr)\\
e, &\mbox{ иначе}.\\
\end{array}
\right.
$$
и 
$$i'= 
\left\lbrace
\begin{array}{ll}
(\theta_{X^{local},env}(e),\theta_{X^{local},env}(SP_{op}(e))),&\mbox{если } op=assign(w, expr),\\
(\theta_{X^{local},env}(e),true),&\mbox{иначе}.\\
\end{array}
\right.
$$


\item Для $i=(\hat e,\hat \varphi)$ переход вычисляет абстракцию для формулы $\hat \varphi \land e$ для совместных состояний $e$ и $\hat e$.

Определим совместность состояния и эффекта окружения $compatible(e, i)$, где  $i=(\hat e,\hat \varphi)$.

\begin{equation}
\label{cpa_predicate_compatible}
\begin{aligned}
& compatible_{TM}(e, i) = \exists v: v \models e \land \hat e
\end{aligned}
\end{equation}

Переход $e \tat{i, g}_{C} (e', \pi')$, где $i=(\hat e,\hat \varphi)$, существует, если
$compatible_{TM}(e,i)$ и $e'= (\hat \varphi \land e)^{\pi'}$.
\end{itemize}

\begin{proof}

Покажем, что определение отношения переходов удовлетворяют условию~\ref{transfer_tm_ir_stronger}. 

Рассмотрим случайное состояние $c \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$ и переход $c \tcarrow{t, g} c'$.

Не будем подробно рассматривать случаи $g = thread\_create$, $g = thread\_join$, так как эти переходы не меняют состояния анализа предикатов и не меняют состояние памяти ($c_l$ и $c_g$). Поэтому в этом случае $c, c' \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$.

Рассмотрим теперь случай $g = assign$ или $g = assume$. Зафиксируем значение $k$ такое, что $t_k = t$. Будем рассматривать переход в потоке из состояния $e_k$.

$e_k \tatarrow{\tau} e_k'$, $e_k \tat{\tau} i' = (\theta_{X^{local},env}(e),\theta_{X^{local},env}(SP_{op}(e_k))$. 
$\forall j \neq k: e_j \tat{i'} e_j'$.
Переход по эффекту окружения возможен, так как состояния являются совместными -- к ним был применим оператор $epp$.

Проверим совместность состояний $e_k'$ и $e_j'$ ($j \neq k$), где $e_k' = (SP_{op}(e_k))^\pi$, $e_j' = (e_j \land \theta_{X^{local},env}(SP_{op}(e_k))^\pi$. 
Заметим, что $\exists v': v' \models e_k'$, иначе перехода $c \tat{t, g} c'$ не было бы.
Кроме того, известно, что $\exists v: v \models e_k \land e_j$, так как состояния были совместны.
Если же не существует такого $\widehat{v}$, который $v' \models e_k' \land e_j'$, это означает, что не существует одинаковых значений глобальных переменных для всех потоков, то есть, перехода $c \tat{t, g} c'$ быть не может.

%Consider an arbitrary $c = (c_{pc}, c_l, c_g, c_s) \in \conc{R}$ and an arbitrary $c'= (c_{pc}', c_l', c_g', c_s'): c \tcarrow c'$.

%\begin{align}
%& c \in \conc{R} \Leftrightarrow \exists e_1 \dots e_n \in R: compatible^E(\{e_1, \dots, e_n\}) \land c \in \epp (\{e_1, \dots, e_n\}) \nonumber 
%\end{align}

%\begin{enumerate}
%\item If $c \tcarrow c'$ does not change $c_g$ and $c_l$, it means $c' \in \conc{R}$, as $\epp$ operator does not limit $c_{pc}$ and $c_s$.
%
%\item If $c \tcarrow c'$ changes only $c_l$.
%So, $\exists i: (t_i \mapsto cl_i) \in c_l$ changed into $(t_i \mapsto cl_i') \in c_l'$.
%We do not know the particular $i$, anyway we consider all $e \tat{\tau} e', e \in R$.
%By the definition $e' = (SP_{op}(e))^\pi$.
%The requirement for $SP_{op}(e)$: $cl_i \models e \implies cl_i' \models e' = SP_{op}(e)$.
%That means $c' \in \epp (\{e_1, \dots, e_i', \dots, e_n\})$
%
%\item If $c \tcarrow c'$ changes $c_g$. So, $\exists g \in G, t \in T: c \tc{g, t} c'$.
%The operation $g$ can be applied to one of $e_i$: $e_i \tat{\tau} e_i'$ and $e_i \tat{\tau} i'$. $compatible^E(\{e_1, \dots, e_n\}) \implies compatible_{TM}(e_i, i')$
%That means we may apply $e_i' \tat{i'} e_i''$. The requirement $\forall i: c_g \models e_i \implies c_g' \models e_i'' = SP_{op}(e_i)$.
%Then, $c' \in \epp (\{e_1'', \dots, e_n''\})$.
%
%\end{enumerate}
\end{proof}

{\textbf 4.} Оператор слияния состояний не объединяет элементы: $merge^E_{P}(e, e', \pi) = e'$. Требование~\ref{cpa_merge_tm_e_eq} очевидно выполнено, так как $e' \sqsubseteq e'$.

{\textbf 5.} Оператор слияния состояний не объединяет элементы: $merge^I_{Sep}(i, i', \pi) = i'$. 
Требование~\ref{cpa_merge_tm_i_eq} очевидно выполнено, так как $i' \sqsubseteq i'$.

Options: 
\begin{enumerate}
\item merge second elements of inference objects (modifications) for equal (or covered) first elements (start states).
$$merge^I_{Eq}(i, i', \pi)= 
\left\lbrace\begin{array}{ll}
(e, \varphi \lor \varphi'), & \mbox{ if } e = e' \\
i', &\mbox{ otherwise}.\\
\end{array}
\right.$$
\item merge first and second elements
$$merge^I_{Join}(i, i', \pi)= 
(e \lor e', \varphi \lor \varphi')$$
\end{enumerate}

{\textbf 6.} Оператор останова проверяет, покрыто ли состояние $e$ другим состоянием из множества достижимых состояний: $stop^E_{P}(e, R, \pi) = \exists e'\in R: (e \sqsubseteq e')$.

\begin{proof}
Проверим, что требование~\ref{cpa_stop_tm_e_eq} выполнено.
\begin{align}
&\forall e \in E, R, \widehat{R} \subseteq E, \pi \in \Pi: \nonumber \\
& e \sqsubseteq e' \implies (eq.~\ref{cpa_conc_eq_2}) \implies \conctm{\widehat{R} \cup R \cup e} \subseteq \conctm{\widehat{R} \cup R \cup e'} \implies \nonumber \\
& \implies (eq.~\ref{cpa_conc_eq_0}) \implies \conctm{\widehat{R} \cup e} \subseteq \conctm{\widehat{R} \cup R} \nonumber
\end{align}
\end{proof}

{\textbf 7.} Оператор останова для эффектов окружения проверяет, может ли изменить состояние этот эффект и не покрыт ли он другим эффектом окружения, находящимся во множестве достижимых состояний:  $i=(\psi,\varphi)$
$stop^I_{P}(i, R, \pi) = (\varphi=true) \lor \exists i'\in R: i' \sqsubseteq i$.

\begin{proof}
Требование~\ref{cpa_stop_tm_i_eq} может быть проверено по аналогии с п. 6. 
\end{proof}

{\textbf 8.} $prec^E_{P}(e, \pi, R) = (e, \pi)$. Условие~\ref{prec_tm_e_equation} выполнено, так как $e \sqsubseteq e$.

{\textbf 9.} $prec^I_{P}(i, \pi, R) = (i, \pi)$. Условие~\ref{prec_tm_i_equation} выполнено, так как $e \sqsubseteq e$.

{\textbf 10.} Проверка совместности была определена в~\ref{cpa_predicate_compatible}.

\section{Анализ примитивов синхронизации}
\label{sect_lock_analysis}

\newcommand{\bots}{\bot_\mathcal{S}}
\newcommand{\tops}{\top_\mathcal{S}}

Определим анализ примитивов синхронизации (Lock Analysis), инвариантный к переходам по окружению, $\mathbb{S}=(D_{S},$ $\Pi_{S}, \tatarrow_{S},$ $merge^E_{S}, stop^E_{S},$ $prec^E_{S},$ $compatible_{S})$, который будет следить за множеством захваченных блокировок для каждого потока.

Он состоит из следующих компонент.

{\textbf 1.} Абстрактный домен $D_{S}=(C, \mathcal{E}, \mathcal{I},compatible^E, \epp)$ использует полурешетку
$\mathcal{E}=(E, \top^E, \bot^E, \sqsubseteq^E, \sqcup^E)$, которая состоит из множества 
$E: 2^S \cup \{\top^E, \bot^E\}$ подмножеств всех переменных синхронизации, 
где 
$\bot^E \sqsubseteq ls \sqsubseteq^E \top^E$ и $ls \subseteq ls'$ $\Rightarrow$ $ls \sqsupseteq^E ls'$ для всех элементов $ls, ls' \subseteq S$ 
(откуда следует $\bot^E \sqcup^E ls = ls$, $\top^E \sqcup ls=\top^E$, $ ls\sqcup^E ls' = ls \cap ls'$ для всех элементов $ls,ls'\subseteq S$, $ls\neq ls'$), 
и 
\begin{itemize}
\item $\forall ls_1, \dots, ls_m \in S:$
\begin{equation}
\begin{aligned}
& \epp_S \begin{pmatrix}
\begin{pmatrix}
ls_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix} = \nonumber \\
& = \begin{cases}
& \left\lbrace (c_{pc},c_l,c_g,c_s,c_t) \in C 
\left| 
\begin{array}{c}
\exists \mathbb{M} \subseteq \{1, \dots,m\} \\
dom(c) = \{t \mid t_i \in \{t_1,\dots,t_m\} \land i \in \mathbb{M}\}\\
\forall s \in S:
c_s(s) = 
\left\lbrace
\begin{array}{ll}
t_1,&\mbox{if } s \in ls_1,\\
\dots\\
t_j,&\mbox{if } s \in ls_j,\\
\cdot,& \mbox{otherwise}\\
\end{array}
\right.\\
\end{array}
\right.
\right\rbrace\\
& \mbox{if } \forall i \neq j: compatible_{TM}(ls_i, ls_j), t_i \in T, t_i \neq t_j \\
& \emptyset \mbox{ else}
\end{cases}
\end{aligned}
\end{equation}

\begin{proof}
Покажем, что требование~\ref{cpa_tm_abstract_domain_2} выполнено.

Пусть $ls \sqsubseteq ls', ls, ls', ls_1, \dots,ls_m \in E_S, t_1, \dots, t_m \in T$.

Если $\exists i, j: compatible_S(ls_i, ls_j) = false$, значит $\epp_S \begin{pmatrix}
\begin{pmatrix}
ls \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix}=\emptyset \subseteq \epp_S(ls', \dots)$.

Теперь рассмотрим случай $\forall i, j: compatible_S(ls_i, ls_j)$. 
Воспользуемся определением совместности состояний: $\forall i: ls \sqsubseteq ls' \land compatible(ls, ls_i) \implies compatible(ls', ls_i)$.

Пусть $\exists s \in S: s \in ls \setminus ls'$. Тогда
$\forall c \in \epp_S \begin{pmatrix}
\begin{pmatrix}
ls \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix}: c_s(s) = t_1$.
И $\forall c \in \epp_S \begin{pmatrix}
\begin{pmatrix}
ls' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix}: c_s(s) = \cdot$.
Это означает
$\forall c \in \epp_S \begin{pmatrix}
\begin{pmatrix}
ls \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix}: c \in \epp_S \begin{pmatrix}
\begin{pmatrix}
ls' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$

Это означает $\epp_S \begin{pmatrix}
\begin{pmatrix}
ls \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix} \subseteq \epp_S \begin{pmatrix}
\begin{pmatrix}
ls' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$
\end{proof}

\item $\mathcal{I}=\mathcal{E}$.
\end{itemize}

{\textbf 2.} В анализе применяется только одна точность: $\Pi_S = \{\pi_o\}$.

{\textbf 3.} Отношение переходов $\tatarrow_S$ содержит переход $ls \tat{\tau, g}_S (ls', \pi)$, с $g=(\cdot,op,\cdot')$ если 
\begin{itemize}
\item $op=acquire(s)$ и $s \notin ls \land ls' = ls \cup \{s\}$,
\item $op=release(s)$ и $ls' = ls \setminus \{s\}$,
\item $op=tc_{child}(l_\nu)$ и $ls' = \emptyset$. 
\item $op \neq acquire$ и $op \neq release$ и $op \neq tc_{child}$ и $ls' = ls$.
\end{itemize}

Переход $\top^E \tat{\tau, g}_S (\top^E, \pi)$ доступен для всех $g\in G$.

$\forall s,i \in E_S: compatible^E_S({s,i}) \implies s \tat{i, g}_S (s, \pi)$, потому что 
\begin{itemize}
\item переход по окружению не возможен, только если он происходит с теми же захваченными блокировками,
\item состояния являются {\em инвариантными к окружению}, то есть ни один поток не может изменить статус блокировки, захваченной в другом потоке.
\end{itemize}

Покажем, что выполнено условие~\ref{transfer_tm_ir_stronger_for_inner}. 
Рассмотрим случайное состояние $c \in \epp
\begin{pmatrix}
\begin{pmatrix}
ls_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$ и переход $c \tcarrow{t, g} c'$.

Не будем подробно рассматривать случаи $g = thread\_create$, $g = thread\_join$, так как эти переходы не меняют состояния анализа предикатов и не меняют состояние примитивов синхронизации ($c_s$). Поэтому в этом случае $c, c' \in \epp
\begin{pmatrix}
\begin{pmatrix}
ls_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$.

Рассмотрим теперь случай $g = acquire$. Зафиксируем значение $k$ такое, что $t_k = t$. Будем рассматривать переход в потоке из состояния $ls_k$.

$c \tcarrow{t, acquire s} c'$, $ls_k \tat{acquire s} ls_k'$, нужно показать, что 
$c' \in \epp
\begin{pmatrix}
\begin{pmatrix}
ls_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_k' \\
t_k 
\end{pmatrix}
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$

По определению отношения переходов $c_s'(s) = t_k$, $ls_k' = ls_k \cup \{s\}$.
Заметим, что если переход есть на конкретных состояниях, это означает, что блокировка $s$ не захвачена ни одним из потоков $t_1, \dots, t_n$.
А это, в свою очередь, означает, что $s \notin e_i, 1 \le i \le n, i \neq k$.
Таким образом, новое состояние $ls_k'$ остается совместным с остальными частичными состояниями $ls_i, i \neq k$.
По определению $\epp_S$
\begin{align}
 \begin{pmatrix}
\begin{pmatrix}
ls_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_k' \\
t_k 
\end{pmatrix}
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix} = \nonumber \\
& = 
& \left\lbrace (c_{pc},c_l,c_g,c_s,c_t) \in C 
\left| 
\begin{array}{c}
\exists \mathbb{M} \subseteq \{1, \dots,m\} \\
dom(c) = \{t \mid t_i \in \{t_1,\dots,t_m\} \land i \in \mathbb{M}\}\\
\forall s \in S:
c_s(s) = 
\left\lbrace
\begin{array}{ll}
t_1,&\mbox{if } s \in ls_1,\\
\dots\\
t_j,&\mbox{if } s \in ls_j,\\
\cdot,& \mbox{otherwise}\\
\end{array}
\right.\\
\end{array}
\right.
\right\rbrace \subseteq \nonumber \\
& \subseteq \left\lbrace (c_{pc},c_l,c_g,c_s,c_t) \in C 
\left| 
\begin{array}{c}
dom(c) = dom(c_0)\\
c_s = c_s \cup \{s \mapsto t_k\}
\end{array}
\right.
\right\rbrace = C_0
\end{align}

Очевидно, $c' \in C_0$.
Аналогично можно проверить, что операция $g = release s$ удовлетворяет условию~\ref{transfer_tm_ir_stronger_for_inner}. 

{\textbf 4.} Оператор слияния не объединяет абстрактные состояния: $merge^E_S(e, e', \pi) = e'$.

{\textbf 5.} Оператор останова проверяет, существует ли состояние, которое содержит меньше захваченных блокировок: $stop^E_S(e, R, \pi) = (\exists e' \in R \land e \sqsubseteq e')$.
Проверим, что требование~\ref{cpa_stop_tm_e_eq} выполнено.
\begin{proof}
\begin{align}
&\forall e \in E, R, \widehat{R} \subseteq E, \pi \in \Pi: \nonumber \\
& e \sqsubseteq e' \implies (eq.~\ref{cpa_conc_eq_2}) \implies \conctm{\widehat{R} \cup R \cup e} \subseteq \conctm{\widehat{R} \cup R \cup e'} \implies \nonumber \\
& \implies (eq.~\ref{cpa_conc_eq_0}) \implies \conctm{\widehat{R} \cup e} \subseteq \conctm{\widehat{R} \cup R} \nonumber
\end{align}
\end{proof}

{\textbf 6.} Точность анализа никогда не изменяется: $prec^E_S(e, \pi, R) = (e, \pi)$.

{\textbf 7.} $compatible_S(e,i) = (e \cap i = \emptyset)$

\section{Расширенный анализ потоков}
\label{sect_simple_extended_thread_analysis}

Определим анализ потоков
$\mathbb{M}=(D_{M},$ $\Pi_{M}, \tatarrow_{M},$ $merge^E_{M}, stop^E_{M},$ $prec^E_{M},$ $compatible_{M})$, который отслеживает идентификаторы потоков.

\textbf{Основные предположения } этого анализа следующие
\begin{enumerate}
\item 
\begin{equation}
\label{main_assumption_1}
\begin{aligned}
& \forall c \tat{t, g} c': g = thread\_exit() \\
& \forall t_c \in T: (t_c, t) \notin c_m
\end{aligned}
\end{equation}
\item 
\begin{equation}
\label{main_assumption_2}
\begin{aligned}
& \forall c \tat{t, g} c': g = thread\_create(var, num, l_{\nu}) \\
& \forall n: c_t(var, n) \notin T \\
\end{aligned}
\end{equation}
\item 
\begin{equation}
\label{main_assumption_4}
\begin{aligned}
& \mbox{Для любой программы существует }{TCT}_g \subseteq X_t \to X_t: \\ % here we strongly use 2.
& \forall c,c'\in C, t\in T: c \tat{t, g} c': g = thread\_create(var, num, l_{\nu})\\
& \forall v \in X_t, n \in \mathbb{N}: c_t(v, n) = t \implies TCT_g(var) = (v)\\
& \mbox{Для создания потока в родительском потоке }t\mbox{ в } var \\
& \mbox{ та же переменная содержится в }TCT_g
\end{aligned}
\end{equation}
\end{enumerate}

%The Thread Analysis inherits the limitations of~\cite{ThreadModular03} and restricted to the programs with bounded thread creation. We suppose that the program has finite number of threads identified by the locations where they are created, i.e $T\subseteq L$ and for $thread\_create(pc_\nu)$ we always create a thread with identifier $pc_\nu$. Note, that the other analyses are not bounded.

{\textbf 1.} Абстрактный домен $D_M$ основан на плоской решетке для переменных потока $X_t$: 
$D_M = (C, \mathcal{E}, \mathcal{I}, \epp)$, with $\mathcal{E}=(E_M, \top^E, \bot^E, \sqsubseteq^E, \sqcup^E)$, $E_M = X_t \times Paths \times Paths \{Alive, Dead\} \cup \{\bot^E,\top^E\}) $,
где $Paths$ -- это множество всех возможных последовательностей $\{label_n\}^{\infty}_1$ и $label_n \in X_t \times \{Child, Parent\}$

$e = (l, pSet, tSet, status)$. $l \in X_t$, $tSet, pSet \in Paths$, $status \in \{Alive, Dead\}$.
$\bot^E \sqsubseteq \{(v, \cdot)\} \sqsubseteq^E \top^E$ и $v \neq v'$ $\Rightarrow$ $v \not\sqsubseteq^E v'$ для всех элементов $v, v'\in X_t$ 
(откуда следует $\bot^E \sqcup^E \{(v, \cdot)\} = \{(v, \cdot)\}$, $\top^E \sqcup \{(v, \cdot)\} = \top^E$, $\{(v, \cdot)\} \sqcup^E \{(v', \cdot)\} = \top^E$ для всех элементов $v,v'\in X_t$, $v\neq v'$)

\begin{itemize}
\item $\forall e_1, \dots, e_m \in E$ обозначим
\begin{equation}
\label{tct}
\begin{aligned}
& TCT(\{e_1, \dots, e_m\}) = \\
& \left\lbrace (v_j, v_i) \left|
\begin{array}{c}
\exists a > 0, 1 \le x \le m, 1 \le b \le m - a: \\
(v_i, Child) = label_a \in tSet_x \land \\
(v_j, \cdot) = label_{a+b} \in tSet_x \land \\
\forall 1 \le c < b: status_{a+c} \neq Child
\end{array}
\right.
\right\rbrace
\end{aligned}
\end{equation}

\item $\forall e_1, \dots, e_m \in E:$
\begin{equation}
\label{compatible_E_thread_M}
\begin{aligned}
& compatible_{E}(\{e_1, \dots, e_m\}) = \\
& \forall (v_i, v_j) \in TCT(\{e_1, \dots, e_m\}): \\
& (v_i, v_k) \in TCT(\{e_1, \dots, e_m\}) \implies v_k = v_j \land \\
& \forall i \neq j: compatible_{TM}(e_i, e_j) \land \\
& \forall 1 \le i \le m: status_i = Dead \implies pSet_i = tSet_i \land \\
& \forall 1 \le i \le m: (l_i, Child) \in pSet_i \land \\
& \forall 1 \le i \le m, 0 \le x \le \infty, y > x: \\
& (l_i, Child) = label_x \in tSet_i \implies \\
& \forall label_y = (v_y, status_y) \in tSet_i \land status_y = Parent
\end{aligned}
\end{equation}

Определение означает, что дерево создания потоков (ДСП) является одинаковым для каждого состояния, то есть, существует общий префикс и только один поток, в котором путь создания потоков разветвляется на два, а все остальные потоки, которые возникают после раветвления, являются уникальными.

\item $\forall e_1, \dots, e_m \in E, \forall t_1, \dots, t_m \in T:$
\begin{equation}
\label{epp_thread_M}
\begin{aligned}
& \epp_{M}
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix} = \\
& = \begin{cases}
& \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, pSet_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \mathbb{N} \\
\forall i, j \in \overline{1..m}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = \{ t_j \mapsto t_i \mid (l_j, l_i) \in TCT(\{e_1, \dots, e_m\}) \\
\end{array}
\right.
\right\rbrace, \\
& \mbox{if } compatible_{E}(e_1, \dots, e_m), t_i \neq t_j \\
& \emptyset \mbox{ else}
\end{cases}
\end{aligned}
\end{equation}

\item $\mathcal{I}=\mathcal{E}$. 
\end{itemize}

{\textbf 2.} Множество точности содержит только один пустой элемент.

{\textbf 3.} Отношение переходов $\tatarrow_F$ содержит переход $e \tat{\tau, g}_F (e', \pi)$, $g=(\cdot,op,\cdot)$, $e = (l, pSet, tSet, rSet, status), e' = (l', pSet', tSet', rSet', status')$ и $e \tat{\tau}_F (i, \pi)$, если $status = Alive$ и $i = e$ и если
\begin{itemize}
\item $op \neq tc_{parent}$, $op \neq tc_{child}$, $op \neq thread\_exit$ и $op \neq thread\_join$, $e' = e$.
\item $op=tc_{child}(var, l_\nu)$, $l' = var$. $tSet' = tSet \cup (var, Child)$, $pSet' = tSet'$ .
\item $op=tc_{parent}(var, l_\nu)$, $l' = l$. $tSet' = tSet \cup (var, Parent)$, $pSet' = pSet$.
\item $op=thread\_exit$, $l' = l$, $tSet = pSet$, $tSet' = tSet$, $status' = \{Dead\}$.
\item $op=thread\_join(var)$, $e' = e \setminus (var, Parent)$ -- это и есть абстракция: анализ не знает, завершен ли соответствующий поток или нет. Поэтому переход всегда выполняется.
\end{itemize}

Покажем, что требование ~\ref{transfer_tm_ir_stronger_for_inner} выполнено.

Рассмотрм случайное состояние $c_0 \in C: \exists m \in \mathbb{N}, e_1, \dots, e_m \in E_M, t_1, \dots, t_m \in T: c_0 \in \epp_M
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$
и случайный переход $c_0 \tc{g,t} c'$.

Так как $c_0 \in \epp_M
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$ и $c_0 \tc{t} c'$, поэтому $t \in dom(c_0)$, откуда следует $\exists k: t_k = t$. 
Зафиксируем это значение $k$, тогда $\tau$-переход выполняется из соответствующего $e_k$.
В соответствии с определением $\epp$~\ref{epp_thread_M}, зафиксируем подмножество $\widehat{\mathbb{N}} \subseteq \mathbb{N}$, такое что $\widehat{\mathbb{N}}=\{num \mid (\cdot, num) \in c^0_l\}$

По определению отношения переходов 3 имеется $e_k \tat{\tau} i_q=e_k$, $\forall q: 1 \le q \le m$. Возьмем $i_q=e_k$.

Замети, что по определению~\ref{epp_thread_M} $\forall q: 1 \le q \le m \land q \neq k: compatible(e_q, e_k)$ и определению отношения переходов 3 следует $e_q \tat{i_q} e_q$. 
Поэтому переход по эффекту окружения может быть применен, но он не изменит состояния.
Возьмем $\forall q: 1 \le q \le m \land q \neq k:$ $e_q' = e_q$ .

Пусть $c_0 = (c_{pc}^0, c_l^0, c_g^0, c_s^0, c^0_t, c^0_m)$, $c' = (c_{pc}', c_l', c_g', c_s', c_t', c_m')$, $e_k=(l_k, pSet_k, tSet_k, status_k)$, $e_k'=(l_k', pSet_k', tSet_k', status_k')$.
Обозначим $TCT(e_1, \dots, e_k, \dots, e_m) = TCT_0$;

{\textit 1)} Рассмотрим случай $g \neq thread\_create$, $g \neq thread\_join$, $g \neq thread\_exit$.

В этом случае по определению отношения переходов 3 $e_k' = e_k$. Поэтому нам нужно показать, что
$c' \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$.

По определению операций $g \neq thread\_create$, $g \neq thread\_join$, $g \neq thread\_exit$ получаем $c_t = c_t'$, $dom(c) = dom(c')$. Отсюда следует $c' \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$, так как $\epp_M$ не зависит от других частей состояний.

{\textit 2)} Рассмотрим случай $g = thread\_exit$. Нам нужно показать 
\begin{align}
& \exists k : 1 \le k \le m \land t_k = t \nonumber \\
& \exists e_1', \dots, e_m' \in E: \nonumber \\
& c' \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m' \\
t_m 
\end{pmatrix}
\end{pmatrix} \nonumber \\
& \mbox{ where } e_1', \dots, e_m' \mbox{ such that } \nonumber \\
&\exists i_1, \dots, i_{k-1}, i_{k+1}, \dots, i_m: \nonumber \\
&
\begin{cases}
\forall q \neq k, q \neq r: e_q \tat{i_q} e_q' \land i_q \in \{i \mid e_k \tat{\tau} i\} \\
e_k \tat{\tau} e_k'
\end{cases} \nonumber 
\end{align}

В этом случае по определению отношения переходов 3 $l_k'=l_k$, $tSet_k'=pSet_k$, $status_k'=Dead$ , то есть $e_k' = (l_k, pSet_k, tSet_k, Dead)$.

По определению $thread\_exit$ получаем $c_t = c_t'$, $dom(c') = (dom(c) \setminus \{t\})$.
По предположению анализа~\ref{main_assumption_1} $(\cdot, t) \notin c_m$, $c_m = c_m'$.

\begin{align}
& \epp_M
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_k' \\
t_k 
\end{pmatrix},
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix} = (def.~\ref{epp_thread_M}) =\nonumber \\
& = \begin{cases}
& \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, pSet_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \mathbb{N} \\
\forall i, j \in \overline{1..m}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = \{ t_j \mapsto t_i \mid (l_j, l_i) \in TCT(\{e_1, \dots, e_m\}) \\
\end{array}
\right.
\right\rbrace, \\
& \mbox{if } compatible_{E}(\{e_1, \dots, e_k', \dots, e_m), t_i \in T, t_i \neq t_j \\
& \emptyset \mbox{ else}
\end{cases} = \nonumber
\end{align}

Заметим, что $\forall i: 1 \le i \le m, i \neq k: tSet_i' = tSet_i$ и $tSet_k' = pSet_k$.
По предположению~\ref{main_assumption_1} $(\cdot, t) \notin c_m$, $c_m = c_m'$.
По определению $\epp$~\ref{epp_thread_M} это означает $(\cdot, l_k) \notin TCT(\{e_1, \dots, e_m\})$.
По определению $TCT$~\ref{tct} $\forall 1 \le x \le m, 0 \le a \le \infty: (\cdot, \cdot) = label_a \in tSet_x \land (l_k, Child) = label_b \in tSet_x \implies a > b$.
Поэтому это также верно для $x = k$, это означает, что $tSet$ не содержит никакую пару $(\cdot, \cdot)$ после $(l_k, Child)$.
Итак, мы показали, что $tSet_k$ не содержит никакую метку после $(l_k, Child)$, что означает
$tSet_k = pSet_k$ и $tSet_k = tSet_k'$. 
Это означает $\forall i: 1 \le i \le m: tSet_i' = tSet_i$.
$TCT$ зависит только от $tSet$ части состояния, поэтому $TCT' = TCT_0$.
Единственное условие совместности состояний, которое поменялось, это $\forall 1 \le i \le m: status_i = Dead \implies pSet_i = tSet_i$.
Так как мы только что доказали, что $pSet_k = tSet_k$ и другие состояния не изменилися, поэтому $compatible_E(e_1, \dots, e_k, \dots, e_m) = true$.

\begin{align}
& = \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \mathbb{N} \\
\forall i, j \in \overline{1..m}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = \{ t_j \mapsto t_i \mid (l_j, l_i) \in TCT(\{e_1, \dots, e_m\}) \\
\end{array}
\right.
\right\rbrace \supseteq \nonumber
\end{align}
Выберем только одно подмножество $\mathbb{N} = \widehat{\mathbb{N}}$.
\begin{align}
& \supseteq \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \widehat{\mathbb{N}} \\
\forall i, j \in \overline{1..m}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = \{ t_j \mapsto t_i \mid (l_j, l_i) \in TCT(\{e_1, \dots, e_m\}) \\
\end{array}
\right.
\right\rbrace = \nonumber
\end{align}

Заметим, что $TCT(\{e_1, \dots, e_k', \dots, e_m\}) = TCT(\{e_1, \dots, e_k, \dots, e_m\})$, откуда следует $\forall t_i: c_m(t_i) = c^0_m(t_i)$.

\begin{align}
& = \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \widehat{\mathbb{N}} \\
\forall i, j \in \overline{1..m}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = c^0_m \\
\end{array}
\right.
\right\rbrace = \nonumber
\end{align}

Заметим, что $c_0 \in \epp_M
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$.

Обозначим $dom_M\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix} = \{t \mid t = t_i \land e_i=(\cdot, \cdot, status_i) \land status_i = Alive \land i \in \overline{1..m}\}$.

Используя определение $\epp_M$~\ref{epp_thread_M} 
для $e_1, \dots, e_m$, получаем
$dom(c_0) = dom_M\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix} = \mathbb{T}$.
Для нового перехода $e_k \tatarrow e_k'$ получаем $dom_M\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_k' \\
t_k 
\end{pmatrix} ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix} = (status_k' = Dead) = dom_M\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix} \setminus \{t_k\} = \mathbb{T} \setminus \{t_k\}$
\begin{align}
& = \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, tSet_i, status_i) \\
dom(c) = \mathbb{T} \setminus \{t_k\} \\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \widehat{\mathbb{N}} \\
\forall i, j \in \overline{1..m}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = c^0_m \\
\end{array}
\right.
\right\rbrace = \tilde{C} \nonumber
\end{align}

Заметим, что $c'$ отличается от $c_0$ только $dom(c') = dom(c_0) \setminus \{t_k\}$.
Мы можем сказать, что

$c' \in \{c \mid dom(c) = dom(c_0) \setminus \{t_k\} \land c_t = c^0_{t} \land c_m = c^0_m\} = \tilde{C}$

Это означает $c' \in \epp_M
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_k' \\
t_k 
\end{pmatrix},
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$.

{\textit 3)} Рассмотрим случай $g = thread\_create(var, num, l_\nu)$, теперь нужно показать, что

\begin{align}
& \exists k : 1 \le k \le m \land t_k = t \nonumber \\
& \exists e_1', \dots, e_{m+1}' \in E: \nonumber \\
& c' \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_{m+1}' \\
t_{m+1} 
\end{pmatrix}
\end{pmatrix} \nonumber \\
& \mbox{ where } e_1' \dots e_{m+1}' \mbox{ such that } \nonumber \\
&\exists i_1, \dots, i_{k-1}, i_{k+1}, \dots, i_m: \nonumber \\
&
\begin{cases}
\forall q \neq k: e_q \tat{i_q} e_q' \land i_q \in \{i \mid e_k \tat{\tau} i\} \\
e_k \tat{\tau, tc_{parent}} e_k' \\
e_k \tat{\tau, tc_{child}} e_{m+1}'
\end{cases} \nonumber 
\end{align}

По определению $thread\_create$ 
$dom(c') = dom(c_0) \cup \{\nu\}$, $c_t' = c^0_t \cup \{(var, num) \mapsto \nu\}$, $c_m'(t) = c_m(t) \cup \{\nu\}$ и
$\forall q: 1\le q\le m: \nu \ne t_q$.
По основному предположению~\ref{main_assumption_2} 
$\forall n: c_t(var, n) \notin T$.
Пусть $t_{m+1} = \nu$ и обозначим $e_k' = (l_k', pSet_k', tSet_k', status_k')$, а $e_{m+1}' = (l_{m+1}', pSet_{m+1}', tSet_{m+1}', status_{m+1}')$.

В соответсвтии с определением переходов 3, %tc_child, tc_parent
$l_k' = l_k$ и $l_{m+1}' = var$. Поэтому
\begin{align}
& \epp_M
\begin{pmatrix}
\begin{pmatrix}
e_1' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_{m+1}' \\
\nu 
\end{pmatrix}
\end{pmatrix} = (def.~\ref{epp_thread_M}) = \nonumber \\
& = \begin{cases}
& \left\lbrace (c_{pc},c_l,c_g,c_s,c_t, c_m) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, pSet_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \mathbb{N} \\
\forall i, j \in \overline{1..m+1}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = \{ t_j \mapsto t_i \mid (l_j, l_i) \in TCT(\{e_1, \dots, e_k', \dots, e_{m+1}'\}) \\
\end{array}
\right.
\right\rbrace, \\
& \mbox{if } \forall i \neq j: compatible_{E}(\{e_1, \dots, e_k', \dots, e_{m+1}'\}), t_i \in T, t_i \neq t_j \\
& \emptyset \mbox{ else}
\end{cases} = \nonumber
\end{align}

Покажем, что $compatible_E(e_1, \dots, e_k', \dots, e_{m+1}')$.
Обозначим $e_k' = (l_k', pSet_k', tSet_k', status_k')$, $e_{m+1}' = (l_{m+1}', pSet_{m+1}', tSet_{m+1}', status_{m+1}')$.
$tSet_k' = tSet_k \cup (var, Parent)$, $tSet_{m+1}' = tSet \cup (var, Child)$.
$TCT' = TCT(\{e_1, \dots, e_k', \dots, e_{m+1}'\}) = TCT_0 \cup {(var, l_k)}$. 
Чтобы проверить $compatible_E(e_1, \dots, e_k', \dots, e_{m+1}')$, нам нужно показать три основные части:
\begin{enumerate}
\item $\forall (v_i, v_j) \in TCT(\{e_1, \dots, e_k', \dots, e_{m+1}'\}): (v_i, v_k) \in TCT(\{e_1, \dots, e_k', \dots, e_{m+1}'\}) \implies l_k = l_j$
Так как $TCT' = TCT_0 \cup {(var, l_k)}$ нам нужно проверить, есть ли другая пара $(var, \cdot)$.
Предствим, что условие нарушено и $\exists 1 \le f \le m: (var, l_f) \in TCT_0$.
Это означает, что $\exists n_v, n_f \in \mathbb{N}: c^0_m(var, n_v) = t_f \land t_f = c_t(l_f, n_f) \land TCT_g(var, l_f)$.
Теперь попытаемся выполнить переход$c_0 \tat{t, g} c'$, $g = thread\_create(var, num, l_{\nu})$ и $t \neq l_f$. 
%??????
% how follows
Этот случай противоречит основному предположению~\ref{main_assumption_4}.
Поэтому $(var, \cdot) \notin TCT_0$ и условие выполнено.
\item $\forall i \neq j: compatible_{TM}(e_i, e_j)$
Так как $\forall 1 \le i \le m, i \neq k: tSet_i' = tSet_i$ нам нужно только проверить $i = k$ и $i = m +1$.
\begin{itemize}
\item Рассмотрим $e_j:j \neq k \land j \neq m + 1$ и $e_k'$. 
$tSet_k' = tSet_k \cup (var, Parent)$. Рассмотрим случайное множество $tSet_j$. Так как известно, что $compatible(e_j, e_k)$, это означает, что 
\begin{align}
& \exists 0 \le p_1, p_2 \le \infty: var^k_{p_1} = var^j_{p_2} \land status^k_{p_1} \neq status^j_{p_2} \nonumber
\end{align}
Теперь представим, что $compatible(e_k', e_j) = false$. Так как множество $tSet_k'$ только шире, это означает, что существует такие же $p_1, p_2: var^{k'}_{p_1} = var^j_{p_2} \land status^{k'}_{p_1} \neq status^j_{p_2}$.
\item Рассмотрим $e_j:j \neq k \land j \neq m + 1$ и $e_{m+1}'$. Этот случай такой же, как и предыдущий.
\item Рассмотрим $e_k'$ и $e_{m+1}'$.
$\exists(var, Parent) \in tSet_k' \land (var, Child) \in tSet_{m+1}'$. Эта пара удовлетворяет условию на $compatible$, что означает$compatible_M(e_k, e_{m+1}')$
\end{itemize}
Так, мы показали, что все новые состояния $e_i'$ и $e_j'$ являются совместными.
\item $\forall 1 \le i \le m+1: status_i = Dead \implies pSet_i = tSet_i$.
Заметим, что $\forall 1 \le i \le m: status_i' = status_i$ и $status_{m+1}' = Alive$.
Если предыдущие состояния были совместны, тогда следующие состояния также удовлетворяют этому условию.
\item $\forall 1 \le i \le m+1: (l_i, Child) \in pSet_i$.
Заметим, что $\forall 1 \le i \le m: pSet_k' = pSet_k$. Ничего не изменилось
$pSet_{m+1} = tSet_{m+1}' = tSet_k \cup \{(var, Child)\}$ и $l_{m+1} = var$. Поэтому условие выполнено.
\item $\forall 1 \le i \le m, 0 \le x \le \infty, y > x: (l_i, Child) = label_x \in tSet_i \implies \forall label_y = (v_y, status_y) \in tSet_i \land status_y = Parent$.
Заметим, что $\forall 1 \le i \le m, i \neq k: tSet_i' = tSet_i$. Ничего не изменилось.
$tSet_k' = tSet_k \cup \{(var, Parent)\}$. Условие все еще вероне, так как мы не добавили метку $Child$.
$tSet_{m+1}' = tSet_k \cup \{(var, Child)\}$. Условие верное, так как после метки $Child$ нет ни одной метки.
\end{enumerate}

\begin{align}
& = \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \mathbb{N} \\
\forall i, j \in \overline{1..m+1}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = \{ t_j \mapsto t_i \mid (l_j, l_i) \in TCT(\{e_1, \dots, e_k', \dots, e_{m+1}'\}) \\
\end{array}
\right.
\right\rbrace \supseteq \nonumber
\end{align}

Выберем $\tilde{\mathbb{N}} = \widehat{\mathbb{N}} \cup \{num\}$.

\begin{align}
& \supseteq \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \tilde{\mathbb{N}} \\
\forall i, j \in \overline{1..m+1}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = \{ t_j \mapsto t_i \mid (l_j, l_i) \in TCT(\{e_1, \dots, e_k', \dots, e_{m+1}'\}) \\
\end{array}
\right.
\right\rbrace = \nonumber
\end{align}

Заметим, что $TCT' = TCT(\{e_1, \dots, e_k', \dots, e_{m+1}'\}) = TCT_0 \cup {(var, l_k)}$. Откуда следует $c_m'(\nu) = c_m(t_k)$.

\begin{align}
& = \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \tilde{\mathbb{N}} \\
\forall i, j \in \overline{1..m+1}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m(t_i) = \begin{cases}
c^0_m(t_i)&, \mbox{ if } i \neq m+1 \\
t&, \mbox{ if } i = m+1 \\
\end{cases}
\end{array}
\right.
\right\rbrace = \nonumber
\end{align}

Используя определение $\epp_M$~\ref{epp_thread_M}
для $e_1, \dots, e_m$ получаем
$dom(c_0) = dom_M\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix} = \mathbb{T}$.
Для нового перехода $e_k \tatarrow e_k'$ и $e_k \tatarrow e_{m+1}'$ получаем $dom_M\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_k' \\
t_k 
\end{pmatrix} ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix},
\begin{pmatrix}
e_{m+1}' \\
\nu 
\end{pmatrix}
\end{pmatrix} = (status_{m+1}' = Alive) = dom_M\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix} \cup \{\nu\} = \mathbb{T} \cup \{\nu\}$

\begin{align}
& = \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, tSet_i, status_i) \\
dom(c) = \mathbb{T} \cup \{\nu\}\\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \tilde{\mathbb{N}} \\
\forall i, j \in \overline{1..m+1}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m(t_i) = \begin{cases}
c^0_m(t_i)&, \mbox{ if } i \neq m+1 \\
t&, \mbox{ if } i = m+1 \\
\end{cases}
\end{array}
\right.
\right\rbrace = \tilde{C} \nonumber 
\end{align}.

Заметим, что $c'$ отличается от $c_0$ только $dom(c') = dom(c_0) \cup \{\nu\}$, $c_t' = c^0_t \cup \{(var, num) \mapsto \nu\}$ и $c_m'(t_k) = c^0_m(t_k) \cup \{\nu\}$.
Можно сказать, что

$c' \in \{c \in C \mid dom(c) = dom(c_0)  \cup \{\nu\} \land c_t' = c^0_t \cup \{(var, num) \mapsto \nu\} \land c_m' = c^0_m \cup \{\nu \mapsto t_k\} \} = \tilde{C}$

Это означает $c' \in \epp_M
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_k' \\
t_k 
\end{pmatrix},
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix},
\begin{pmatrix}
e_{m+1} \\
\nu 
\end{pmatrix}
\end{pmatrix}$.

{\textit 4)} Рассмотрим случай $g = thread\_join(var, num)$, теперь нужно показать, что

\begin{align}
& \exists k : 1 \le k \le m \land t_k = t \nonumber \\
& \exists r \in \overline{1..m}: \exists e_1', \dots, e_m' \in E: \nonumber \\
& c' \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_{r-1}' \\
t_{r-1} 
\end{pmatrix} ,
\begin{pmatrix}
e_{r+1}' \\
t_{r+1} 
\end{pmatrix},
\dots& ,
\begin{pmatrix}
e_m' \\
t_m 
\end{pmatrix}
\end{pmatrix} \nonumber \\
& \mbox{ where } e_1', \dots, e_{r-1}, e_{r+1}, \dots, e_m' \mbox{ such that } \nonumber \\
&\exists i_1, \dots, i_{k-1}, i_{k+1}, \dots, i_m: \nonumber \\
&
\begin{cases}
\forall q \neq k, q \neq r: e_q \tat{i_q} e_q' \land i_q \in \{i \mid e_k \tat{\tau} i\} \\
e_k \tat{\tau} e_k'
\end{cases} \nonumber 
\end{align}

По определению $thread\_join$
$\exists t: t = c_t(var, num) \land t \notin dom(c)$, $c_t' = c^0_t \setminus \{(var, num) \mapsto t\}$, $c_m' = c^0_m \setminus (t, \cdot)$.
По определению отношения переходов $transfer$~3
$e_k' = (l_k', pSet_k', tSet_k', Active)$, $tSet_k' = tSet_k \setminus \{(var, Parent)\}$, $pSet_k' = pSet_k$.

Так как $\exists t: t \notin dom(c) \land c_t(var, num) = t \land c \in \epp_M
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$, 
, это означает $\exists r: t_r = t \land e_r = (l_r, pSet_r, tSet_r, Exit)$ (определение $\epp$~\ref{epp_thread_M}).

Заметим, что $r \neq k$, потому что ни одна операция не может быть выполнена после $thread\_join$.

Сейчас нужно показать, что
$c' \in \epp_M
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}&,
\dots& ,
\begin{pmatrix}
e_{r-1} \\
t_{r-1} 
\end{pmatrix},
\begin{pmatrix}
e_{r+1} \\
t_{r+1} 
\end{pmatrix},
\dots& ,
\begin{pmatrix}
e_k' \\
t_k 
\end{pmatrix} ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}
$

\begin{align}
& \epp_M
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}&,
\dots&,
\begin{pmatrix}
e_{r-1} \\
t_{r-1} 
\end{pmatrix},
\begin{pmatrix}
e_{r+1} \\
t_{r+1} 
\end{pmatrix},
\dots& ,
\begin{pmatrix}
e_k' \\
t_k 
\end{pmatrix} ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix} = (def.~\ref{epp_thread_M}) = \nonumber \\
& = \begin{cases}
& \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, pSet_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \mathbb{N} \\
\forall i, j \in \overline{1..m}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = \{ t_j \mapsto t_i \mid (l_j, l_i) \in TCT(\{e_1, \dots, e_{r-1}, e_{r+1}, \dots, e_k', \dots, e_m\}) \\
\end{array}
\right.
\right\rbrace, \\
& \mbox{if } \forall i \neq j: compatible_{E}(\{e_1, \dots, e_{r-1}, e_{r+1}, \dots, e_k', \dots, e_m\}), t_i \in T, t_i \neq t_j \\
& \emptyset \mbox{ else}
\end{cases} = \nonumber
\end{align}

Покажем, что новые состояний все еще совместны.
В соответствии с основным предположением~\ref{main_assumption_1} $\forall t_c \in T: c^0_m(t_c) \neq t_r$.
Нам нужно проверить только

\begin{enumerate}
\item $\forall (v_i, v_j) \in TCT(\{e_1, \dots, e_{r-1}, e_{r+1}, \dots, e_m\}): (v_i, v_k) \in TCT(\{e_1, \dots, e_{r-1}, e_{r+1}, \dots, e_m\}) \implies v_k = v_j$.
Удаление одного состояния $e_r$ и одной метки $(l_r, Parent)$ из состояния $e_k$ может только удалить дуги и не может изменить существующие направления. Поэтому глобальная структура графа не может измениться.
\item $\forall i \neq j: compatible_{TM}(e_i, e_j)$.
По определению $\epp$~\ref{epp_thread_M} $(l_r, l_k) \in TCT_0$.
По определению TCT~\ref{tct} $\forall 1 \le x \le m: (l_r, \cdot) \in tSet_x \implies (l_k, Child) \in tSet_x$.
По определению $compatible_E$~\ref{compatible_E_thread_M} $status_r = Dead \implies pSet_r = tSet_r$.
По определению $compatible_E$~\ref{compatible_E_thread_M} $(l_r, Child) \in pSet_r = tSet_r$.
Так как $(l_r, l_k) \in TCT_0$, $tSet_r = \{\dots, (l_k, Child), (\cdot, Parent), \dots, (\cdot, Parent), (l_r, Child)\}$.
По определению $compatible_E$~\ref{compatible_E_thread_M} $tSet_k = \{\dots, (l_k, Child), (\cdot, Parent), \dots, (\cdot, Parent)\}$.
Заметим, что части последовательностей $tSet_r$ и $tSet_k$ до $(l_k, Child)$ должны быть одинаковы, иначе $TCT$ будет отличаться.
По определению $compatible_E$~\ref{compatible_E_thread_M} $compatible_{TM}(e_k, e_r)$.
Единственная возможность, чтобы быть совместными -- это $(l_r, Parent) \in tSet_k$, $l_r = var$.
Сейчас нужно показать, что после удаления $(l_r, Parent)$ из $tSet_k$ другие состояния остаются совместными.
Представим, что $\exists s \neq r: compatible(e_s, e_k) \land (compatible(e_s, e_k') = false)$. 
Это означает, что $(var, Child) \in tSet_s$. Так как $s \neq r$, $l_s \neq l_r$~\ref{main_assumption_4}.
%!!!!!!!!!!!!!!!!!

По определению $compatible_E$~\ref{compatible_E_thread_M}, $(l_s, Child) \in tSet_s$.
Более того, соответствующая метка $(l_s, Child)$ должна быть последней меткой в последовательности $tSet_s$.
$tSet_s = \{\dots, (l_r, Child), \dots, (l_s, Child)\}, (\cdot, Parent), \dots\}$.
Заметим, что части до $(l_r, Child)$ должны быть равны для обоих $tSet_r$ и $tSet_s$, иначе TCT разрушится.
Это означает, что $compatible_E(e_s, e_r) = false$.
И $\forall s: compatible(e_s, e_k) \land compatible(e_s, e_k')$
\item $\forall 1 \le i \le m: status_i = Dead \implies pSet_i = tSet_i$.
Так как статусы не менялись, условие выполнено.
\item $\forall 1 \le i \le m: (l_i, Child) \in pSet_i$.
Так как $\forall 1 \le i \le m: pSet_i' = pSet_i$ соответствующее условие выполнено.
\item $\forall 1 \le i \le m, 0 \le x \le \infty, y > x: (l_i, Child) = label_x \in tSet_i \implies  \forall label_y = (v_y, status_y) \in tSet_i \land status_y = Parent$.
Так как $\forall 1 \le i \le m, i \neq k, i \neq r: tSet_i' = tSet_i$ соответствующее условие выполнено.
$tSet_k' = tSet_k \setminus \{(l_r, Parent)\}$. Метки$(\cdot, Child)$ не изменились, поэтому условие выполено.
\end{enumerate}

\begin{align}
& = \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
\exists \mathbb{M} \subseteq \overline{1..m}: \\
c_t = \{(l_i, num_i) \mapsto t_i\} \land i \in \mathbb{M} \\
num_i \in \mathbb{N}, e_i = (l_i, \cdot), i \in \mathbb{M} \\
\forall i, j \in \mathbb{M}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = \{t_i \mapsto W_i \mid W_i = \{t_j \mid (l_j, \cdot) \in tSet_i \setminus pSet_i \}\} \\
\end{array}
\right.
\right\rbrace \supseteq \nonumber
\end{align}

Выберем $\tilde{\mathbb{M}} = \widehat{\mathbb{M}} \setminus \{r\}$.

\begin{align}
& \supseteq \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
c_t = \{(l_i, num_i) \mapsto t_i\} \land i \in \tilde{\mathbb{M}} \\
num_i \in \mathbb{N}, e_i = (l_i, \cdot), i \in \tilde{\mathbb{M}} \\
\forall i, j \in \widehat{\mathbb{M}}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = \{t_i \mapsto W_i \mid W_i = \{t_j \mid (l_j, \cdot) \in tSet_i \setminus pSet_i \}\} \\
\end{array}
\right.
\right\rbrace = \tilde{C} \nonumber
\end{align}

$c'$ отличается от $c_0$ только удалением $(var, num)$ из $c_t$. 
Можно сказать, что

$c' \in \{c \in C \mid dom(c) = dom(c_0)  \cup \{\nu\} \land c_t' = c^0_t \setminus \{(var, num) \mapsto t_r\} \} = \tilde{C}$

Это означает $c' \in \epp_M
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_k' \\
t_k 
\end{pmatrix},
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$.

%We have the transfer $\top \tat{\tau, g}_T (\top, \pi)$ for all $g\in G$.

%$\forall t,i \in E_T: compatible^E(t,i) \implies t \tat{i, g}_T (t, \pi)$, because 
%\begin{itemize}
%\item inference object guards the transfer by checking inequality of thread identifiers in compatible,
%\item states are {\em invariant to environment}, i.e. no thread can change an identifier of the other thread.
%\end{itemize}

{\textbf 4.} Оператор слияния состояний не объединяет элементы: $merge^E_T(e, e', \pi) = e'$. Как уже было показано ранее, такой оператор слияния удовлетворяет условию~\ref{cpa_merge_tm_e_eq}.

{\textbf 5.} Оператор останова для состояний рассматривает абстрактные состояния по одному: $stop^E_T(e, R, \pi) = (e \in R)$. Как уже было показано ранее, такой оператор останова удовлетворяет условию~\ref{cpa_stop_tm_e_eq}.

{\textbf 6.} Состояния и точностть никогда не изменяются: $prec^E_T(e, \pi, R) = (e, \pi)$. Как уже было показано ранее, такой оператор удовлетворяет условию~\ref{prec_tm_e_equation}.

{\textbf 7.} 
\begin{equation}
\label{compatible_thread}
\begin{aligned}
& e = (l^e, tSet^e, status^e), i = (l^i, tSet^i, status^i), \\
& compatible_T(e,i) = \exists (var, \cdot): \\
& (var, s_e) \in tSet_e \land  (var, s_i) \in tSet_i \land s_e \neq s_i \land \\
& (var, s_e') \in tSet_e \implies s_e = s_e' \land \\
& (var, s_i') \in tSet_i \implies s_i = s_i'
\end{aligned}
\end{equation}

\section{Метод поиска состояния гонки}

Метод поиска состояний гонки содержит в себе комбинацию рассмотренных выше анализов: анализ точек программы $\mathcal{L}$, анализ потоков $\mathbb{M}$, анализ примитивов синхронизации $\mathbb{S}$ и анализ предикатов $\mathbb{P}$. 
Все эти анализы объединяются с помощью композитного анализа $\mathbb{C}$.
Операторы каждого из этих видов анализа удовлетворяют условиям~\ref{cpa_transfer_eq},~\ref{cpa_merge_tm_e_eq},~\ref{cpa_merge_tm_i_eq},~\ref{cpa_merge_tm_e_eq},~\ref{cpa_merge_tm_i_eq},~\ref{prec_tm_e_equation},~\ref{prec_tm_i_equation}, а значит, позволяют утверждать по теореме~\ref{thrm_soundness}, что множество вычесленных абстрактных состояний аппроксимирует свержу множество конкретных состояний программы.
Таким образом, если в числе абстрактных состояний программы присутствует ошибочное, значит, программа не соответствует поставленной спецификации.

Покажем, что для программы, содержащей состояний гонки в смысле определения~\ref{raceDef}, будет найдено состояние гонки.
Пусть у нас есть множество достижимых состояний $R: \exists c, c_1, c_2 \in \conc{R} \subseteq C, g_1, g_2 \in G, \widehat{t}, \overline{t} \in T, \widehat{t} \neq \overline{t}: c \tcarrow{g_1, \widehat{t}} c_1, c \tcarrow{g_2, \overline{t}} c_2$, то есть присустствует состояние гонки.
По требованию~\ref{transfer_tm_ir_stronger} 
\begin{align}
\exists e_1,\dots,e_m,e_1', \dots, e_m', e_1'',\dots,e_m'' \in R, \nonumber \\
t_1, \dots, t_n \in T, k, l \in \mathbb{N}: t_k = \widehat{t}, t_l = \overline{t} \nonumber \\
c \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1^1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_k \\
t_k 
\end{pmatrix},
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}, \nonumber \\
e_k \tat{\tau, g_1} e_k', e_k \tat{\tau} i', e_j \tat{i'} e_j', j \neq k, \nonumber \\
e_l \tat{\tau, g_2} e_l'', e_l \tat{\tau} i'', e_j \tat{i''} e_j'', j \neq l, \nonumber \\
c_1 \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_k' \\
t_k 
\end{pmatrix},
\dots& ,
\begin{pmatrix}
e_m' \\
t_m 
\end{pmatrix}
\end{pmatrix},\nonumber \\
c_2 \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1'' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_l'' \\
t_l 
\end{pmatrix},
\dots& ,
\begin{pmatrix}
e_m'' \\
t_m 
\end{pmatrix}
\end{pmatrix} \nonumber
\end{align}

Таким образом, необходимым условием состояния гонки в программе, являются четыре состояния $e_k, e_k', e_l, e_l'' \in R: e_k \tat{\tau, g_1} e_k', e_l \tat{\tau, g_2} e_l''$. 
При этом такие состояния должны быть совместнымы по требованию оператора $\epp$, а операции $g_1, g_2$ теми же, что и в определении состояния гонки~\ref{raceDef}: доступ к одной области памяти, и хотя бы одна операция записи.

Можно упростить это условие еще сильнее, так как на самом деле состояния $e_k', e_l''$ также не важны для определения состояния гонки, важен лишь сам факт наличия перехода.
Итак, можно сформулировать определение состояния гонки наабстрактных состояниях.

\begin{defn}
\label{raceDef_abstract}
Программа, для которой получено множество достижимых абстрактных состояний $R$, содержит \textbf{состояние гонки}, если $\exists e_1, e_2 \in R$, $g_1, g_2 \in G: e_1 \tat{\tau, g_1} \cdot \land e_2 \tc{\tau, g_2} \cdot$ и операции $g_1, g_2$ выполняются над одной и той же глобальной переменной $x \in X^{global}$ и хотя бы одна операция является присваиванием (то есть $assign(x, expr)$).
\end{defn}


%\newpage
%============================================================================================================================
%\section{Длинное название параграфа, в котором мы узнаём как сделать две картинки с~общим номером и названием} \label{sect2_2}
%
%А это две картинки под общим номером и названием:
%\begin{figure}[ht]
%  \begin{minipage}[ht]{0.49\linewidth}\centering
%    \includegraphics[width=0.5\linewidth]{knuth1} \\ а)
%  \end{minipage}
%  \hfill
%  \begin{minipage}[ht]{0.49\linewidth}\centering
%    \includegraphics[width=0.5\linewidth]{knuth2} \\ б)
%  \end{minipage}
%  \caption{Очень длинная подпись к изображению, на котором представлены две фотографии Дональда Кнута}
%  \label{img:knuth}  
%\end{figure}
%
%Те~же~две картинки под~общим номером и~названием, но с автоматизированной нумерацией подрисунков:
%\begin{figure}[ht]
%    {\centering
%        \hfill
%        \subbottom[List-of-Figures entry][Первый подрисунок\label{img:knuth_2_1}]{%
%            \includegraphics[width=0.25\linewidth]{knuth1}}
%        \hfill
%        \subbottom[\label{img:knuth_2_2}]{%
%            \includegraphics[width=0.25\linewidth]{knuth2}}
%        \hfill
%        \subbottom[Третий подрисунок]{%
%            \includegraphics[width=0.3\linewidth]{example-image-c}}
%        \hfill
%    }
%    \legend{Подрисуночный текст, описывающий обозначения, например. Согласно
%    ГОСТ 2.105, пункт 4.3.1, располагается перед наименованием рисунка.}
%    \caption[Этот текст попадает в названия рисунков в списке рисунков]{Очень
%    длинная подпись к второму изображению, на котором представлены две
%    фотографии Дональда Кнута}
%    \label{img:knuth_2}
%\end{figure}
%
%\section{Традиции русского набора}
%
%\subsection{Пробелы}
%
%В~русском наборе принято:
%\begin{itemize}
%    \item единицы измерения, знак процента отделять пробелами от~числа: 10~кВт, 15~\% (согласно ГОСТ 8.417, раздел 8);
%    \item $\tg 20^\circ$, но: 20~${}^\circ$C (согласно ГОСТ 8.417, раздел 8);
%    \item знак номера, параграфа отделять от~числа: №~5, \S~8;
%    \item стандартные сокращения: т.\:е., и~т.\:д., и~т.\:п.;
%    \item неразрывные пробелы в~предложениях.
%\end{itemize}
%
%\subsection{Математические знаки и символы}
%
%Русская традиция начертания греческих букв и некоторых математических
%функций отличается от~западной. Это исправляется серией
%\verb|\renewcommand|.
%\begin{itemize}
%%Все \original... команды заранее, ради этого примера, определены в Dissertation\userstyles.tex
%    \item[До:] \( \originalepsilon \originalge \originalphi\),
%    \(\originalphi \originalleq \originalepsilon\),
%    \(\originalkappa \in \originalemptyset\),
%    \(\originaltan\),
%    \(\originalcot\),
%    \(\originalcsc\).
%    \item[После:] \( \epsilon \ge \phi\),
%    \(\phi \leq \epsilon\),
%    \(\kappa \in \emptyset\),
%    \(\tan\),
%    \(\cot\),
%    \(\csc\).
%\end{itemize}
%
%Кроме того, принято набирать греческие буквы вертикальными, что
%решается подключением пакета \verb|upgreek| (см. закомментированный
%блок в~\verb|userpackages.tex|) и~аналогичным переопределением в
%преамбуле (см.~закомментированный блок в \verb|userstyles.tex|). В
%этом шаблоне такие переопределения уже включены.
%
%Знаки математических операций принято переносить. Пример переноса
%в~формуле \eqref{eq:equation3}.

%\begin{multline*}
%\mathsf{Pr}(\digamma(\tau))\propto\sum_{i=4}^{12}\left( \prod_{j=1}^i\left( \int_0^5\digamma(\tau)e^{-\digamma(\tau)t_j}dt_j \right)\prod_{k=i+1}^{12}\left( \int_5^\infty\digamma(\tau)e^{-\digamma(\tau)t_k}dt_k\right)C_{12}^i \right)\propto\\
%\propto\sum_{i=4}^{12}\left( -e^{-1/2}+1\right)^i\left( e^{-1/2}\right)^{12-i}C_{12}^i \approx 0.7605,\quad \forall\tau\neq\overline{\tau}
%\end{multline*}
%
%
%%Большая фигурная скобка только справа
%\[\left.                                                          %ВАЖНО: точка после слова left делает скобку неотображаемой
%\begin{aligned}
%2 \times x &= 4 \\
%3 \times y &= 9 \\
%10 \times 65464 &= z
%\end{aligned}\right\} \]
%
