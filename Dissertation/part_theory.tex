\chapter{Теория}
\label{chapter_theory}

%Preliminary Definitions
%Theory
\section{Основные определения}
В этом разделе представлены основные определения параллельной программы и достижимых конкретных состояний в программе.

Будем рассматривать простой императивный язык программирования, в котором поддерживаются операторы присваивания (assignment), проверки условия (assumption), захват и освобождение примитивов синхронизации (acquire/release) и создание потоков (thread\_create)\footnote{Реализация основана на инструменте \cpachecker, который работает с программами на языке Си}.

Параллельная программа представляется автоматом потока управления (англ. Control Flow Automaton, CFA), который состоит из множества вершин $L$  и множества соединяющих их ребер $G$ .
Множество $L$ - это множество всех точек программы (англ. program location), множество $G \subseteq L \times Ops \times L$, где $Ops$ - это множество всех операций программы.
Так, отдельная дуга $g \in G, g = (l_1, op, l_2)$ моделирует операцию $op$, которая выполняется в программе, когда управление переходит из точки $l_1$ в точку $l_2$.
Операция создания нового потока создает новый поток с идентификатором из множества $T$ и новый поток начинает свое выполнение из некоторой точки программы из множества $L$.
Множество всех переменных программы, которые встречаются в операциях $assignment$ и $assumption$ обозначается как $X$.
Будем считать, что переменные принимают только значения лежащие в $\mathbb{Z}$.
Подмножество $X$, которое содержит все локальные переменные программы, обозначается как $X^{local}$, а подмножество, содержащее все глобальные переменные, -  $X^{global}$. 
%(to simplify presentation all threads have the same set of local variables) 
Операции захвата и освобождения примитивов синхронизации определены над множеством специальных переменных $S: S \cap X = \emptyset$.
Далее мы будем называть примитив синхронизации, связанный с переменной $s \in S$ блокировкой $s$.
Переменные из множества $S$ принимают значения из $\mathcal{T}=T \cup \{\bot_T\}$.
При этом, $s \mapsto t, t \in T$ означает, что блокировка $s$ захвачена потоком $t$, а $s \mapsto \bot_T$ означает, что эта блокировка не захвачена.

\emph{Конкретным состоянием} параллельной программы называется четверка $(c_{pc}, c_l, c_g, c_s)$, где
\begin{enumerate}
\item Отображение $c_{pc}: T \to L$ является частичной функцией из идентификаторов потока во множество точек программы.
Каждое такое состояние задает точку в программе, в которой находится каждый из потоков.
\item Отображение $c_l: T \to C^{local}$ является частичной функций из множества идентификаторов потока во множество присваиваний локальным переменным их значений. $C^{local}: X^{local} \to \mathbb{Z}$ - отображение, которое задает каждой переменной из $X^{local}$ ее значение из $\mathbb{Z}$.
\item $c_g: X^{global} \to \mathbb{Z}$ задает значения глобальных переменных программы.
\item $c_s: S \to \mathcal{T}$ задает значения блокировок. 
\end{enumerate}
Множество всех возможных конкретных состояния программы обозначим через $C$.

Отображения $c_{pc}$ и $c_l$ представляют локальные части конкретного состояния для каждого потока, а $c_g$ и $c_s$ представляют глобальную часть конкретного состояния, не зависящую от потока.
Обозначим $dom$ область определения частичной функции, например, $dom(c_{pc})=\{ t \mid \exists (t, l) \in c_{pc} \land t \in T \land l \in L \}$.
Будем использовать обозначение $\qdot$ для замены параметра, который является несущественным.
Например, предыдущее определение может быть записано следующим образом $dom(c_{pc})=\{ t \mid \exists (t, \qdot) \in c_{pc} \land t \in T\}$.

Каждое состояние $c=(c_{pc}, c_l, c_g, c_s)\in C$ должно удовлетворять условию $dom(c_{pc})=dom(c_l)$, которое означает, что области определения локальных частей состояния находятся в консистентном состоянии.
Будем использовать обозначение $dom(c)$, как область значения локальных частей состояния, то есть $dom(c)=dom(c_{pc})=dom(c_l)$.

Под отношением переходов, помеченным дугой $g$ будем понимать $\tc{g,t} \subseteq C \times G \times T \times C$, где дуга $g \in G$, а идентификатор потока $t \in T$.
Переход  $c_1 \tc{g,t} c_2, c_1, c_2 \in C$ моделирует переход программы из состояния $c_1$ в состояние $c_2$ при выполнении потоком $t \in T$ операции на дуге $g \in G$.

Для всех $c=(c_{pc}, c_l, c_g, c_s), c'=(c'_{pc}, c'_l, c'_g, c'_s) \in C$, $g = (l, \cdot, l')\in G$, $t\in T$ любой переход $c \tc{g, t} c'$ должен удовлетворять следующим требованиям:
\begin{enumerate}
\item Переход начинается в состоянии $c$: $t\in dom(c_{pc}) \land c_{pc}(t)=l$.
\item При выполнении операции поток $t$ переходит в точку $l'$: $c'_{pc}(t)=l'$.
\item Каждый переход $c \tc{g,t} c'$ может изменить только локальную часть состояния, которая соответствует потоку $t$ и, возможно, глобальную часть состояния, то есть локальные части других потоков остаются неизменны.
Формально
$\forall t'\in T: (t'\neq t) \land (t \in dom(c_{pc})\cap dom(c'_{pc})) \Rightarrow c'_{pc}(t')=c_{pc}(t') \land c'_l(t')=c_l(t')$.
\end{enumerate}

%define regular semantics
Обозначим через $eval(c, t, expr)$ значение выражения $expr$ над переменными из $X^{local} \cup X^{global}$ и со значениями этих переменных из конкретного состояния $c \in C$ для потока с идентификатором $t \in T$. %TODO need more?

Далее определим семантику операций в программе.

\subsection{Проверка условия}
Для дуги $g = (l, assume(expr), l') \in G$, $t\in T$, $l, l' \in L$ существует переход $c \tc{g, t} c'$, $c=(c_{pc}, c_l, c_g, c_s)$, $c'=(c'_{pc}, c'_l, c'_g, c'_s) \in C$ в том и только в том случае, если
\begin{itemize}
\item $dom(c)=dom(c')$ -- переход не меняет множество активных потоков;
\item $eval(c, t, expr) \neq 0$ -- значение проверяемого выражение не равно нулю.
\end{itemize}

\subsection{Присваивание}
Для дуги $g = (l, assign(x, expr), l') \in G$, $t\in T$, $l, l' \in L$ существует переход $c \tc{g, t} c'$, $c=(c_{pc}, c_l, c_g, c_s)$, $c'=(c'_{pc}, c'_l, c'_g, c'_s) \in C$ в том и только в том случае, если
\begin{itemize}
\item $dom(c)=dom(c')$ -- переход не меняет множество активных потоков;
\item 
\begin{align}
c'_l(t)(x')=
\begin{cases}
eval(c, t, expr)& \text{, если $x' = x$} \\
c_l(t)(x') & \text{, если $x' \in X^{local} \land x'\neq x$}
\end{cases} \nonumber
\end{align}
\item
\begin{align}
c'_g(x')=
\begin{cases}
eval(c, t, expr)& \text{, если $x' = x$} \\
c_g(x') & \text{, если $x' \in X^{global} \land x'\neq x$}
\end{cases} \nonumber
\end{align}
\item $c'_s = c_s$ -- блокировки не меняют свои значения.
\end{itemize}

%define acquire|release operations
\subsection{Операции с примитивами синхронизации}
Используем похожее определение на то, которое было дано в~\cite{TAR}. 
Предполагаем, что операция $acquire(s)$ в потоке $t \in T$, где $s\in S$ - блокировка, имеет следующую семантику: 
если $s \mapsto \bot_T$ в предыдущем состоянии, тогда $s \mapsto t$ в следующем состоянии, и эта операция (сравнение и изменение состояния блокировки) производится атомарно за один переход.
%This encoding is essential to prove absence of data races by thread-modular analysis as described in~\cite{}. %qader
%For example, if you use semantics $if$ $(s==0)$ $s=1$ then thread-modular approach will not work.

Формально, для дуги $g = (l, acquire(s), l') \in G$ и $t\in T$, $l, l' \in L$ существует переход
$c \tc{g, t} c'$, $c=(c_{pc}, c_l, c_g, c_s)$, $c'=(c'_{pc}, c'_l, c'_g, c'_s) \in C$
тогда и только тогда, когда 
\begin{itemize}
\item $dom(c)=dom(c')$ -- переход не меняет множество активных потоков;
\item $c'_l=c_l$ -- переход не меняет значения локальных переменных;
\item $c'_g = c_g$ -- переход не меняет значения глобальных переменных;
\item $c_s(s) = \bot_T \land c'_s(s)=t \land \forall s'\in S: s'\neq s \Rightarrow c'_s(s')=c_s(s')$ -- никакие другие блокировки не меняют свое значение.
\end{itemize}

Предполагаем, что операция $release(s)$ в потоке $t \in T$ имеет следующую семантику:
если в начальном состоянии блокировка $s \in S$ была захвачена тем же потоком, то есть $s \mapsto t$, то в следующем состоянии эта блокировка освобождается, то есть $s \mapsto \bot_T$. Операция проходит атомарно.

Формально, для дуги $g = (l, release(s), l')\in G$ и $t\in T$, $l, l' \in L$ существует переход
$c \tc{g, t} c'$, $c=(c_{pc}, c_l, c_g, c_s)$, $c'=(c'_{pc}, c'_l, c'_g, c'_s) \in C$ тогда и только тогда, когда 
\begin{itemize}
\item $dom(c)=dom(c')$ -- переход не меняет множество активных потоков;
\item $c'_l(t)=c_l(t)$ -- переход не меняет значения локальных переменных;
\item $c'_g = c_g$ -- переход не меняет значения глобальных переменных;
\item $c_s(s)=t \land c_s'(s)=\bot_T \land \forall s'\in S: s'\neq s \Rightarrow c'_s(s')=c_s(s')$ -- никакие другие блокировки не меняют свое значение
\end{itemize}

%define thread_create
\subsection{Создание потоков}
Определим семантику $thread\_create(l_\nu)$ таким образом, чтобы текущий поток при выполнении этого оператора перешел в следующую точку программы после $thread\_create$, а новый поток создается с новым идентификатором $\nu \in T$, который добавляется в локальную часть состояния.
Созданный поток начинает свое выполнение из точки программы $l_\nu \in L$.

Заметим, что такое определение позволяет поддерживать анализ программ с неограниченным количеством потоков, так как $thread\_create$ может встречаться в цикле.

Для дуги $g = (l, thread\_create(l_\nu), l')$ существует переход
$c \tc{g, t} c'$, $c=(c_{pc}, c_l, c_g, c_s)$, $c'=(c'_{pc}, c'_l, c'_g, c'_s) \in C$, $\nu \in T$ тогда и только тогда
\begin{itemize}
\item $\nu \notin dom(c) \land dom(c') = dom(c) \cup \{ \nu\}$ -- поток с идентификатором $\nu$ добавляется во множество потоков;
\item $c'_{pc}(t)=l'$ -- счетчик команд в родительском потоке переходит на следующую команду $l'$;
\item $c'_{pc}(\nu)=l_\nu$ --  счетчик команд в дочернем потоке устанавливается в начальную позицию $l_\nu$;
\item $c'_l(\nu)=\emptyset$ -- локальные переменные созданного потока не инициализированы;
\item $c'_l(t)=c_l(t) \land c'_g = c_g \land c'_s = c_s$ -- все остальные части конкретного состояния остаются без изменений.
\end{itemize}

A complete transition relation $\tcarrow$ is a union over all control-flow edges: 
$\tcarrow = \displaystyle\bigcup_{g \in G,t \in T} \tc{g,t}$.
We write $c \tc{g, t} c'$, if $(c, g, t, c') \in \tcarrow$, and
$c \tc{g} c'$, if $\exists t\in T: c \tc{g,t} c'$, and 
$c \tcarrow c'$, if $\exists g\in G: c \tc{g} c'$. 
A set $r \subseteq C$ is called region.
A concrete state $c_n$ is reachable from a region $r$, denoted by $c_n \in Reach_{\tcarrow}(r)$, if there exists a sequence of concrete states $\langle c_0, c_1, ..., c_n \rangle$ such that $c_0 \in r$ and $\forall i : 1 \leq i \leq n : c_{i-1} \tcarrow c_i$.

%TODO example
%For example, consider an edge $g = (thread\_create)$ of thread creation: 
%$(2, c_1^1, c_1^2, c_1^g) \tc{g, 1} (3, c_2^1, c_1^2, c_1^3, c_1^g)$, where the $c_1^3$ is local state of the new thread.

%TODO we demonstrate reachability on data race conditions
%interesting -- requires at least two threads

%\begin{defn}
%\label{raceDef}
%We define a \textbf{data race condition} as a concrete state $c$, such that $\exists c_1, c_2 \in C$, $g_1, g_2 \in G$, $t_1, t_2 \in T$, $t_1 \neq t_2 : c \tc{g_1, t_1} c_1 \land c \tc{g_2, t_2} c_2$ and operations $g_1, g_2$ are performed on the same global variable $x \in X^{global}$ and at least one operation is assignment (i.e. $assign(x, expr)$).
%\end{defn}

%Note, that acquire/release operations are special ones and operate on lock variables only.


\section{Адаптивный статический анализ с частичными состояниями}
\label{sect_cpata}

\newcommand{\update}{update}
\newcommand{\frontier}{frontier}

Определим формально \emph{адаптивный статический анализ с частичными состояниями} для параллельных программ $\mathbb{D}=(D$, $\Pi$, $\tatarrow$, $merge$, $stop$, $prec$, $\update$, $\frontier$ $)$.
Он состоит из абстрактного домена $D$, 
множество точности $\Pi$, 
отношения переходов $\tatarrow$,
оператора слияния $merge$, оператор останова $stop$, функции уточненения $prec$, 
операторов $\update$ и $\frontier$, которые определяют множества частичных состояний для следующего перехода.
Эти операторы будут подробно рассмотрены далее.

{\textbf 1.} \emph{Абстрактный домен}  $D=(C, \mathcal{E},\conc{\cdot})$ определяется множеством $C$ конкретных состояний, полурешеткой $\mathcal{E}$ абстрактных состояний и функцией конкретизации $\conc{\cdot}$.
Полурешетка 
$\mathcal{E}=(E, \top, \bot, \sqsubseteq, \sqcup)$ состоит из (возможно, бесконечного) множества $E$ элементов абстрактного домена, верхнего элемента $\top \in E$, нижнего элемента $\bot \in E$, частичного порядка $\sqsubseteq \subseteq E \times E$ и функции $\sqcup:E \times E \rightarrow E$ (оператор объединения состояний).
Функция $\sqcup$ возвращает наименьший элемент решетки, который больше, чем каждый из двух ее аргументов, а символы $\top$ и $\bot$ обозначают наибольший и наименьший элемент решетки $E$ соответственно. 

Функция конкретизации $\conc{\cdot}: 2^E \rightarrow 2^C$ отображает каждое множество абстрактных состояний $s \subseteq E$ на множество его значений, то есть на множество конкретных состояний программы, которое оно представляет.
Заметим, что аргументом функции конкретизации является множество абстрактных состояний, а не одно состояние.
Это объясняется тем, что суммарное знание для множества частичных состояний может быть больше, чем знание для одного частичного состояния, то есть,  
$$\forall R\subseteq E: \conc{R} \supseteq \bigcup_{e\in R}{\conc{\{e\}}}$$

Для корректности анализа программы абстрактный домен должен удовлетворять следующим требованиям:

\begin{equation}
\label{cpa_conc_eq_0}
\forall R \subseteq \overline{R} \subseteq E: \conc{R} \subseteq \conc{\overline R}
\end{equation}

\begin{equation}
\label{cpa_conc_eq_2}
\forall e, e' \in E, R \subseteq E : e \sqsubseteq e' \implies \conc{R \cup e} \subseteq \conc{R \cup e'}
\end{equation}

{\textbf 2.} Множество \emph{точности} $\Pi$ определяет уровень детализации абстрактного домена. Анализ использует элементы из $\Pi$, чтобы определять различный уровень точности для различных абстрактных состояний.
Пара $(e, \pi)$ называется абстрактным состоянием $e$ с точностью $\pi$.
Операторы на абстрактном домене параметризуются уровнем точности.

Для $R \subseteq E \times \Pi$ обозначаем
$\conc{R} = \conc{\bigcup_{(e,\pi)\in R}\{e\}}$.

{\textbf 3.} Отношение переходов \emph{transfer} $\tatarrow: 2^{E\times \Pi} \times G \times E \times \Pi$ определяет для каждого множества частичных состояний $\hat R$ следующие возможные абстрактные состояния $e'$ с точностью $\pi$.
Будем писать $\hat R \tat{g} (e', \pi)$, если $(\hat R, g, e, \pi) \in \tatarrow$ и $\hat R \tatarrow (e', \pi)$ если $\exists g \in G: \hat R \tat{g} (e', \pi)$.

%TODO: do we need g,t on the arrow? 
%and $e \tatarrow (e', \pi)$ if $\exists g \in G, t \in T: e \tat{g,t} (e', \pi)$.

Требование к отношению переходов в классическом CPA является слишком строгим.
В некоторых случаях более эффективным является аппроксимировать переходы из $\conc{\hat R}$  в несколько шагов:
\begin{itemize}
\item применение переходов из частичных состояний по отдельности;
\item применение некоторых шагов позже, например, переходов по окружению.
\end{itemize}

Обозначим $Reach^k$ как
\begin{equation}
\label{reach_k}
\begin{aligned}
& \forall R \subseteq E: Reach^0(R) = R \\
\forall k\ge 1:& Reach^{k+1}(R) = \bigcup_{\hat R \subseteq Reach^{k}(R)}{\{(e',\pi') \mid \hat R \tatarrow (e',\pi')\}} \cup Reach^{k}(R) \\
\end{aligned}
\end{equation}

Далее мы будем писать $Reach(R) = Reach^1(R)$. 

Требованием к отношению переходов является аппроксимация сверху множества конкретных переходов:
\begin{equation}
\label{cpa_transfer_eq}
\begin{aligned}
& \exists k \ge 1: \forall R \subseteq E \times \Pi:\\
& \conc{Reach^k(R)} \supseteq \bigcup_{c \in \conc{R}}{\{c' \mid c \tcarrow c'\}} \\
\end{aligned}
\end{equation}

%--------------------------------

{\textbf 4.} Оператор \emph{merge} $merge: E \times E \times \Pi \rightarrow E$ ослабляет второй параметр, используя информацию от первого параметра, и возвращает новое абстрактное состояние с точностью, которая передавалась, как третий параметр.
Оператор \emph{merge} должен удовлетворять следующим требованиям:
\begin{equation}
\label{cpa_merge_eq}
\begin{aligned}
&\forall e, e' \in E, \pi \in \Pi :\\
&e' \sqsubseteq merge(e, e', \pi)
\end{aligned}
\end{equation}

{\textbf 5.} Оператор \emph{stop} $stop: E \times 2^{E \times \Pi} \times \Pi \rightarrow \mathbb{B}$ проверяет, является ли абстрактное состояние, передаваемое, как первый параметр с точностью, передаваемой как третий параметр, покрытым множеством абстрактных состояний, которые передаются вторым параметром.
Оператор останова может, например, проходить по элементам из множества $R$, который передается как второй параметр и искать такой элемент, который больше ($\sqsubset$), чем проверяемый элемент.
%, or -- if $D$ is a powerset domain\footnote{A powerset domain is an abstract domain s.t. $\tconc{e \sqcup e'}{t} = \tconc{e}{t} \cup \tconc{e'}{t}$} -- can join the elements of $R$ to check if $R$ subsumes the first parameter. 
Оператор останова должен удовлетворять следующему требованию:
\begin{equation}
\label{cpa_stop_eq}
\begin{aligned}
&\forall e \in E, R \subseteq E, \pi \in \Pi:\\
&stop(e, R, \pi) \implies\forall \hat R \subseteq E: \conc{\{e\}\cup \hat R} \subseteq \conc{R \cup \hat R}
\end{aligned}
\end{equation}

{\textbf 6.} Функция уточнения $prec:E \times \Pi \times 2^{E \times \Pi} \rightarrow E \times \Pi$ вычисляет новое абстрактное состояние и новую точность для данного абстрактного состояния и множества асбтрактных состояний.
Эта функция может производить ослабление абстрактного состояния.
Она должна удовлетворять следующему требованию:

\begin{equation}
\label{prec_equation}
\begin{aligned}
& \forall e, e' \in E, \pi, \pi' \in \Pi, R \subseteq E \times \Pi:\\
& (e', \pi') = prec(e, \pi, R) \implies e \sqsubseteq e'
\end{aligned}
\end{equation}

%--------------------------------

{\textbf 7.} Оператор
$\update: 2^{2^{E\times \Pi}} \times 2^{E\times \Pi} \times E \times \Pi \times E \times \Pi \rightarrow 2^{2^{E \times \Pi}}$
заменяет старый элемент с некоторой точностью на новый элемент с новой точностью во множестве необработанных состояний (\emph{waitlist}), который представлен первым параметром ($2^{2^{E\times \Pi}}$) и возвращает новый \emph{waitlist}.

Обозначим $Reach^w(W) = \{(e, \pi) \mid R_0 \tatarrow (e,\pi) \land R_0 \in W\}$.
Заметим, что 
\begin{equation}
\label{reach_w_equation}
\begin{aligned}
& Reach^w(W_1 \cup W_2) = Reach^w(W_1) \cup Reach^w(W_2))
\end{aligned}
\end{equation}

Оператор \emph{update} должен удовлетворять следующему требованию:
\begin{equation}
\label{cpa_update_transfer_eq}
\begin{aligned}
& \forall e, e' \in E, \pi, \pi' \in \Pi, W,W' \subseteq 2^{E\times \Pi},  R \subseteq E\times \Pi, e \sqsubseteq e':\\
& R' = R \setminus \{e\} \cup \{e'\} \land W' = \update(W, R, e, \pi, e',\pi') \\
& \land ( \forall \overline{R} \subseteq R: \overline{R} \in W \lor (\forall e \in Reach^w(\{\overline{R}\}) \exists e' \in R: e \sqsubseteq e') \implies  \\
& \forall \overline{R} \subseteq R': \overline{R} \in W' \lor (\forall e \in Reach^w(\{\overline{R}\}) \exists e' \in R': e \sqsubseteq e'))
\end{aligned}
\end{equation}

\iffalse %The following text is banned by moderator
The equation~\ref{cpa_update_transfer_eq} is more general, but for further profs we will use more specific and strict condition.

\begin{equation}
\label{cpa_update_transfer_eq_power}
\begin{aligned}
update(W, R, e, \pi, e', \pi') = \{\widehat{R} \mid \widehat{R} \in W \land (e, \pi) \notin \widehat{R}\} \cup frontier(R', e', \pi')
\end{aligned}
\end{equation}

Show that equation~\ref{cpa_update_transfer_eq_power} implies equation~\ref{cpa_update_transfer_eq}.
Denote $\overline{W} = \{\widehat{R} \mid \widehat{R} \in W \land (e, \pi) \notin \widehat{R}\}$. $W = \overline{W} \cup \{\widehat{R} \mid \widehat{R} \in W \land (e, \pi) \in \widehat{R}\}$.
$W' = update(W, R, e, \pi, e', \pi') = \{\widehat{R} \mid \widehat{R} \in W \land (e, \pi) \notin \widehat{R}\} \cup frontier(R', e', \pi') = \overline{W} \cup frontier(R', e', \pi')$.
Denote also $R \setminus \{e\} = \widehat{R}$. Then $R' = \widehat{R} \cup \{e'\}$.
Get an arbitrary $\overline{R} \subseteq R'$, assume $\forall \overline{R} \subseteq R: \overline{R} \in W \lor Reach(\overline{R}) \subseteq R$ and show that definition~\ref{cpa_update_transfer_eq_power} satisfies the invariant~\ref{cpa_update_transfer_eq}. 

\begin{itemize}
\item $e \notin \overline{R} \land e \notin Reach^w(\{\overline{R}\})$. The assumption for the $\overline{R}$ holds, i.e.
\begin{align}
& \overline{R} \in W \lor Reach^w(\{\overline{R}\}) \subseteq R \leftrightarrow (item) \nonumber \\
& \leftrightarrow \overline{R} \in \widehat{W} \lor Reach^w(\{\overline{R}\}) \subseteq R \setminus \{e\} \implies \nonumber \\
& \implies \overline{R} \in W' \lor Reach^w(\{\overline{R}\}) \subseteq R'
\end{align}

\item $\overline{R} \subseteq \widehat{R} \land e \in Reach^w(\{\overline{R}\})$. For that $\overline{R}$ the assumption holds.
\end{itemize}
\fi

{\textbf 8.} Оператор
$\frontier: 2^{E\times \Pi} \times E \times \Pi \rightarrow 2^{2^{E\times \Pi}}$ возвращает новое множество необработанных состояний для нового элемента с новой точностью.

Оператор \emph{frontier} должен удовлетворять следующему требованию:
\begin{equation}
\label{cpa_frontier_transfer_eq}
\begin{aligned}
& \forall e \in E, \pi \in \Pi, \widehat{R}, R \subseteq E, \widehat{R} \subseteq (R \cup \{e\}), e\in \widehat{R} : \\ 
&  
\widehat{R} \subseteq frontier(R, e, \pi) \lor Reach(\widehat{R}) \subseteq (R \cup \{e\}) \\ 
\end{aligned}
\end{equation}

%end of CPA definition
\section{Алгоритм с частичными состояниями}

\begin{algorithm}[H]
% General Algorithm
 \KwData{
 адаптивный статический анализ с частичными состояниями $\mathbb{D}$,
 {начальное абстрактное состояние $e_0$ с точностью $\pi_0 \in \Pi$},
 {множество $reached$ элементов из $E \times \Pi$},
 {множество $waitlist$ элементов из $2^{E \times \Pi}$}
 }
\KwResult{множество достижимых состояний $reached$}
{\color{blue}
 $waitlist := \frontier(\emptyset, \emptyset, e_0, \pi_0)$\;
}
 $reached := \{e_0,\pi_0\} $\;

 \While{$waitlist \neq \emptyset$}{
  pop $\widehat{R}$ from $waitlist$\;  
  \For{each $e'$ in $\widehat{R} \tatarrow (e', \pi')$ }{
   $(\widehat{e}, \widehat{e})=prec(e',\pi',reached)$\;
   \For{each $(e'', \pi'') \in reached$}{
    $e_{new} = merge(\widehat{e}, e'', \widehat{\pi})$\;
    \If{$e_{new} \neq e''$}{
{\color{blue}
     $waitlist := \update(waitlist, reached, e'', \pi'', e_{new}, \widehat{\pi})$\;
}
     $reached := reached \setminus{\{(e'', \pi'')\}} \cup \{(e_{new}, \widehat{\pi})\}$\;
    }
   }
   \If{$!stop(\widehat{e}, reached, \widehat{\pi})$}{
{\color{blue}
    $waitlist := waitlist \cup \frontier(reached, \widehat{e}, \widehat{\pi})$\;
}
    $reached := reached \cup \{(\widehat{e}, \widehat{\pi})\}$\;
   }
  }
 }%repeat

 \caption{$CPA_{PS}(\mathbb{D}, e_0, \pi_0)$}
 \label{cpata_algorithm_ps}
\end{algorithm}

\begin{thrm}
(Soundness) Для заданного адаптивного статического анализа с частичными состояниями $\mathbb{D}$ и начального абстрактного состояния $e_0$ с точностью $\pi_0$, алгоритм $CPA_{PS}$ вычисляет множество абстрактных состояний, которое аппроксимирует сверху множество достижимых конкретных состояний:

$$\conc{CPA_{PS}(\mathbb{D}, e_0, \pi_0)} \supseteq Reach_{\tcarrow}(\conc{\{e_0\}})$$

\end{thrm}

\section{Одиночное изображение} \label{sect2_1}

%\newpage
%============================================================================================================================
\section{Длинное название параграфа, в котором мы узнаём как сделать две картинки с~общим номером и названием} \label{sect2_2}

А это две картинки под общим номером и названием:
\begin{figure}[ht]
  \begin{minipage}[ht]{0.49\linewidth}\centering
    \includegraphics[width=0.5\linewidth]{knuth1} \\ а)
  \end{minipage}
  \hfill
  \begin{minipage}[ht]{0.49\linewidth}\centering
    \includegraphics[width=0.5\linewidth]{knuth2} \\ б)
  \end{minipage}
  \caption{Очень длинная подпись к изображению, на котором представлены две фотографии Дональда Кнута}
  \label{img:knuth}  
\end{figure}

Те~же~две картинки под~общим номером и~названием, но с автоматизированной нумерацией подрисунков:
\begin{figure}[ht]
    {\centering
        \hfill
        \subbottom[List-of-Figures entry][Первый подрисунок\label{img:knuth_2_1}]{%
            \includegraphics[width=0.25\linewidth]{knuth1}}
        \hfill
        \subbottom[\label{img:knuth_2_2}]{%
            \includegraphics[width=0.25\linewidth]{knuth2}}
        \hfill
        \subbottom[Третий подрисунок]{%
            \includegraphics[width=0.3\linewidth]{example-image-c}}
        \hfill
    }
    \legend{Подрисуночный текст, описывающий обозначения, например. Согласно
    ГОСТ 2.105, пункт 4.3.1, располагается перед наименованием рисунка.}
    \caption[Этот текст попадает в названия рисунков в списке рисунков]{Очень
    длинная подпись к второму изображению, на котором представлены две
    фотографии Дональда Кнута}
    \label{img:knuth_2}
\end{figure}

Возможно вставлять векторные картинки, рассчитываемые \LaTeX\ <<на~лету>>
с~их~предварительной компиляцией. Надписи в таких рисунках будут выполнены
тем же~шрифтом, который указан для документа в целом.
На рисунке~\ref{img:tikz_example} на~странице~\pageref{img:tikz_example} представлен пример схемы, рассчитываемой пакетом \verb|tikz| <<на~лету>>.
Для ускорения компиляции, подобные рисунки могут быть <<кешированы>>, что
определяется настройками в~\verb|common/setup.tex|.
Причём имя предкомпилированного
файла и папка расположения таких файлов могут быть отдельно заданы,
что удобно, если не для подготовки диссертации,
то для подготовки научных публикаций.
\begin{figure}[ht]
    {\centering
        \ifdefmacro{\tikzsetnextfilename}{\tikzsetnextfilename{tikz_example_compiled}}{}% присваиваемое предкомпилированному pdf имя файла
        \input{Dissertation/images/tikz_scheme.tikz}

    }
    \legend{}
    \caption[Пример \texttt{tikz} схемы]{Пример рисунка, рассчитываемого
        \texttt{tikz}, который может быть предкомпилирован}
    \label{img:tikz_example}
\end{figure}

Множество программ имеют либо встроенную возможность экспортировать векторную
графику кодом \verb|tikz|, либо соответствующий пакет расширения.
Например, в GeoGebra есть встроенный экспорт,
для Inkscape есть пакет svg2tikz,
для Python есть пакет matplotlib2tikz,
для R есть пакет tikzdevice.


\section{Традиции русского набора}

\subsection{Пробелы}

В~русском наборе принято:
\begin{itemize}
    \item единицы измерения, знак процента отделять пробелами от~числа: 10~кВт, 15~\% (согласно ГОСТ 8.417, раздел 8);
    \item $\tg 20^\circ$, но: 20~${}^\circ$C (согласно ГОСТ 8.417, раздел 8);
    \item знак номера, параграфа отделять от~числа: №~5, \S~8;
    \item стандартные сокращения: т.\:е., и~т.\:д., и~т.\:п.;
    \item неразрывные пробелы в~предложениях.
\end{itemize}

\subsection{Математические знаки и символы}

Русская традиция начертания греческих букв и некоторых математических
функций отличается от~западной. Это исправляется серией
\verb|\renewcommand|.
\begin{itemize}
%Все \original... команды заранее, ради этого примера, определены в Dissertation\userstyles.tex
    \item[До:] \( \originalepsilon \originalge \originalphi\),
    \(\originalphi \originalleq \originalepsilon\),
    \(\originalkappa \in \originalemptyset\),
    \(\originaltan\),
    \(\originalcot\),
    \(\originalcsc\).
    \item[После:] \( \epsilon \ge \phi\),
    \(\phi \leq \epsilon\),
    \(\kappa \in \emptyset\),
    \(\tan\),
    \(\cot\),
    \(\csc\).
\end{itemize}

Кроме того, принято набирать греческие буквы вертикальными, что
решается подключением пакета \verb|upgreek| (см. закомментированный
блок в~\verb|userpackages.tex|) и~аналогичным переопределением в
преамбуле (см.~закомментированный блок в \verb|userstyles.tex|). В
этом шаблоне такие переопределения уже включены.

Знаки математических операций принято переносить. Пример переноса
в~формуле \eqref{eq:equation3}.

\subsection{Кавычки}
В английском языке приняты одинарные и двойные кавычки в~виде ‘...’ и~“...”. В России приняты французские («...») и~немецкие („...“) кавычки (они называются «ёлочки» и~«лапки», соответственно). <<Лапки>> обычно используются внутри ,,ёлочек``, например, <<... наш гордый ,,Варяг``...>>.

Французкие левые и правые кавычки набираются
как лигатуры \verb|<<| и \verb|>>|, а~немецкие левые и правые кавычки набираются как лигатуры \verb|,,| и \verb|‘‘| (\verb|``|).

Вместо лигатур или команд с~активным символом "\ можно использовать команды \verb|\glqq| и \verb|\grqq| для набора немецких кавычек и команды \verb|\flqq| и~\verb|\frqq| для набора французских кавычек. Они определены в пакете \verb|babel|.

\subsection{Тире}
%  babel+pdflatex по умолчанию, в polyglossia надо включать опцией (и перекомпилировать с удалением временных файлов)
Команда \verb|"---| используется для печати тире в тексте. Оно несколько короче английского длинного тире. Кроме того, команда задаёт небольшую жёсткую отбивку от слова, стоящего перед тире. При этом, само тире не отрывается от~слова. После тире следует такая же отбивка от текста, как и перед тире. При наборе текста между словом и командой, за которым она следует, должен стоять пробел.

В составных словах, таких, как <<Закон Менделеева"--~Клапейрона>>, для печати тире надо использовать команду \verb|"--~|. Она ставит более короткое, по~сравнению с~английским, тире и позволяет делать переносы во втором слове. При~наборе текста команда \verb|"--~| не отделяется пробелом от слова, за которым она следует (\verb|Менделеева"--~|). Следующее за командой слово может быть  отделено от~неё пробелом или перенесено на другую строку.

Если прямая речь начинается с~абзаца, то перед началом её печатается тире командой
\verb|"--*|. Она печатает русское тире и жёсткую отбивку нужной величины перед текстом.

\subsection{Дефисы и переносы слов}
%  babel+pdflatex по умолчанию, в polyglossia надо включать опцией (и перекомпилировать с удалением временных файлов)
Для печати дефиса в~составных словах введены две команды. Команда~\verb|"~| печатает дефис и~запрещает делать переносы в~самих словах, а~команда \verb|"=| печатает дефис, оставляя \TeX ’у право делать переносы в~самих словах.

В отличие от команды \verb|\-|, команда \verb|"-| задаёт место в~слове, где можно делать перенос, не~запрещая переносы и~в~других местах слова.

Команда \verb|""| задаёт место в~слове, где можно делать перенос, причём дефис при~переносе в~этом месте не~ставится.

Команда \verb|",| вставляет небольшой пробел после инициалов с~правом переноса в~фамилии.

\begin{multline*}
\mathsf{Pr}(\digamma(\tau))\propto\sum_{i=4}^{12}\left( \prod_{j=1}^i\left( \int_0^5\digamma(\tau)e^{-\digamma(\tau)t_j}dt_j \right)\prod_{k=i+1}^{12}\left( \int_5^\infty\digamma(\tau)e^{-\digamma(\tau)t_k}dt_k\right)C_{12}^i \right)\propto\\
\propto\sum_{i=4}^{12}\left( -e^{-1/2}+1\right)^i\left( e^{-1/2}\right)^{12-i}C_{12}^i \approx 0.7605,\quad \forall\tau\neq\overline{\tau}
\end{multline*}


%Большая фигурная скобка только справа
\[\left.                                                          %ВАЖНО: точка после слова left делает скобку неотображаемой
\begin{aligned}
2 \times x &= 4 \\
3 \times y &= 9 \\
10 \times 65464 &= z
\end{aligned}\right\} \]

