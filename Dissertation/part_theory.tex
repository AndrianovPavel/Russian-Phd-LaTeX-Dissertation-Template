\chapter{Теория}
\label{chapter_theory}

\section{Основные определения}
В этом разделе представлены основные определения параллельной программы и достижимых конкретных состояний в программе.

Будем рассматривать простой императивный язык программирования, в котором поддерживаются операторы присваивания (assignment), проверки условия (assumption), захват и освобождение примитивов синхронизации (acquire/release) и создание потоков (thread\_create)\footnote{Реализация основана на инструменте \cpachecker, который работает с программами на языке Си}.

Параллельная программа представляется автоматом потока управления (англ. Control Flow Automaton, CFA), который состоит из множества вершин $L$  и множества соединяющих их ребер $G$ .
Множество $L$ - это множество всех точек программы (англ. program location), множество $G \subseteq L \times Ops \times L$, где $Ops$ - это множество всех операций программы.
Так, отдельная дуга $g \in G, g = (l_1, op, l_2)$ моделирует операцию $op$, которая выполняется в программе, когда управление переходит из точки $l_1$ в точку $l_2$.
Операция создания нового потока создает новый поток с идентификатором из множества $T$ и новый поток начинает свое выполнение из некоторой точки программы из множества $L$.
Множество всех переменных программы, которые встречаются в операциях $assignment$ и $assumption$ обозначается как $X$.
Будем считать, что переменные принимают только значения лежащие в $\mathbb{Z}$.
Подмножество $X$, которое содержит все локальные переменные программы, обозначается как $X^{local}$, а подмножество, содержащее все глобальные переменные, -  $X^{global}$. 
%(to simplify presentation all threads have the same set of local variables) 
Операции захвата и освобождения примитивов синхронизации определены над множеством специальных переменных $S: S \cap X = \emptyset$.
Далее мы будем называть примитив синхронизации, связанный с переменной $s \in S$ блокировкой $s$.
Переменные из множества $S$ принимают значения из $\mathcal{T}=T \cup \{\bot_T\}$.
При этом, $s \mapsto t, t \in T$ означает, что блокировка $s$ захвачена потоком $t$, а $s \mapsto \bot_T$ означает, что эта блокировка не захвачена.

\emph{Конкретным состоянием} параллельной программы называется четверка $(c_{pc}, c_l, c_g, c_s)$, где
\begin{enumerate}
\item Отображение $c_{pc}: T \to L$ является частичной функцией из идентификаторов потока во множество точек программы.
Каждое такое состояние задает точку в программе, в которой находится каждый из потоков.
\item Отображение $c_l: T \to C^{local}$ является частичной функций из множества идентификаторов потока во множество присваиваний локальным переменным их значений. $C^{local}: X^{local} \to \mathbb{Z}$ - отображение, которое задает каждой переменной из $X^{local}$ ее значение из $\mathbb{Z}$.
\item $c_g: X^{global} \to \mathbb{Z}$ задает значения глобальных переменных программы.
\item $c_s: S \to \mathcal{T}$ задает значения блокировок. 
\end{enumerate}
Множество всех возможных конкретных состояния программы обозначим через $C$.

Отображения $c_{pc}$ и $c_l$ представляют локальные части конкретного состояния для каждого потока, а $c_g$ и $c_s$ представляют глобальную часть конкретного состояния, не зависящую от потока.
Обозначим $dom$ область определения частичной функции, например, $dom(c_{pc})=\{ t \mid \exists (t, l) \in c_{pc} \land t \in T \land l \in L \}$.
Будем использовать обозначение $\qdot$ для замены параметра, который является несущественным.
Например, предыдущее определение может быть записано следующим образом $dom(c_{pc})=\{ t \mid \exists (t, \qdot) \in c_{pc} \land t \in T\}$.

Каждое состояние $c=(c_{pc}, c_l, c_g, c_s)\in C$ должно удовлетворять условию $dom(c_{pc})=dom(c_l)$, которое означает, что области определения локальных частей состояния находятся в консистентном состоянии.
Будем использовать обозначение $dom(c)$, как область значения локальных частей состояния, то есть $dom(c)=dom(c_{pc})=dom(c_l)$.

Под отношением переходов, помеченным дугой $g$ будем понимать $\tc{g,t} \subseteq C \times G \times T \times C$, где дуга $g \in G$, а идентификатор потока $t \in T$.
Переход  $c_1 \tc{g,t} c_2, c_1, c_2 \in C$ моделирует переход программы из состояния $c_1$ в состояние $c_2$ при выполнении потоком $t \in T$ операции на дуге $g \in G$.
Для полноты будем считать, что существует специальный $\varepsilon$-переход из каждого состояния в себя:
$\forall c \in C, t \in T: c \tc{\varepsilon, t} c$.

Определим множество конкретных переходов $\mathcal{T}=C\times G \times T$.
Конкретный переход $\tau \in \mathcal{T}$ -- это тройка $\tau = (c, g, t)$. 
Будем писать $\tau_1 \tcarrow \tau_2$, если $\exists c_3 \in C: c_1 \tc{g_1, t_1} c_2 \tc {g_2, t_2} c_3$.

Для всех $c=(c_{pc}, c_l, c_g, c_s), c'=(c'_{pc}, c'_l, c'_g, c'_s) \in C$, $g = (l, \cdot, l')\in G$, $t\in T$ любой переход $c \tc{g, t} c'$ должен удовлетворять следующим требованиям:
\begin{enumerate}
\item Переход начинается в состоянии $c$: $t\in dom(c_{pc}) \land c_{pc}(t)=l$.
\item При выполнении операции поток $t$ переходит в точку $l'$: $c'_{pc}(t)=l'$.
\item Каждый переход $c \tc{g,t} c'$ может изменить только локальную часть состояния, которая соответствует потоку $t$ и, возможно, глобальную часть состояния, то есть локальные части других потоков остаются неизменны.
Формально
$\forall t'\in T: (t'\neq t) \land (t \in dom(c_{pc})\cap dom(c'_{pc})) \Rightarrow c'_{pc}(t')=c_{pc}(t') \land c'_l(t')=c_l(t')$.
\end{enumerate}

Полное отношение переходов $\tcarrow$ определяется как объединение по всехм переходам: 
$\tcarrow = \displaystyle\bigcup_{g \in G,t \in T} \tc{g,t}$.
Будем обозначать $c \tc{g, t} c'$, если $(c, g, t, c') \in \tcarrow$, и
$c \tc{g} c'$, если $\exists t\in T: c \tc{g,t} c'$, и 
$c \tcarrow c'$, если $\exists g\in G: c \tc{g} c'$. 
%A set $r \subseteq C$ is called region.
%A concrete state $c_n$ is reachable from a region $r$, denoted by $c_n \in Reach_{\tcarrow}(r)$, if there exists a sequence of concrete states $\langle c_0, c_1, ..., c_n \rangle$ such that $c_0 \in r$ and $\forall i : 1 \leq i \leq n : c_{i-1} \tcarrow c_i$.

%define regular semantics
Обозначим через $eval(c, t, expr)$ значение выражения $expr$ над переменными из $X^{local} \cup X^{global}$ и со значениями этих переменных из конкретного состояния $c \in C$ для потока с идентификатором $t \in T$. %TODO need more?

Далее определим семантику операций в программе.

\subsection{Проверка условия}
Для дуги $g = (l, assume(expr), l') \in G$, $t\in T$, $l, l' \in L$ существует переход $c \tc{g, t} c'$, $c=(c_{pc}, c_l, c_g, c_s)$, $c'=(c'_{pc}, c'_l, c'_g, c'_s) \in C$ в том и только в том случае, если
\begin{itemize}
\item $dom(c)=dom(c')$ -- переход не меняет множество активных потоков;
\item $eval(c, t, expr) \neq 0$ -- значение проверяемого выражение не равно нулю.
\end{itemize}

\subsection{Присваивание}
Для дуги $g = (l, assign(x, expr), l') \in G$, $t\in T$, $l, l' \in L$ существует переход $c \tc{g, t} c'$, $c=(c_{pc}, c_l, c_g, c_s)$, $c'=(c'_{pc}, c'_l, c'_g, c'_s) \in C$ в том и только в том случае, если
\begin{itemize}
\item $dom(c)=dom(c')$ -- переход не меняет множество активных потоков;
\item 
\begin{align}
c'_l(t)(x')=
\begin{cases}
eval(c, t, expr)& \text{, если $x' = x$} \\
c_l(t)(x') & \text{, если $x' \in X^{local} \land x'\neq x$}
\end{cases} \nonumber
\end{align}
\item
\begin{align}
c'_g(x')=
\begin{cases}
eval(c, t, expr)& \text{, если $x' = x$} \\
c_g(x') & \text{, если $x' \in X^{global} \land x'\neq x$}
\end{cases} \nonumber
\end{align}
\item $c'_s = c_s$ -- блокировки не меняют свои значения.
\end{itemize}

%define acquire|release operations
\subsection{Операции с примитивами синхронизации}
Используем похожее определение на то, которое было дано в~\cite{TAR}. 
Предполагаем, что операция $acquire(s)$ в потоке $t \in T$, где $s\in S$ - блокировка, имеет следующую семантику: 
если $s \mapsto \bot_T$ в предыдущем состоянии, тогда $s \mapsto t$ в следующем состоянии, и эта операция (сравнение и изменение состояния блокировки) производится атомарно за один переход.
%This encoding is essential to prove absence of data races by thread-modular analysis as described in~\cite{}. %qader
%For example, if you use semantics $if$ $(s==0)$ $s=1$ then thread-modular approach will not work.

Формально, для дуги $g = (l, acquire(s), l') \in G$ и $t\in T$, $l, l' \in L$ существует переход
$c \tc{g, t} c'$, $c=(c_{pc}, c_l, c_g, c_s)$, $c'=(c'_{pc}, c'_l, c'_g, c'_s) \in C$
тогда и только тогда, когда 
\begin{itemize}
\item $dom(c)=dom(c')$ -- переход не меняет множество активных потоков;
\item $c'_l=c_l$ -- переход не меняет значения локальных переменных;
\item $c'_g = c_g$ -- переход не меняет значения глобальных переменных;
\item $c_s(s) = \bot_T \land c'_s(s)=t \land \forall s'\in S: s'\neq s \Rightarrow c'_s(s')=c_s(s')$ -- никакие другие блокировки не меняют свое значение.
\end{itemize}

Предполагаем, что операция $release(s)$ в потоке $t \in T$ имеет следующую семантику:
если в начальном состоянии блокировка $s \in S$ была захвачена тем же потоком, то есть $s \mapsto t$, то в следующем состоянии эта блокировка освобождается, то есть $s \mapsto \bot_T$. Операция проходит атомарно.

Формально, для дуги $g = (l, release(s), l')\in G$ и $t\in T$, $l, l' \in L$ существует переход
$c \tc{g, t} c'$, $c=(c_{pc}, c_l, c_g, c_s)$, $c'=(c'_{pc}, c'_l, c'_g, c'_s) \in C$ тогда и только тогда, когда 
\begin{itemize}
\item $dom(c)=dom(c')$ -- переход не меняет множество активных потоков;
\item $c'_l(t)=c_l(t)$ -- переход не меняет значения локальных переменных;
\item $c'_g = c_g$ -- переход не меняет значения глобальных переменных;
\item $c_s(s)=t \land c_s'(s)=\bot_T \land \forall s'\in S: s'\neq s \Rightarrow c'_s(s')=c_s(s')$ -- никакие другие блокировки не меняют свое значение
\end{itemize}

%define thread_create
\subsection{Создание потоков}
Определим семантику $thread\_create(l_\nu)$ таким образом, чтобы текущий поток при выполнении этого оператора перешел в следующую точку программы после $thread\_create$, а новый поток создается с новым идентификатором $\nu \in T$, который добавляется в локальную часть состояния.
Созданный поток начинает свое выполнение из точки программы $l_\nu \in L$.

Заметим, что такое определение позволяет поддерживать анализ программ с неограниченным количеством потоков, так как $thread\_create$ может встречаться в цикле.

Для дуги $g = (l, thread\_create(l_\nu), l')$ существует переход
$c \tc{g, t} c'$, $c=(c_{pc}, c_l, c_g, c_s)$, $c'=(c'_{pc}, c'_l, c'_g, c'_s) \in C$, $\nu \in T$ тогда и только тогда
\begin{itemize}
\item $\nu \notin dom(c) \land dom(c') = dom(c) \cup \{ \nu\}$ -- поток с идентификатором $\nu$ добавляется во множество потоков;
\item $c'_{pc}(t)=l'$ -- счетчик команд в родительском потоке переходит на следующую команду $l'$;
\item $c'_{pc}(\nu)=l_\nu$ --  счетчик команд в дочернем потоке устанавливается в начальную позицию $l_\nu$;
\item $c'_l(\nu)=\emptyset$ -- локальные переменные созданного потока не инициализированы;
\item $c'_l(t)=c_l(t) \land c'_g = c_g \land c'_s = c_s$ -- все остальные части конкретного состояния остаются без изменений.
\end{itemize}

%TODO example
%For example, consider an edge $g = (thread\_create)$ of thread creation: 
%$(2, c_1^1, c_1^2, c_1^g) \tc{g, 1} (3, c_2^1, c_1^2, c_1^3, c_1^g)$, where the $c_1^3$ is local state of the new thread.

%TODO we demonstrate reachability on data race conditions
%interesting -- requires at least two threads

\subsection{Ошибка в программе}

Во многих методах статической верификации используется понятие ошибочного состояния. 
Такие методы решают задачу достижимости и пытаются доказать, что заданное ошибочное состояния недостижимо.
Примером такого определения является использование конструкций типа assert. 
В случае нарушения логического условия, записанного в качестве параметра, инструмент фиксирует ошибку.

Такое определение ошибки является достаточно общим, так как позволяет сформулировать различные свойства программы, которые требуется верифицировать. 
Еще одной важной особенностью является то, что такое определение с одинаковым успехом может применяться как к последовательным программам, так и к параллельным. 

Состояние гонки обычно определяются с помощью такой конструкции, как последовательность

\begin{small}
\begin{lstlisting}
variable = expression;
assert(variable == expression);
\end{lstlisting}
\end{small}

Основным минусом такого подхода является то, что при поиске состояний гонки  реальных программах не известно, какая именно переменная может модифицироваться из нескольких потоков, а значит, придется расставлять assert после каждой записи в переменную. 
Поэтому, хотя такое определение ошибки тоже имеет место и поддерживается в предлагаемой теории, дадим более практичное определение.

\begin{defn}
\label{raceDef}
Определим \textbf{состояние гонки} как конкретное состояние $c$ такое, что $\exists c_1, c_2 \in C$, $g_1, g_2 \in G$, $t_1, t_2 \in T$, $t_1 \neq t_2 : c \tc{g_1, t_1} c_1 \land c \tc{g_2, t_2} c_2$ и операции $g_1, g_2$ выполняются над одной и той же глобальной переменной $x \in X^{global}$ и хотя бы одна операция является присваиванием (то есть $assign(x, expr)$).
\end{defn}

%Note, that acquire/release operations are special ones and operate on lock variables only.


\section{Адаптивный статический анализ с абстрактными переходами}
\label{sect_cpata}

\newcommand{\update}{update}
\newcommand{\frontier}{frontier}

В классической теории~\cite{BeyerCPA07,Beyer08}, абстрактное состояние представляет собой множество конкретных состояний программы.
В предлагаемом расширении теории абстрактное состояние является частичным, то есть оно может не представлять ни одного состояния программы.
Поэтому функция конкретизации, которая предоставляет соответствие между абстрактными состояниями и конкретными, в расширенной теории отличается от классической: она определяется на множестве абстрактных элементов.
Это является следствием того, что полное конкретное состояние может быть получено только из нескольких частичных состояний, описывающих потоки по-отдельности.

Частичными также являются и абстрактные переходы.
Поэтому анализ не может гарантировать, что 
Поэтому анализ не может гарантировать, что последующие конкретные переходы будут достижимы за один шаг оператора transfer.
В общем случае для этого может понадобиться $k$ шагов. Для подхода с отдельным анализом потоков $k=2$: анализ выполняет обычный переход в потоке, а затем распространяет его на все остальные потоки в качестве перехода в окружении. Это требует двух итераций алгоритма.

Определим формально \emph{адаптивный статический анализ с абстрактными переходами} для параллельных программ $\mathbb{D}=(D$, $\Pi$, $\tatarrow$, $merge$, $stop$, $prec$).
Он состоит из абстрактного домена $D$, 
множество точности $\Pi$, 
отношения переходов $\tatarrow$,
оператора слияния $merge$, оператор останова $stop$, функции уточненения $prec$.
Несмотря на то, что сам операторы остались теми же, что и в классической версии теории, они претерпели некоторые изменения.
Эти операторы будут подробно рассмотрены далее.

\begin{itemize}

\item \emph{Абстрактный домен}  $D=(\mathcal{T}, \mathcal{E},\conc{\cdot})$ определяется множеством $\mathcal{T}$ конкретных переходов ($\mathcal{T} \subseteq C \times G \times T$), полурешеткой $\mathcal{E}$ абстрактных переходов и функцией конкретизации $\conc{\cdot}$.
Полурешетка 
$\mathcal{E}=(E, \top, \bot, \sqsubseteq, \sqcup)$ состоит из (возможно, бесконечного) множества $E$ элементов абстрактного домена, верхнего элемента $\top \in E$, нижнего элемента $\bot \in E$, частичного порядка $\sqsubseteq \subseteq E \times E$ и функции $\sqcup:E \times E \rightarrow E$ (оператор объединения состояний).
Функция $\sqcup$ возвращает наименьший элемент решетки, который больше, чем каждый из двух ее аргументов, а символы $\top$ и $\bot$ обозначают наибольший и наименьший элемент решетки $E$ соответственно. 

Функция конкретизации $\conc{\cdot}: 2^E \rightarrow 2^\mathcal{T}$ отображает каждое множество абстрактных переходов $R \subseteq E$ на множество его значений, то есть на множество конкретных состояний программы, которое оно представляет.
Основным отличием от классической функции конкретизации – это определение на множестве абстрактных элементов.
Это объясняется тем, что суммарное знание для множества частичных состояний может быть больше, чем знание для одного частичного состояния, то есть,  
$$\forall R\subseteq E: \conc{R} \supseteq \bigcup_{e\in R}{\conc{\{e\}}}$$

Для корректности анализа программы абстрактный домен должен удовлетворять следующим требованиям:

\begin{equation}
\label{cpa_conc_eq_0}
\forall R \subseteq \overline{R} \subseteq E: \conc{R} \subseteq \conc{\overline R}
\end{equation}

\begin{equation}
\label{cpa_conc_eq_2}
\forall e, e' \in E, R \subseteq E : e \sqsubseteq e' \implies \conc{R \cup e} \subseteq \conc{R \cup e'}
\end{equation}

\item Множество \emph{точности} $\Pi$ определяет уровень детализации абстрактного домена. 
Анализ использует элементы из $\Pi$, чтобы определять различный уровень точности для различных абстрактных элементов.
Пара $(e, \pi)$ называется абстрактным элементом $e$ с точностью $\pi$.
Операторы на абстрактном домене параметризуются уровнем точности.

Для $R \subseteq E \times \Pi$ обозначаем
$\conc{R} = \conc{\bigcup_{(e,\pi)\in R}\{e\}}$.

\item Отношение переходов $\tatarrow: E\times \Pi \times 2^{E\times \Pi} \times E $ определяет для каждого частичного перехода $e$ с точностью $\pi$ и множества достигнутых частичных переходов $\widehat{R}$ следующие возможные абстрактные переходы $e'$.
Будем писать $(e, \pi) \tat{\widehat{R}} e'$, если $(e, \pi, \widehat{R}, e') \in \tatarrow$.

%TODO: do we need g,t on the arrow? 
%and $e \tatarrow (e', \pi)$ if $\exists g \in G, t \in T: e \tat{g,t} (e', \pi)$.

Обозначим $Suc(e, R) = \{e' \mid e \tat{R} e'\}$, то есть состояния достижимые из $e$, а объединение по всем состояниям из R:
$Suc(R) = \bigcup_{e \in R}{Suc(e, R)}$.

Далее нам понадобится требование на $Suc(e, R)$:
\begin{equation}
\label{eq_suc}
\begin{aligned}
& \forall R_1, R_2, \widehat{R} \subseteq E, e \in E:\\
& \conc{R_1} \subseteq \conc{R_2} \implies \conc{Suc(e, R_1) \cup \widehat{R}} \subseteq \conc{Suc(e, R_2) \cup \widehat{R}} 
\end{aligned}
\end{equation}

Обозначим $Reach^k$ как
\begin{equation}
\label{reach_k}
\begin{aligned}
& \forall R \subseteq E: Reach^0(R) = R \\
& \forall k \ge 1: Reach^{k+1}(R) = Suc(Reach^k(R)) \cup Reach^{k}(R) \\
\end{aligned}
\end{equation}

Далее мы будем писать $Reach(R) = Reach^1(R)$. 

% Легко показать следующие утверждения, которые понадобятся в дальнейшем:
% \begin{equation}
% \label{cpa_reach_dist_1}
% \forall k \ge 1, A,B \subseteq E: \\
% Reach^k(A \cup B) =  Reach^k(A) \cup Reach^k(B)
% \end{equation}
%
% \begin{equation}
% \label{cpa_reach_dist_2}
% \forall k \ge 1, A,B \subseteq E, A \subseteq B: \\
% Reach^k(A) \subseteq  Reach^k(B)
% \end{equation}

Требование к отношению переходов в классическом CPA~\cite{Beyer08} является слишком строгим.
В некоторых случаях, в частности, при анализе многопоточных программ, более эффективным является аппроксимировать переходы из $\conc{\widehat{R}}$  в несколько шагов:
\begin{itemize}
\item применение переходов из частичных состояний по отдельности;
\item применение некоторых шагов позже, например, переходов по окружению.
\end{itemize}

Требованием к отношению переходов является аппроксимация сверху множества конкретных переходов:
\begin{equation}
\label{cpa_transfer_eq}
\begin{aligned}
& \exists k \ge 1: \forall R \subseteq E \times \Pi:\\
& \conc{Reach^k(R)} \supseteq \bigcup_{\tau \in \conc{R}}{\{\tau' \mid \tau \tcarrow \tau'\}}  \\
\end{aligned}
\end{equation}

Таким образом, условие~\ref{cpa_transfer_eq} ослабляет требования на оператор $transfer$ по сравнению с классической теорией CPA.
Оно означает, что анализ может получить все конкретные переходы не за один шаг абстрактного перехода, а после $k$ шагов.
Для анализа каждого потока по-отдельности мы далее увидем, что $k=2$.

%--------------------------------

\item Оператор слияния состояний $merge: E \times E \times \Pi \rightarrow E$ ослабляет второй параметр, используя информацию от первого параметра, и возвращает новое абстрактное состояние с точностью, которая передавалась, как третий параметр.
Оператор \emph{merge} должен удовлетворять следующим требованиям:
\begin{equation}
\label{cpa_merge_eq}
\begin{aligned}
&\forall e, e' \in E, \pi \in \Pi : &e' \sqsubseteq merge(e, e', \pi)
\end{aligned}
\end{equation}

\item Оператор останова $stop: E \times 2^{E \times \Pi} \times \Pi \rightarrow \mathbb{B}$ проверяет, является ли абстрактный переход, передаваемый, как первый параметр с точностью, передаваемой как третий параметр, покрытым множеством абстрактных переходов, которые передаются вторым параметром.
%Оператор останова может, например, проходить по элементам из множества $R$, который передается как второй параметр и искать такой элемент, который больше ($\sqsubset$), чем проверяемый элемент.
%, or -- if $D$ is a powerset domain\footnote{A powerset domain is an abstract domain s.t. $\tconc{e \sqcup e'}{t} = \tconc{e}{t} \cup \tconc{e'}{t}$} -- can join the elements of $R$ to check if $R$ subsumes the first parameter. 
Оператор останова должен удовлетворять следующему требованию:
\begin{equation}
\label{cpa_stop_eq}
\begin{aligned}
&\forall e \in E, R \subseteq E, \pi \in \Pi:\\
&stop(e, R, \pi) \implies\forall \hat R \subseteq E: \conc{\{e\}\cup \hat R} \subseteq \conc{R \cup \hat R}
\end{aligned}
\end{equation}

\item Функция настройки точности $prec:E \times \Pi \times 2^{E \times \Pi} \rightarrow E \times \Pi$ вычисляет новое абстрактное состояние и новую точность для данного абстрактного состояния и множества асбтрактных состояний.
Эта функция может производить ослабление абстрактного состояния.
Она должна удовлетворять следующему требованию:

\begin{equation}
\label{cpa_prec_eq}
\begin{aligned}
& \forall e, e' \in E, \pi, \pi' \in \Pi, R \subseteq E \times \Pi:\\
& (e', \pi') = prec(e, \pi, R) \implies e \sqsubseteq e'
\end{aligned}
\end{equation}

\end{itemize}

В целом, множество точности $\Pi$, оператор останова $stop$, оператор объединения $merge$, оператор настройки точности $prec$ остаются такими же, как и в классической теории CPA.

%end of CPA definition
\section{Алгоритм с частичными состояниями}

Алгоритм~\ref{cpata_algorithm_ps} представляет основной алгоритм, который вычисляет множество достижимых абстрактных переходов.
Он также не претерпел никаких изменений относительно классической теории CPA за исключением расширения оператора transfer.
 
\begin{algorithm}
% Plain Algorithm
 \KwData{
 адаптивный статический анализ с частичными состояниями $\mathbb{D}$,
 {начальный абстрактный переход $e_0$ с точностью $\pi_0 \in \Pi$},
 {множество $reached$ элементов из $E \times \Pi$},
 {множество $waitlist$ элементов из $2^{E \times \Pi}$}
 }
\KwResult{множество достижимых состояний $reached$}
 $waitlist := \{(e_0, \pi_0)\}$\;
 $reached := \{(e_0, \pi_0)\}$\;

 \While{$waitlist \neq \emptyset$}{
  pop $(e, \pi)$ from $waitlist$\;  
  \For{$e'$ in $(e, \pi) {\color{blue} \tat{reached}} e')$ }{
   $(\widehat{e}, \widehat{\pi})=prec(e',\pi,reached)$\;
   \For{each $(e'', \pi'') \in reached$}{
    $e_{new} = merge(\widehat{e}, e'', \widehat{\pi})$\;
    \If{$e_{new} \neq e''$}{
     $waitlist := waitlist \setminus \{(e'',\pi'')\} \cup \{(e_{new},\pi'')\}$\;
     $reached := reached \setminus \{(e'',\pi'')\} \cup \{(e_{new},\pi'')\}$\;
    }
   }
   \If{$!stop(\widehat{e}, reached, \widehat{\pi})$}{
    $waitlist := waitlist \cup \{(\widehat{e}, \widehat{\pi})\}$\;
    $reached := reached \cup \{(\widehat{e}, \widehat{\pi})\}$\;
   }
  }
 }%repeat

% Thin about the caption
 \caption{Algorithm $CPA(\mathbb{D}, e_0, \pi_0)$}
 \label{cpata_algorithm_ps}
\end{algorithm} 
 
\begin{thrm}
\label{thrm_soundness}
(Soundness) Для заданного адаптивного статического анализа с частичными состояниями $\mathbb{D}$ и начального абстрактного состояния $e_0$ с точностью $\pi_0$, алгоритм $CPA$ вычисляет множество абстрактных состояний, которое аппроксимирует сверху множество достижимых конкретных состояний:

$$\conc{CPA_{PS}(\mathbb{D}, e_0, \pi_0)} \supseteq Reach_{\tcarrow}(\conc{\{e_0\}})$$

\end{thrm}

Доказательство состоит из двух частей. Сначала доказывается, что алгоритм~\ref{cpata_algorithm_ps_without_waitlist} без использов
ания структуры waitlist аппроксимирует сверху множество достижимых конкретных состояний. Вторым шагом показывается, что алгоритм~\ref{cpata_algorithm_ps} эквивалентен алгоритму~\ref{cpata_algorithm_ps_without_waitlist}.

\begin{algorithm}[H]
% General Algorithm without waitlist
 \KwData{
 адаптивный статический анализ с частичными состояниями $\mathbb{D}$,
 {начальное абстрактное состояние $e_0$ с точностью $\pi_0 \in \Pi$},
 {множество $reached$ из элементов $E \times \Pi$}
 }
\KwResult{множество достижимых абстрактных состояний $reached$}
 $reached := \{e_0,\pi_0\} $\;
 
 \For{each $e \in reached$ }{
  \For{each $e'$: $e \tat{reached} (e', \pi')$ }{
   $(\widehat{e}, \widehat{\pi})=prec(e',\pi',reached)$\;
   \For{each $(e'', \pi'') \in reached$}{
    $e_{new} = merge(\widehat{e}, e'', \widehat{\pi})$\;
    \If{$e_{new} \neq e''$}{
     $reached := reached \setminus{\{(e'', \pi'')\}} \cup \{(e_{new}, \widehat{\pi})\}$\;
    }
   }
   \If{$!stop(\widehat{e}, reached, \widehat{\pi})$}{
    $reached := reached \cup \{(\widehat{e}, \widehat{\pi})\}$\;
   }
  }
 }%repeat

 \caption{$\overline{CPA}(\mathbb{D}, e_0, \pi_0)$}
 \label{cpata_algorithm_ps_without_waitlist}
\end{algorithm}

\begin{proof}
Нужно доказать, что $\conc{\overline{CPA}(\mathbb{D}, e_0, \pi_0)} \supseteq Reach_{\tcarrow}(\conc{\{e_0\}})$.
Определим рекурсивную функцию $\overline{CPA}_n(\mathbb{D}, e_0, \pi_0)$, которая будет вычислять множество достижимых состояний алгоритма на n-той итерации.
 Обозначим ее для краткости $reached_n \equiv \overline{CPA}_n(\mathbb{D}, e_0, \pi_0)$.

 \begin{equation}
 \label{cpa_recursive_algorithm}
 \begin{aligned}
 & reached_0 = \{e_0\} \\
 & s_n = \{e' \mid e \in reached_n \land e \tat{reached_n} e'\} \\
 & s'_n = \{\widehat{e} \mid \widehat{e} = prec(e',\pi',reached_n) \land e' \in s_n\} \\
 & \widehat{s}_n = \{\overline{e} \mid \exists e^1 \in reached_n, \widehat{e} \in s'_n \ldotp \overline{e} = merge(\widehat{e}, e^1, \pi))\} \\
 & \widehat{s}^1_n = reached_n \setminus \widehat{s}_n \\
 & \widehat{s}^2_n = \widehat{s}_n \setminus reached_n \\
 & \tilde{s}_n = \{e \mid e \in s' \land !(stop(e, reached_n, \pi))\} \\
 & reached_{n+1} = reached_n \setminus \widehat{s}^1_n \cup \widehat{s}^2_n \cup \tilde{s}_n = \widehat{s}_n \cup \tilde{s}_n\\
 \end{aligned}
 \end{equation}

Покажем, что 
 \begin{equation}
 \label{algorithm_lemma_1}
 \begin{aligned}
 \conc{reached_{n+1} \cup \hat{R}} \supseteq \conc{Reach(reached_n) \cup \hat{R}} \end{aligned}
 \end{equation}

 \begin{align*}
 & \conc{reach_{n+1} \cup \hat{R}} = (def.) = \conc{reached_n \setminus \widehat{s}^1_n \cup \widehat{s}^2_n \cup \tilde{s}_n \cup \hat{R}} \supseteq \\
 & (eq.~\ref{cpa_conc_eq_2},\ref{cpa_merge_eq}) \supseteq \conc{reached_n  \cup \tilde{s}_n \cup \hat{R}}  
  \supseteq (eq.~\ref{cpa_conc_eq_2},\ref{cpa_stop_eq})\\
  & \supseteq \conc{reached_n  \cup s'_n \cup \hat{R}}  \supseteq (eq.~\ref{cpa_conc_eq_2},\ref{cpa_prec_eq}) \supseteq \conc{reached_n  \cup s_n \cup \hat{R}} =\\
  &= (def.~\ref{reach_k}) = \conc{Reach(reached_n) \cup \hat{R}}
 \end{align*}
 
 Теперь докажем по индукции, что 
 
 \begin{equation}
 \label{algorithm_invariant_1}
 \begin{aligned}
 \forall \hat{R} \in E, k \in \mathbb{N}, \conc{reached_{n+k} \cup \hat{R}} \supseteq \conc{Reach^k(reached_n) \cup \hat{R}}
 \end{aligned}
 \end{equation}
 
 При $k=0$ отношение тривиально: $\conc{reached_n \cup \hat{R}} \supseteq \conc{reached_n \cup \hat{R}}$.
 Пусть теперь инвариант~\ref{algorithm_invariant_1} выполнен при некотором $k$, рассмотрим его при $k+1$:
 \begin{align*}
 & \conc{reach_{n+k+1} \cup \hat{R}} \supseteq (eq.~\ref{algorithm_lemma_1}) \supseteq \conc{Reach(reached_{n+k}) \cup \hat{R}} = \\
 & = (def.) = \conc{reached_{n+k} \cup \{e' \mid e \tat{reached_{n+k}} e' \land e \in reached_{n+k}} \cup \hat{R}\} \\
 & \supseteq (eq.~\ref{algorithm_invariant_1}) \supseteq \conc{Reach^k(reached_n) \cup \\
 & \{e' \mid e \tat{reached_{n+k}} e' \land e \in reached_{n+k}\} \cup \hat{R}} \supseteq (eq.~\ref{eq_suc}) \\
 & \supseteq \conc{Reach^k(reached_n) \cup \{e' \mid e \tat{Reach^k(reached_n)} e' \land e \in Reach^k(reached_n)\} \\ 
 & \cup \hat{R}} = (def.~\ref{reach_k}) = \conc{Reach^{k+1}(reached_n) \cup \hat{R}}
 \end{align*}

Таким образом, мы имеем,
\begin{equation}
 \label{algorithm_invariant_2}
 \begin{aligned}
 \conc{reach_{n+k}} \supseteq \conc{Reach^k(reached_n)} \supseteq (eq.~\ref{cpa_transfer_eq}) \supseteq \bigcup_{\tau \in \conc{reached_n}}{\{\tau' \mid \tau \tcarrow \tau'\}}
 \end{aligned}
 \end{equation}


Когда алгоритм заканчивает свое выполнение (доходит до неподвижной точки) $reached_n = reached_{n+1}$. 
Обозначим финальное множество, как $Reached = lim_{n \rightarrow \infty}(reached_n)$.
Нам остается доказать, что $\bigcup_{\tau \in \conc{Reached}}{\{\tau' \mid \tau \tcarrow \tau'\}} \supseteq Reach_{\tcarrow}(\conc{\{e_0\}})$.


Покажем, что $\forall \{\tau_i\} \in \mathcal{T}: \tau_0 \in \conc{\{e_0\}} \land \forall 1 \leq k \leq N: \tau_{k} \tcarrow \tau_{k+1} \implies \forall 1 \leq k \leq N: \tau_k \in \conc{Reached}$ по индукции.
Алгоритм~\ref{cpata_algorithm_ps_without_waitlist} не удаляет состояния, поэтому $e_0 \in Reached \lor e_0 \sqsubseteq e' \in Reached$.
Таким образом, $ \tau_0 \in \conc{Reached}$, то есть, базис индукции выполнен.
Предположим, что утверждение выполнено для некоторого $n \in \mathbb{N}$:

\begin{align}
& \forall 1 \leq k \leq n: \tau_k \in \conc{Reached} \nonumber \\ 
& \forall \tau \in \conc{Reached}: \{\tau' \mid \tau \tcarrow \tau'\} \subseteq (eq.~\ref{cpa_transfer_eq}) \subseteq \conc{Reach^k(Reached)} = \\
& = \conc{Reached} \implies \tau_{k+1} \in \{\tau' \mid \tau \tcarrow \tau'\} \subseteq \conc{Reached} \nonumber
\end{align}

Так, мы показали, что $\conc{\overline{CPA}(\mathbb{D}, e_0, \pi_0)} \supseteq Reach_{\tcarrow}(\conc{\{e_0\}})$.


Теперь нам нужно показать, что алгоритм использующий очередь состояний ($waitlist$) эквивалентен алгоритму без нее, то есть, что $\forall e \in \overline{CPA}(\mathbb{D}, e_0, \pi_0) \exists e' \in CPA(\mathbb{D}, e_0, \pi_0): e \sqsubseteq e'$.

Заметим, что итерации алгоритмов абсолютно одинаковые, поэтому изменения полученных состояний являются эквивалентными.
Единственным отличием является то, что $CPA(\mathbb{D}, e_0, \pi_0)$ итерируется по очереди состояний, а $\overline{CPA}(\mathbb{D}, e_0, \pi_0)$ -- по всем возможным подмножествам R.
Два алгоритма могут быть синхронизированы следующим образом: они начинают с одного и того же начального множества $reached$. 
Каждая итерация алгоритма $CPA(\mathbb{D}, e_0, \pi_0)$ повторяется алгоритмом $\overline{CPA}(\mathbb{D}, e_0, \pi_0)$. 
Так как они выполняют одинаковые действия и модифицируют множество $reached$ одинаково, получаемое множество $reached$ будет совпадать у обоих алгоритмов.
Когда $CPA(\mathbb{D}, e_0, \pi_0)$ заканчивает выполнение, $\overline{CPA}(\mathbb{D}, e_0, \pi_0)$ продолжает выполнять все оставшиеся итерации.

Теперь нужно показать, что рассмотренных итераций алгоритма $CPA(\mathbb{D}, e_0, \pi_0)$ будет достаточно для построения финального множества $reached$.

По аналогии с предыдущим пунктом нам потребуется рекурсивное определение функций $reached_n$ и $waitlist_n$:
 \begin{equation}
 \label{cpa_recursive_algorithm_2}
 \begin{aligned}
 & reached_0 = \{e_0\} \\
 & waitlist_0 = \{e_0\} \\
 & e_n = get(waitlist_n) \text{ выдает первое состояние в очереди} \\
 & s_n = \{e'_n \mid e_n \tat{reached_n} e'_n\} \\
 & s'_n = \{\widehat{e}_n \mid \widehat{e}_n = prec(e'_n,\pi',reached_n) \land e'_n \in s_n\} \\
 & \widehat{s}_n = \{\overline{e_n} \mid \exists e^1_n \in reached_n, \widehat{e}_n \in s'_n \ldotp \overline{e_n} = merge(\widehat{e}_n, e^1_n, \pi))\} \\
 & \widehat{s}^1_n = reached_n \setminus \widehat{s}_n \\
 & \widehat{s}^2_n = \widehat{s}_n \setminus reached_n \\
 & \tilde{s}_n = \{e_n \mid e_n \in s'_n \land !(stop(e_n, reached_n, \pi))\} \\
 & reached_{n+1} = reached_n \setminus \widehat{s}^1_n \cup \widehat{s}^2_n \cup \tilde{s}_n = \widehat{s}_n \cup \tilde{s}_n\\
 & waitlist_{n+1} = waitlist_n \setminus \{e_n\} \setminus \widehat{s}^1_n \cup \widehat{s}^2_n \cup \tilde{s}_n
 \end{aligned}
 \end{equation}

Докажем следующий инвариант для всех итераций алгоритмов.

\begin{equation}
\label{cpa_algorithm_equivalance_invariant}
\begin{aligned}
& \forall e \in reached_n: \\
& e \in waitlist_n \lor (\forall \widehat{R} \subseteq E : \conc{\{e' \mid e \tat{reached_n} e'\} \cup reached_n \cup \widehat{R}} \subseteq \conc{reached_n \cup \widehat{R}}) 
\end{aligned}
\end{equation}

Этот инвариант означает, что для любого перехода из $reached_n$ либо он находится в $waitlist_n$, либо все следующие переходы тоже находятся в $reached_n$, то есть в процессе анализа переходы не теряются.

Докажем инвариант~\ref{cpa_algorithm_equivalance_invariant} по индукции.
Для начального шага инвариант выполнен: $reached_0 = \{e_0\} \land waitlist_0 = \{e_0\} \implies e_0 \in waitlist_0$.
Пусть теперь инвариант выполнен для некоторой итерации $k$. Рассмотрим следующую итерацию $k+1$ и возьмем случайный переход $e \in reached_{k+1}$.
Возможны четыре варианта:

\begin{enumerate}
\item $e \in (reached_{k+1} \setminus reached_n) \setminus \{e_n\}$. Для этого состояния ничего не меняется, для него был выполнен инвариант на предыдущей итерации, и будет выполнен на этой.
\item $e = e_k$. На прошлой итерации инвариант был выполнен, так как $e_k \in waitlist_k$, но $e_k \notin waitlist_{k+1}$.
По определению $reached_{k+1} = reached_k \setminus \widehat{s}^1_k \cup \widehat{s}^2_k \cup \tilde{s}_k$ и $\conc{reached_{k+1} \cup \widehat{R}} = \conc{reached_k \setminus \widehat{s}^1_k \cup \widehat{s}^2_k \cup \tilde{s}_k \cup \widehat{R}} \supseteq (eq.~\ref{cpa_merge_eq}) \supseteq \conc{reached_k \cup \tilde{s}_k \cup \widehat{R}} \supseteq (eq.~\ref{cpa_stop_eq}) \supseteq \conc{reached_k \cup s'_k \cup \widehat{R}} \supseteq (eq.~\ref{cpa_prec_eq}) \supseteq \conc{reached_k \cup \{e' \mid e \tat{reached_k} e'\} \cup \widehat{R}}$. Откуда следует $\conc{\{e' \mid e \tat{reached_{k+1}} e'\} \cup reached_{k+1} \cup \widehat{R}} \subseteq \conc{reached_{k+1} \cup \widehat{R}})$.
\item $e \in \widehat{s}^2_{k+1}$. По определению $waitlist_{k+1}$ это означает, что $\widehat{s}^2_{k+1} \subseteq waitlist_{k+1} \implies e \in waitlist_{k+1}$. А значит, инвариант выполнен.
\item $e \in \tilde{s}_k$. Опять же, по определению $waitlist_{k+1}$ это означает, что $\tilde{s}_k \subseteq waitlist_{k+1} \implies e \in waitlist_{k+1}$. А значит, инвариант выполнен.
\end{enumerate}

Инвариант~\ref{cpa_algorithm_equivalance_invariant} выполнен на всех итерациях алгоритма $CPA(\mathbb{D}, e_0, \pi_0)$, включая последнюю, в которой $waitlist_k = \emptyset$, $reached_k = Reached$, поэтому $\conc{\{e' \mid e \tat{Reached} e'\} \cup Reached} \subseteq \conc{Reached}$.
Отсюда следует, что все остальные операции алгоритма $\overline{CPA}(\mathbb{D}, e_0, \pi_0)$ являются бесполезными.
Действительно, пусть $\overline{CPA}(\mathbb{D}, e_0, \pi_0)$ нашел переход $e \in Reached: e \tat{Reached} e' \land e' \notin Reached$.
Используя инвариант мы получаем, что $\conc{\{e'\} \cup Reached} \subseteq \conc{Reached}$. 
То есть, этот абстрактный переход не дает новых конкретных переходов.
Отсюда следует, что

$\conc{\overline{CPA}(\mathbb{D}, e_0, \pi_0)} \subseteq (req.~\ref{cpa_conc_eq_2}) \subseteq \conc{CPA(\mathbb{D}, e_0, \pi_0)}$

Мы доказали следующее неравенство:

$$Reach_{\tcarrow}(\conc{\{e_0\}}) \subseteq \conc{\overline{CPA}(\mathbb{D}, e_0, \pi_0)} \subseteq \conc{CPA(\mathbb{D}, e_0, \pi_0)}$$

\end{proof}

\newcommand{\IR}{IR}
\newcommand{\epp}{\mathrel{\bigoplus}}
\newcommand{\conctm}[1]{\conc{#1}_{TM}}

\section{Адаптивный статический анализ с раздельным рассмотрением потоков}
\label{sect_tm_with_io}

\subsection{Основная идея}

\subsection{Формальное описание внутреннего CPA}
 
CPA, реализующий логику анализа с раздельным рассмотрением потоков, требует некоторые дополнительные возможности от вложенных CPA. 
Поэтому прежде, чем формально описывать ThreadModularCPA, опишем расширенные требования ко вложенным CPA.
 
Определение CPA, который может быть использован внутри анализа с раздельным рассмотрением потоков, расширяется доволнительным набором операторов: $\mathbb{I}=(D_{I},$ $\Pi_{I}, \tatarrow_{I},$ $merge_{I}, stop_{I},$ $prec_{I},$ $compatible_{I},$ $\cdot|_p$, $compose_I$).
Кроме того, усиливаются требования к основным операторам.

Абстрактный домен $D_I = (\mathcal{T}_I, \mathcal{E}_I, \epp_I)$ включает в себя множество конкретных переходов $\mathcal{T}_I$, полурешетку абстрактных переходов $\mathcal{E}_I$, а вместо функции конкретизации, в отличие от обычного CPA, используется оператор композиции $\epp_I$.
Это необходимо из-за того, что для подхода с раздельным анализом потоков используется одна общая схема вычисления конкретных состояний, которая основана на этом операторе композиции. 
Поэтому от вложенных CPA требуется только определить оператор композиции.

Как было уже сказано, состояния и переходы являются частичными, поэтому они могут не соответствовать напрямую конкретным состояниям и переходам. Чтобы получить полный переход, нужно взять композицию множества частичных переходов, которые соответствуют всем доступным потокам. Совместные частичные переходы могут быть объединены в полный конкретный переход с помощью оператора композиции $\epp: E \times T \times 2^{E \times T} \to 2^{\mathcal{T}}$.
Он возвращает множество конкретных переходов, которое соответствует данным частичным переходам.

Основное требование к оператору $\epp_I$ должен соответствовать полурешетке. Так, если один из абстрактных переходов меньше, чем другой, то композиция с тем же множеством не должна получить большее множество конкретных переходов. 


\begin{equation}
\label{cpa_tm_epp_req_1}
\begin{aligned}
& \forall e \sqsubseteq e' \in E, e_1, \dots e_n \in E, t_0,t_1,\dots,t_n \in T, t_i \neq t_j : \\
& \epp_I
\left(
\begin{pmatrix}
e \\
t_0 
\end{pmatrix} ,
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix} ,
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)
\subseteq \\
&\epp_I
\left(
\begin{pmatrix}
e' \\
t_0 
\end{pmatrix} ,
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)
\end{aligned}
\end{equation}

И симметричное требование для второго аргумента:

\begin{equation}
\label{cpa_tm_epp_req_2}
\begin{aligned}
& \forall e \sqsubseteq e' \in E, e_1, \dots e_n \in E, t_0,t_1,\dots,t_n \in T, t_i \neq t_j : \\
& \epp_I
\left(
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix} ,
\left\{
\begin{pmatrix}
e \\
t_0 
\end{pmatrix} ,
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)
\subseteq \\
&\epp_I
\left(
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix} ,
\left\{
\begin{pmatrix}
e' \\
t_0 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)
\end{aligned}
\end{equation}

Оператор проверки совместности $compatible_I: E \times E \rightarrow \{true, false\}$ проверяет, могут ли два частичных перехода начинаться из общего полного родительского состояния. 

Оператор проекции $\cdot|_p: E \rightarrow E$ проецирует переход в потоке на другой поток. Например, проекция может содержать модификации глобальных переменных, но опускать изменения локальных данных для потока.

$compose_I: E \times E \rightarrow E$ объединяет два абстрактных перехода в один. Он применяет абстрактную дугу из одного перехода к абстрактному состоянию другого перехода. 

В дальнейшем мы будем использовать оператор $apply_I$, как комбинацию трех операторов: $\cdot|_p$, $compose_I$ и $compatible_I$::

\begin{equation}
\label{apply_function}
\begin{aligned}
\forall e, e' \in E: apply(e, e') = 
\begin{cases}
compose_{I}(e, e'|_p), &\mbox{ если } compatible_I(e, e'|_p) \\
\bot, & \mbox{ иначе}
\end{cases}
\end{aligned}
\end{equation}

Таким образом, оператор $apply$ означает, что переходы могут быть объединены только если они совместны. Результатом применения оператора является новый переход, который будем называть переходом в окружении, так как он представляет собой эффект окружения.

Оператор $apply$ связан с оператором $transfer_I$, поэтому отдельного условия на него нет.
Тем не менее, в дальнейшем будет описано явное условие~\ref{cpa_transfer_tm_req}, связывающее операторы $apply$ и $transfer_I$.
%Требование~\ref{cpa_transfer_tm_req} является более строгим и влечет за собой выполнение~\ref{cpa_transfer_eq}.
Таким образом, CPA удовлетворяют общим условиям.


\subsection{Формальное описание ThreadModularCPA}

Определим специальный CPA, который реализует логику отдельного анализа потоков: $\mathbb{TM}=(D_{TM}, \Pi_{TM}, \tatarrow_{TM}, merge_{TM}, stop_{TM}, prec_{TM})$, который основан на внутреннем CPA $\mathbb{I}=(D_{I}, \Pi_{I}, \tatarrow_{I}, merge_{I}, stop_{I}, prec_{I}, compatible_{I},$ $\cdot|_p,$ $compose_I$).

\begin{enumerate}

\item Абстрактный домен $D_{TM}=(\mathcal{T}, \mathcal{E}, \conctm{\cdot})$.

Полурешетка $\mathcal{E}=\mathcal{E}_I$ эквивалентна полурешетке внутреннего анализа.
Функция конкретизации $\conc{\cdot}$ выражается через оператор композиции:

\begin{equation}
\label{cpa_conc_tm_def}
\begin{aligned}
& \forall R \subseteq E: \conctm{R} = \\ & \bigcup_{k=1}^{\infty}{ 
\bigcup_{
\begin{array}{c}
e_0, e_1,\dots,e_k \in R \\
t_0, t_1,\dots,t_k \in T
\end{array}
} {
\epp_I
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_k \\
t_k 
\end{pmatrix}
\right\}
\right)
}
}
\end{aligned}
\end{equation}

Таким образом, множество конкретных состояний получается композицией всех возможных подмножеств из частичных состояний.
Такое определение необходимо для потенциально бесконечных конкретных состояний, которые успешно поддерживаются с помощью конечных абстрактных состояний.
%Such complicated definition is needed for potentially infinite concrete states, which are successfully hold with finite abstract states. Do not replace with sets!
Покажем, что при выполнении~\ref{cpa_tm_epp_req_1},~\ref{cpa_tm_epp_req_2} требования \ref{cpa_conc_eq_0}, \ref{cpa_conc_eq_2} выполнены.

\begin{proof}

Предположим, что $R \subseteq R' \subseteq E$

\begin{align*}
\conctm{R} = \bigcup_{k}{
\bigcup_{
\begin{array}{c}
e_0, \dots,e_k \in R \\
t_0, \dots,t_k \in T
\end{array}
}{ 
\epp_I
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_k \\
t_k 
\end{pmatrix}
\right\}
\right)
}
} \subseteq  \\
\subseteq \bigcup_{k}{
\bigcup_{
\begin{array}{c}
e_0, \dots,e_k \in \overline{R} \\
t_0, \dots,t_k \in T
\end{array}
\epp_I
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_k \\
t_k 
\end{pmatrix}
\right\}
\right) 
}
} = \conctm{R'} 
\end{align*}

Теперь предположим, что $e \sqsubseteq e' \in E, R \subseteq E$
\begin{align*}
& \conctm{R \cup \{e\}} = \\
& \bigcup_{k}{
\bigcup_{
\begin{array}{c}
e_0, \dots,e_k \in R \cup \{e\} \\
t_0, \dots,t_k \in T
\end{array}
}{ 
\epp_I
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_k \\
t_k 
\end{pmatrix}
\right\}
\right)
}
} \subseteq \\
& \subseteq (req.~\ref{cpa_tm_epp_req_1},~\ref{cpa_tm_epp_req_2}) \subseteq \\
& \subseteq \bigcup_{k}{
\bigcup_{
\begin{array}{c}
e_0, \dots,e_k \in R \cup \{e'\} \\
t_0, \dots,t_k \in T
\end{array}
}{ 
\epp_I
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_k \\
t_k 
\end{pmatrix}
\right\}
\right)
}
} = \\
& = \conctm{R \cup \{e'\}}
\end{align*}
\end{proof}

\item Отношение переходов определяет следующие переходы, после чего применяет все достигнутые переходы, как переходы в окружении, к новым переходам, а новые переходы, как переходы в окружении, -- к уже достижимым.

\begin{algorithm}
% Thread-modular transfer 
 \KwData{
 {начальный переход $e_0$ с точностью $\pi_0 \in \Pi$}
 }
\KwResult{множество следующих переходов $result$}
 $result := \emptyset$ \;
 
 \For{each $\widehat{e} : e_0 \tat{R}_{I} \widehat{e}$ }{
  $result := result \cup \{\widehat{e}\}$ \;
  
  \For {each $e' \in reached$} {
    $result := result \cup \{apply(e', \widehat{e})\}$ \;
    $result := result \cup \{apply(\widehat{e}, e')\}$ \;
  }
  
 }%repeat
  \Return result

 \caption{$transfer_{TM}(e_0, \pi_0, reached)$}
 \label{cpata_transfer}
\end{algorithm}

Нужно доказать, что такой оператор $transfer$ удовлетворяет условию~\ref{cpa_transfer_eq}.
Для этого нам потребуется более сложное условие, связывающее операторы внутреннего CPA~\ref{cpa_transfer_inner_req}:

\begin{equation}
\begin{aligned}
\label{cpa_transfer_inner_req}
& \forall \tau, \tau' \in \mathcal{T}, R \subseteq E: \tau \tcarrow \tau', \forall e_0, e_1, \dots, e_n \in R: e_i = (s_i, q_i) \\
& \left(
\begin{array}{ll}
& \exists t_0, t_1, \dots, t_n \in T, t_i \neq t_j, t_0 = t \\
& \tau \in \epp_I
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix} ,
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)
\end{array}
\right) \Rightarrow \\
& \left[ \begin{array}{ll}
\lor q_0 & \neq thread\_create \land \\
& \exists e'_0, e'_1, \dots, e'_n \in E, \forall 1 \leq i \leq n: e_i \tat{R} e'_i: \\
& \exists 1 \le k \le n: t_k = t' \land \\
& \tau' \in \epp_I((e_k', t_k), \{(\tilde{e}_i, t_i) \mid \tilde{e}_i = apply(e_i', e'_k) \land i \neq k)\}) \\
\lor q_0 & = thread\_create \land \\
& \exists e'_0, e'_1, \dots, e'_{n+1} \in E, \forall 1 \leq i \leq n: e_i \tat{R} e'_i \land e_0 \tat{R} e'_{n+1}: \\
& \exists 1 \le k \le n + 1: t_k = t' \land \\
& \tau' \in \epp_I((e_k', t_k), \{(\tilde{e}_i, t_i) \mid \tilde{e}_i = apply(e_i', e'_k) \land i \neq k)\}) 
\end{array} 
\right.
\end{aligned}
\end{equation}

\begin{proof}
Действительно, рассмотрим случайный переход $\tau \tcarrow \tau'$, $\tau \in \conc{R}$.
Нужно показать, что $\exists k: tau' \in Reach^k(R)$.
Так как $\tau \in \conc{R}$ по определению $\conc{R}$~\ref{cpa_conc_tm_def} это означает, что $\exists t, t_1, \dots, t_n \in T, t_i \neq t_j, e_0, e_1, \dots, e_n \in R:$\\
$\tau \in \epp_I
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix} ,
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)$.

По условию на внутренние операторы~\ref{cpa_transfer_inner_req} это означает, что найдутся такие элементы $e'_0, e'_1, \dots, e'_n \in E$, которые могут быть получены за два шага: 
\begin{enumerate}
\item применение оператора $transfer$ и оператора $apply$ для перехода в текущем потоке;
\item применение оператора $transfer$ к переходам в окружении, которые были получены на предудыщем шаге с помощью оператора $apply$.
\end{enumerate}
\end{proof}
И для этих элементов $e'_0, e'_1, \dots, e'_n$ будет выполнено $\tau' \in \epp_I((e_i', t_i), \{(e_0', t_0), \dots, (e_n', t_n)\})$.
То есть, показано, что $\exists k=2: \tau' \in Reach^k(R)$.

\item $\Pi_{TM} = \Pi_{I}$
\item $merge_{TM} = merge_{I}$.
\item $stop_{TM} = stop_{I}$.
\item $prec_{TM} = prec_{I}$.

Для операторов $merge$, $stop$, $prec$ требования для внутреннего анализа совпадают с требованиями~\ref{cpa_merge_eq},~\ref{cpa_stop_eq},~\ref{cpa_prec_eq}.
\end{enumerate}

\subsection{Использование явного вида переходов}
\label{subsect_transitions}

Описанный в предыдущих разделах вариант анализа является достаточно общим. 
В различных CPA, применяемых на практике, вид абстрактного перехода зачастую может быть явно разделен на абстрактное состояние и на абстрактную дугу.
В этом случае, можно упростить описание этого анализа, используя явное разделение перехода на две части, каждая из которых отображается на свои подмножества конкретных элементов.
В этом разделе опишем общие свойства для такого варианта CPA, чтобы в дальнейшем не повторять их для каждого варианта анализа.

Итак, предположим, что полурешетка конкретных переходов $\mathcal{E}_I$ состоит из двух частей: $\mathcal{E}_I = \mathcal{E}^S_I \times \mathcal{E}^E_I$.
Это означает, что множество элементов также состоит из двух частей $E_I = E^S_I \times E^E_I$, $\top_I = \{\top^S_I, \top^E_I\}$, $\bot_I = \{\bot^S_I, \bot^E_I\}$, а все операторы получаются такой же композицией:\\
$\forall e, e' \in E_I, e = (s, q), e \sqsubseteq e' \iff (s \sqsubseteq s' \land q \sqsubseteq q')$, \\
$\forall e_1, e_2, e \in E_I, e = (s, q), e = e_1 \sqcup e_2 \iff (s = s_1 \sqcup s_2 \land q = q_1 \sqcup q_2)$.

Таким образом, имеют место две независимые решетки: над состояниями и над дугами.

Кроме того, множество абстрактных дуг почти всегда включает в себя конкретные дуги $g \in G$. 
То есть, $E^E_I = G \cup \mathcal{G}$, где $\mathcal{G}$ и есть множество абстрактных дуг (включая $\bot^E_I$).
При этом, для абстрактных дуг можно представить аналог конкретизации для состояний: $||\cdot||_I : E^E_I \to 2^G$.
Для корректности, должно быть обеспечены следующие условия:

\begin{equation}
\label{conc_edge_eq_1}
\begin{aligned}
\forall e, e' \in E^E_I: e \sqsubseteq e' \implies ||e||_I \subseteq ||e'||_I
\end{aligned}
\end{equation}

\begin{equation}
\label{conc_edge_eq_2}
\begin{aligned}
\forall q \in \mathcal{G}, g \in G: g \in ||q|| \implies g \sqsubseteq^E_I q
\end{aligned}
\end{equation}


Для оператора композиции $\epp_I$ почти всегда требуется вспомогательный предикат для определение совместности множества переходов $check_C: 2^{E_I} \to \mathbb{B}$, то есть могут ли указанные частичные переходы составить один глобальный переход.
Не путать с оператором $compatible_I$, который проверяет возможность того, что два различных перехода могут \textit{начинаться} из одного состояния.
Этот оператор $check_C$ может проверять соответствие перехода состоянию, то есть для некоторых типов анализа он не может быть разбит на два оператора, определенных на множестве состояний и на множестве переходов.
Тем не менее, оператор $\epp_I$ может быть представлен в виде композиции:

\begin{equation}
\label{epp_split}
\begin{aligned}
& \forall e_1, \dots, e_n \in E_I, e_i=(s_i,q_i): \\
& \epp_I
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right) = \\
& =
\begin{cases}
& \left\lbrace 
(c, g, t_0) \in \mathcal{T}
\left| 
\begin{array}{c}
c \in \epp^S_I
\left(
\begin{pmatrix}
s_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
s_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
s_n \\
t_n 
\end{pmatrix}
\right\}
\right) \\
g \in ||q_0||_I \cap ||q_1||_I \cap \dots \cap ||q_n||_I\})
\end{array}
\right.
\right\rbrace,\\
& \hspace{1cm} \mbox{if } check_C(e_0, \{e_1, \dots, e_n\})\\
& \emptyset \mbox{, otherwise}
\end{cases}
\end{aligned}
\end{equation}

При этом $\epp^S_I$ должен удовлетворять похожим условиям(\ref{cpa_tm_epp_req_1},~\ref{cpa_tm_epp_req_2}):

\begin{equation}
\label{cpa_tm_epp_split_req_1}
\begin{aligned}
& \forall s \sqsubseteq s' \in E^S_I, s_1, \dots s_n \in E^S_I, t_0,t_1,\dots,t_n \in T, t_i \neq t_j : \\
& \epp^S_I
\left(
\begin{pmatrix}
e \\
t_0 
\end{pmatrix} ,
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix} ,
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)
\subseteq \\
&\epp^S_I
\left(
\begin{pmatrix}
e' \\
t_0 
\end{pmatrix} ,
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)
\end{aligned}
\end{equation}

И симметричное требование для второго аргумента:

\begin{equation}
\label{cpa_tm_epp_split_req_2}
\begin{aligned}
& \forall s \sqsubseteq s' \in E^S_I, s_1, \dots s_n \in E^S_I, t_0,t_1,\dots,t_n \in T, t_i \neq t_j : \\
& \epp^S_I
\left(
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix} ,
\left\{
\begin{pmatrix}
e \\
t_0 
\end{pmatrix} ,
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)
\subseteq \\
&\epp^S_I
\left(
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix} ,
\left\{
\begin{pmatrix}
e' \\
t_0 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)
\end{aligned}
\end{equation}

Из условий~\ref{conc_edge_eq_1},~\ref{conc_edge_eq_2},~\ref{cpa_tm_epp_split_req_1},~\ref{cpa_tm_epp_split_req_2} следуют условия~\ref{cpa_tm_epp_req_1},~\ref{cpa_tm_epp_req_2}, так как множества конкретных состояний и абстрактных дуг только расширяются.

Нужно отметить, что разбить оператор $\epp^S_I$ по аналогии с оператором $\epp^E_I$ невозможно, так как уже существуют варианты анализа, которые используют иформацию о других частичных состояниях. 
Хотя таких видов анализа очень мало. 

Как уже было упомянуто, вспомогательный оператор $check_C$ в общем случае не может быть разбит на две части, однако, часто он может быть представлен через оператор проекции следующим образом: 

\begin{equation}
\label{default_check_c_def}
\begin{aligned}
& \forall e_1, \dots, e_n \in E_I, e_i=(s_i,q_i): \\
& check_C(e_0, \{e_1, \dots, e_n\}) = \\
& check^S_C(s_0, \{s_1, \dots, s_n\}) \land (\forall 1 \le i \le n, e_0|_p = (\overline{s}, \overline{q}), \overline{q} \sqsubseteq q_i)
\end{aligned}
\end{equation}

Представление~\ref{check_c_def} означает, что анализ не отслеживает соответствие состояний переходам. 
В этом случае, состояния должны быть совместными, а от абстрактных дуг требуется, чтобы переходы в окружении соответствовали исходному переходу в потоке. 

Если переход разбивается на две части, то оператор $compose_I$ становится тривиальным:
\begin{equation}
\label{default_compose_def}
\begin{aligned}
\forall e, e' \in E_I, e = (s, q), e' = (s', q'): compose_I(e, e') = \tilde{e} = (s, q')
\end{aligned}
\end{equation}

Оператор $compatible_I$ проверяет возможность параллельного выполнения различных переходов из частичных состояний, поэтому обычно имеет место такое выражение:

\begin{equation}
\label{default_compatible_def}
\begin{aligned}
\forall e, e' \in E_I, e = (s, q), e' = (s', q'): compatible_I(e, e') = check^S_C(s, {s'})
\end{aligned}
\end{equation}


\subsection{Анализ, инвариантный к эффектам окружения}

Анализ $\mathbb{I}$ будем называть инвариантным к эффектам окружения, если $\forall e, e' \in E, R \subseteq E, \widehat{e} = apply_I(e, e'): \widehat{e} = \bot \lor \widehat{e} \tat{R} e$.
То есть, никакие переходы, полученные применением эффектов окружения (проекций) не могут изменить текущего состояния (перехода). 
В этом случае применение эффектов окружения является бессмысленным.

Нужно заметить, что такой анализ не сводится к классическому анализу, так как по-прежнему $\forall R\subseteq E_C: \conc{R}_R \neq \bigcup_{e\in R}{\conc{e}_C}$.
Кроме того, часто может быть определен нетривиальный оператор $compatible^{I}$ внутри оператора $apply_I$. 
Это означает, что несмотря на то, что эффектны окружения этого вида анализа не могут изменить его состояние, сам он способен влиять на применение эффектов окружения на другие типы анализов, которые не являются инвариантными к эффектам окружения.

Если все используемые при анализе программы виды анализа инвариантны к эффектам окружения, это позволяет значительно повысить скорость работы, за счет применения только переходов в потоке.
При этом, как правило, теряется точность анализа, так как анализ полностью абстрагируется от поведения других потоков.

\section{Анализ с раздельным рассмотрением потоков без абстракции}

В этом разделе покажем, что в представленную теорию укладывается классический алгоритм проверки моделей, описанный в~\cite{ThreadModular03}.

Определим анализ с раздельным рассмотрением потоков с эффектами окружения, как
$\mathbb{Q}=(D_{Q}, \Pi_{Q}, \tatarrow_{Q}, merge_{Q}, stop_{Q}, prec_{Q}, compatible_{Q}, \cdot|_p, compose_Q)$.

Также как и в алгоритме~\cite{ThreadModular03} применение анализа возможно только к программам с ограниченным количеством точек создания потоков. Далее предполагаем, что программа имеет ограниченное количество потоков, которые отличаются точками в программе, обозначающих начало потока, например, для $thread\_create(pc_\nu)$ будет всегда создан поток с идентификатором $pc_\nu$.

% В анализе можно выделить отдельные элементы: абстрактные состояния и абстрактные дуги, поэтому при описании будет использовано описания подраздела~\ref{subsect_transitions}.

\begin{enumerate}

\item $D_Q=(\mathcal{T}_Q, \mathcal{E}_Q, \epp_Q)$.

$\mathcal{T}_Q=C \times G \times T$ -- все конкретные переходы программы.

$\mathcal{E}_Q=(E_Q, \top^E_Q, \bot^E_Q, \sqsubseteq^E_Q, \sqcup^E_Q)$ определен над $E_Q=\mathcal{R} \times T \times (G \cup \mathcal{G})$, где
$\mathcal{R}$ множество всех проекций конкретных состояний на некоторый поток:
$\mathcal{R} \subseteq T\times L\times C^{local} \times c_g \times c_s$, а 
$\mathcal{G}$ содержит эффекты окружения на глобальные части состояния
$\mathcal{G} \subseteq c_g \times c_s \times c_g \times c_s$.

Отметим, что кодирование элементов анализа было максимально приближено к оригинальному, описанному в статье~\cite{ThreadModular03}.
И в отдельных случаях кодирование может быть избыточно.

Для переходов определим дополнительный оператор, проверяющий, могут ли указанные частичные переходы образовывать глобальный переход:

\begin{equation}
\label{check_tm_na_def}
\begin{aligned}
& \forall e_0, \dots, e_n \in E_Q, e_i = (s_i, t_i, q_i), s_i=(\widehat{t_i},pc_i,l_i,gl_i,cs_i), t_i, \widehat{t_i} \in T\\
& check_C(e_0, \{e_1, \dots, e_n\}) = \\
& \forall 1 \le i \le n: t_i = t_0 \land \widehat{t_i} \ne \widehat{t_k} \land gl_i=gl_k \land cs_i=cs_k  \land \\
& e_0|_p = (s_p, t_p, q_p), q_p = q_i
\end{aligned}
\end{equation}

Для совместных переходов $e_1,\dots,e_n$ можно определить $\widehat{gl}=gl_i=gl_k$ и $\widehat{s}=s_i=s_k$.
Оператор композиции $\epp_Q$ можно определить с помощью оператора~\ref{check_tm_na_def}.

\begin{equation}
\label{epp_tm_na}
\begin{aligned}
& \forall e_0, \dots, e_n \in E_Q, t_i \in T, e_i = (s_i, t_i, q_i), s_i=(\widehat{t_i},pc_i,l_i,gl_i,cs_i)\\
& \epp_Q
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_k \\
t_k 
\end{pmatrix}
\right\}
\right) = \\
&\begin{cases}
&\left\lbrace\left(
\begin{array}{cc}
& (c, g, t_0) \in \mathcal{T} \\
& c = (c_{pc},c_l,c_g,c_s)
\end{array}
\left| 
\begin{array}{c}
\{t_0 \to pc_0,\dots,t_j \to pc_j\},\\
\{t_0\to l_0, \dots, t_j\to l_j\},\\
\hat{gl}, \hat s \\
g \in q_0
\end{array}
\right.
\right)\right\rbrace \\& \hspace*{1cm} \text{, if }check_C(\{e_0,\dots,e_j\}) \\
& \emptyset \text{, otherwise}
\end{cases}
\\
\end{aligned}
\end{equation}

$\sqsubseteq_Q, \sqcup_Q$ определены как равенство соответствующих элементов, то есть 
$e_1 \sqsubseteq^E_Q e_2 \iff e_1 = e_2$, а $e_1 \neq e_2 \iff e_1 \sqcup_Q e_2 = \top^E$.
Таким образом, основные требования~\ref{cpa_tm_epp_req_1},~\ref{cpa_tm_epp_req_2} на $\epp_Q$ выполнены.

\item $\Pi_Q = \{\emptyset\}$ содержит один элемент, так как анализ не использует абстракцию.

\item
Отношение переходов $\tatarrow_Q$ содержит переход $e \tat{R}_Q (e', \pi)$, $e=(s, t, q)$ если
\begin{itemize}
\item $q \in G$ и есть переход на проекциях. Пусть
$s=(t, pc, l, gl, cs)$ и есть
\begin{itemize}
\item $(\{t\to pc\}, \{t\to l\}, gl, s) \tc{g,t} (\{t\to pc'\}, \{t\to l'\}, gl', cs'))$, где $g \ne thread\_create$, тогда 
следующее состояние $s' = (t,pc',l', gl',cs')$.
\item или в случае $q=thread\_create(pc_\nu)$, $\nu=pc_\nu$, \\
$(\{t\to pc\}, \{t\to l\}, gl, cs) \tc{thread\_create(pc_\nu), t} (\{t\to pc', \nu \to pc_\nu\}, \{t\to l,\nu \to l\}, gl, cs))$, тогда 
следующее состояние либо $e' = (t,pc',gl,s)$, либо $e' = (\nu,pc_\nu,gl,s)\}$ (новый поток).
\end{itemize}
\item $q=(gl, cs, gl'',cs'') \in \mathcal{G}$, $s=(t, pc, l, gl, cs)$. Тогда следующее состояние $e'=(t, pc, l, gl'', cs'')$.
\end{itemize}

Теперь нужно доказать условие~\ref{cpa_transfer_inner_req}, связывающее операторы $transfer$, $\epp$ и $apply$.
\begin{proof}

Рассмотрим случайный переход $\tau \tcarrow \tau'$, где $\tau=(c,t,g), \tau' = (c',t',g')$ и предположим, что 
$\exists t_0, t_1, \dots, t_n \in T, t_i \neq t_j$ \\
$\tau \in \epp_I((e_0,t_0), \{(e_1,t_1), \dots, (e_n, t_n)\})$.
По определению~\ref{epp_tm_na} это означает, что $s_i = (t_i, c(t_i),c_l(t_i), c_g,c_s)$. 
По определению $\tatarrow_Q$ существует состояние $s_0' = (t_0, c'(t_0),c_l'(t_0), c'_g,c'_s)$.
% Кроме того, переход e'_0 может быть спроецирован: $e'_0|_p = e'_p = (s, t, (gl', s', gl'', s''))$.
Так как $\{e_i\}$ были совместны  (оператор $check_C(\{e_0,\dots,e_n\})$, это означает, что все переходы в окружении соответствует переходу: $\forall 1 \le i \le n: q_i = (gl, s, gl', s')$.
Таким образом, следующие состояния имеют вид $e_i \tatarrow e'_i$, $e'_i = (s'_i, t_i, q'_i)$, где $s'_i = (t_i, c(t_i),c_l(t_i), c'_g,c'_s)$.
То есть, глобальные части других частичных состояний меняются в соответствии с переходом в основном потоке.
При этом по определению $\tatarrow_Q$, который выдает все возможные переходы, $\exists 0 \le k \le n: g' = q'_k$, то есть новый переход в потоке должен содержатся среди полученных после переходов в окружении. 
Зафиксируем это значение $k$ и рассмотрим проекцию этого нового перехода в потоке: $e'_k|_p = e'_p = (s'_k, t_k, (gl', s', gl'', cs'')) $.
Глобальное часть состояний $s'_i$ была получена с помощью одинакового перехода, поэтому она удовлетворяет условию совместности $compatible_Q$. 
Поэтому можно применить оператор $apply$ $\forall 0 \le i \le n, i \neq k: \tilde{e_i} = apply(e'_i, e'_p) = (s'_i, t_i, (gl', s', gl'', cs''))$.
И тогда, состояния $e'_k, \tilde{e'_0}, \dots, \tilde{e'_{k-1}}, \tilde{e'_{k+1}}, \dots, \tilde{e'_n}$ удовлетворяют условию $check_C$. 
А значит, могут быть объединены в глобальный переход оператором $\epp$, при этом $\tau'$ будет в этом множестве по его построению.

В доказательстве опущен второй случай с операцией создания потока thread\_create. 
Рассуждения полностью повторяют описанные выше с той лишь поправкой, что они проводятся для $n+1$ элемента.
\end{proof}

\item
$merge_Q(e_1,e_2,R) = e_2$.
Данный оператор очевидно удовлетворяет условию~\ref{cpa_merge_eq}.

\item
$stop_Q(e,R,\pi)=\exists e' \in R: e \sqsubseteq e'$.
Данный оператор очевидно удовлетворяет условию~\ref{cpa_stop_eq}.

\item
$prec_Q(e,\pi)=(e,\pi)$ (точность и состояние никогда не изменяются).
Данный оператор очевидно удовлетворяет условию~\ref{cpa_prec_eq}.

\item 
$compose_Q(e,e')=\tilde{e} = (s, t, g')$.

\item 
$e|_p = e' = (s, t, (gl, s, gl', s'))$.

\item
$compatible_Q: E_Q \times E_Q \to \mathbb{B}$ определяется, как равенство глобальных частей состояний, $compatible_Q(e,i)$ для $e=(t,pc, l, gl,s)$ и $e'=(t',gl',s',gl'',s'')$ есть    
$\forall \tau, \tau' \in E_Q, \tau_i = (e_i, t_i, q_i), e_i=(t_i,pc_i, l_i, gl_i,s_i)$ \\
$compatible_Q(\tau, \tau') = (gl=gl' \land s=s')$

\end{enumerate}

\section{Композиция различных видов анализа}
\label{sect_composite_analysis}

Композиция различных типов анализа принципиально важна для объединения различных техник в одном алгоритме.
Этот CPA содержит в себе различные внутренние CPA, в которых переходы выполняются параллельно.
Таким образом, вычисляется абстракция сразу для нескольких типов анализа, что позволяет значительно увеличить точность.

Пусть есть несколько различных видов анализа с раздельным рассмотрением потоков: $\Delta_1, \dots, \Delta_n$. 
Композиция различных видов анализа может быть представлена, как отдельный анализ $\mathscr{C}=(D_{\mathscr{C}},$ $\Pi_{\mathscr{C}}, \tatarrow_{\mathscr{C}},$ $merge_{\mathscr{C}}, stop_{\mathscr{C}},$ $prec_{\mathscr{C}},$ $\cdot|_p$, $compose_{\mathscr{C}}$, $compatible_{\mathscr{C}}$).
Каждый $\Delta_i$ реализует отдельный вид анализа. 
$\Delta_i=(D_{\Delta_i},$ $\Pi_{\Delta_i}, \tatarrow_{\Delta_i},$ $merge^E_{\Delta_i}, stop^E_{\Delta_i},$ $prec^E_{\Delta_i},$ $\cdot|_{\Delta_i}$, $compose_{\Delta_i}$, $compatible_{\Delta_i}$)

\begin{itemize}

\item  $D_{\mathscr{C}} = D_{\Delta_1} \times \dots \times D_{\Delta_n}$

Это означает, что $\mathcal{T} = C \times G \times T$, $\mathcal{E}_{\mathscr{C}} = \mathcal{E}_{\Delta_1} \times \dots \times \mathcal{E}_{\Delta_n}$.
%$compatible_{\mathscr{C}}(e_1,\dots, e_m) = 
%compatible_1(e_1^1,\dots, e_m^1) \land \dots \land compatible_n(e_1^n,\dots, e_m^n)$

\begin{equation}
\label{composite_epp_def}
\begin{aligned}
& \epp_{\mathscr{C}}
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right) = \\
& \hspace{1cm} \epp_{\Delta_1}
\left(
\begin{pmatrix}
e^1_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e^1_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e^1_m \\
t_m 
\end{pmatrix}
\right\}
\right) \cap \dots \\
& \hspace{1cm} \dots \cap 
\epp_{\Delta_n}
\left(
\begin{pmatrix}
e^n_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e^n_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e^n_m \\
t_m 
\end{pmatrix}
\right\}
\right)  
\end{aligned}
\end{equation}

Из выполнимости условий~\ref{cpa_tm_epp_req_1},~\ref{cpa_tm_epp_req_2} для вложенных $\Delta_i$ следует выполнимость условий для $\mathscr{C}$, так как пересечение более широких множеств не может быть меньше, чем пересечение исходных множеств.

\item  $\Pi_{\mathscr{C}} = \Pi_{\Delta_1} \times \dots \times \Pi_{\Delta_n}$

\item 
Внутренние элементы $\Delta$ работают с графом потока управления, с двумя дополнительными операциями:~\footnote{Заметим, что в реализации \cpachecker уже присутствуют две дуги в ГПУ для каждого вызова функции: function summary и function entry. Поэтому вызов функции $thread\_create$ не требует изменений в ГПУ с точки зрения реализации.}
\begin{enumerate}
\item $tc_{parent}$ представляет действие $thread\_create$ в родительском потоке, а
\item $tc_{child}$ представляет действие $thread\_create$ в дочернем потоке.
\end{enumerate}

Для отношения переходов в композиции
$e \tat{R}_{\mathscr{C}} (e',\pi')$, где $e = (e_1, \dots, e_n), e_i = (s_i, q_i), q_i \in G, q_i=(l,op,l')$.

\begin{itemize}
\item если $op=thread\_create(l_\nu)$, то рассматриваются два перехода в родительском и в дочернем потоке
\begin{enumerate}
\item $(s_j, (l, tc_{parent}, l')) \tat{R}_{\Delta_j} (e_j',\pi')$,
\item $(s_j, (l, tc_{child}, l')) \tat{R}_{\Delta_j} (e_j',\pi')$.
\end{enumerate}
\item иначе, $e_j \tat{R}_{\Delta_j} (e_j',\pi')$.
\end{itemize}

Комбинация полученных $e_j$ в один переход CompositeCPA напрямую $e' = (e_1', \dots, e_n')$ является корректным, однако недостаточно точным для использования на практике. 
Один из внутренних CPA может получить более точную абстракцию, но за счет декартова произведения с другими анализами, он потеряет эту информацию. 
В частности, это важно для определения следующей дуги. Один из внутренних CPA может определить, что следующий переход возможен только по одной-единственной дуге, а другой внутренний CPA, не имея этой информации, очертит более широкое реузльтирующее множество.
В это ситуации было бы логичнее рассмотреть только одну дугу даже второму анализу.

Для этого определяется оператор усиления: $\downarrow: E_{\Delta_1} \times \dots \times E_{\Delta_n} \rightarrow E_{\mathscr{C}}$.
Как видно из определения, этот оператор зависит от конкретных видов анализа (CPA).
Опишем общий вид этого оператора для усиления информации о дугах.

\begin{equation}
\label{simple_strengthen_def}
\begin{aligned}
& \forall e \in E_{\mathscr{C}}, e = (e_1, \dots, e_n), \forall 1 \le i \le n: e_i = (s_i, q_i) \\
& \downarrow(e_1, \dots, e_n) = \begin{cases}
& ((s_1, g), \dots, (s_n, g)) \mbox{, если } \exists g: ||q_1|| \cap \dots \cap ||q_n|| = \{g\} \\
& \bot \mbox{, если }: ||q_1|| \cap \dots \cap ||q_n|| = \emptyset \\
& (e_1, \dots, e_n) \mbox{, иначе }
\end{cases}
\end{aligned}
\end{equation}

Такое определение является самым примитивным оператором $\downarrow$, так как оно не учитывает возможности усиления ни абстрактных состояний, ни абстрактных дуг.
Такой оператор передает информацию другим операторам только о том, что существует единственная конкретная дуга, соответствующая абстрактным дугам всех внутренних CPA.
Тем не менее, возможны другие, более интеллектуальные, реализации этого оператора.

В дальнейшем нам понадобится оператор замены: 
\begin{align*}
\forall e \in E, e = (s, q): \cancelto{g}{e} = \begin{cases}
& (s, g) \mbox{, если } g \in G \\
& \bot_I \mbox{, если } g = \bot^T_I \in \mathcal{G} \\
& e\mbox{, иначе}
\end{cases}
\end{align*}

Таким образом, полученные выше $e_j'$ переходами внутренних CPA комбинируются в один переход CompositeCPA с помощью оператора $\downarrow$:
$e' = \downarrow(e'_1, \dots, e'_n)$.
Для краткости далее будем обозначать $\downarrow(e'_1, \dots, e'_n) = \downarrow e'$.

Основным требованием на оператор $\downarrow$ является то, что он не должен терять конкретные переходы:

\begin{equation}
\label{cpa_strengthen_req_1}
\begin{aligned}
& \forall e_0, e_1, \dots, e_n \in E_{\mathscr{C}}, t_0, \dots, t_n \in T \\
& \epp_{\mathscr{C}}
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right) = \\
& \epp_{\mathscr{C}}
\left(
\begin{pmatrix}
\downarrow e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)
\end{aligned}
\end{equation}

И симметричное требование для второго аргумента:

\begin{equation}
\label{cpa_strengthen_req_2}
\begin{aligned}
& \forall e_0, e_1, \dots, e_n \in E_{\mathscr{C}}, t_0, \dots, t_n \in T \\
& \epp_{\mathscr{C}}
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right) = \\
& \epp_{\mathscr{C}}
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
\downarrow e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)
\end{aligned}
\end{equation}

Еще одно требование связывает оператор $apply$ с оператором $\downarrow$:
\begin{equation}
\label{cpa_strengthen_apply_req}
\begin{aligned}
& \downarrow apply_{\mathscr{C}}(e_1, e_2) = apply_{\mathscr{C}}(\downarrow e_1, \downarrow e_2)
\end{aligned}
\end{equation}


Простой оператор $\downarrow$(определение~\ref{simple_strengthen_def}) удовлетворяет условиям~\ref{cpa_strengthen_req_1},~\ref{cpa_strengthen_req_2}, так как с учетом определения~\ref{epp_split} конкретная дуга $g \in ||q_0|| \cap \dots \cap ||q_n||$.
То есть, сужение каждой из абстрактных дуг (по определению~\ref{simple_strengthen_def}) никак не влияет на результат оператора $\epp$.

Для оператора $\downarrow$(определение~\ref{simple_strengthen_def}) требование~\ref{cpa_strengthen_apply_req} трансформируется в такое требование для внутренних CPA:
\begin{equation}
\label{cpa_strengthen_simple_apply_req}
\begin{aligned}
\forall e_1, e_2 \in E_I, g \in G \cup \mathcal{G} :
\cancelto{g}{apply_{I}(e_1, e_2)} = apply_I(\cancelto{g}{e_1}, \cancelto{g}{e_2})
\end{aligned}
\end{equation}
При этом в основном требуется доказать условие~\ref{cpa_strengthen_simple_apply_req} для $g \in G$, так как остальные две части являются тривиальными.
Легко видеть, что из условия~\ref{cpa_strengthen_simple_apply_req}, определения~\ref{simple_strengthen_def} и определения $apply$ будет следовать выполнение условия~\ref{cpa_strengthen_apply_req}

Так как композитный анализ разбивает операцию $thread\_create$ на две дуги, требование~\ref{cpa_transfer_inner_req} трансформируется в

\begin{equation}
\label{cpa_transfer_composite_req}
\begin{aligned}
& \forall \tau, \tau' \in \mathcal{T}, R \subseteq E: \tau \tcarrow \tau', \forall e_0, e_1, \dots, e_n \in R: e_i = (s_i, q_i) \\
& \left(
\begin{array}{ll}
& \exists t_0, t_1, \dots, t_n \in T, t_i \neq t_j, t_0 = t \\
& \tau \in \epp_I
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix} ,
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)
\end{array}
\right) \Rightarrow \\
& \left[ \begin{array}{ll}
\lor q_0 & \neq thread\_create \land \\
& \exists e'_0, e'_1, \dots, e'_n \in E, \forall 1 \leq i \leq n: e_i \tat{R} e'_i: \\
& \exists 1 \le k \le n: t_k = t' \land \\
& \tau' \in \epp_I((e_k', t_k), \{(\tilde{e}_i, t_i) \mid \tilde{e}_i = apply(e_i', e'_k) \land i \neq k)\}) \\
\lor q_0 & = thread\_create \land \\
& \exists e'_0, e'_1, \dots, e'_{n+1} \in E, \forall 0 \leq i \leq n: \\
& \begin{cases}
& (s_0, (l, tc_{parent}, l')) \tat{R} e'_0 \\
& (s_0, (l, tc_{child}, l')) \tat{R} e'_{n+1} \\
& e_i \tatarrow e'_i, \text{ если } i \neq 0
\end{cases} \\
& \exists 0 \le k \le n + 1:  t_k = t' \land\\
& \tau' \in \epp_I((e_k', t_k), \{(\tilde{e}_i, t_i) \mid \tilde{e}_i = apply(e_i', e'_k) \land i \neq k)\}) 
\end{array} 
\right.
\end{aligned}
\end{equation}
%
%\begin{equation}
%\label{transfer_tm_ir_stronger_for_inner_3}
%\begin{aligned}
%& \cdot g = thread\_join(var,num):\\
%& \exists r: t_r \notin dom(c) \land c_t(var, num) = t_r \\
%& \exists e_1', \dots,e_{r-1}', e_{r+1}', e_m' \in E:\\
%& c' \in \epp
%\begin{pmatrix}
%\begin{pmatrix}
%e_1' \\
%t_1 
%\end{pmatrix}&,
%\dots& ,
%\begin{pmatrix}
%e_{r-1}' \\
%t_{r-1} 
%\end{pmatrix},
%\begin{pmatrix}
%e_{r+1}' \\
%t_{r+1} 
%\end{pmatrix} ,
%\dots& ,
%\begin{pmatrix}
%e_m' \\
%t_m 
%\end{pmatrix}
%\end{pmatrix} \\
%& \mbox{ где } e_1',\dots,e_{r-1}', e_{r+1}', \dots e_m' \mbox{ такие, что } \\
%&\exists i_1, \dots, i_{k-1}, i_{k+1}, \dots, i_m: \\
%&
%\begin{cases}
%\forall q \neq k \land q \neq r: e_q \tat{i_q} e_q' \land i_q \in \{i \mid e_k \tat{\tau} i\} \\
%e_k \tat{\tau, tc_{parent}} e_k' \\
%e_k \tat{\tau, tc_{child}} e_{m+1}
%\end{cases}
%\end{aligned}
%\end{equation}

Теперь нужно показать, что требование~\ref{cpa_transfer_inner_req} выполнено для $\mathscr{C}$, если требование~\ref{cpa_transfer_composite_req} выполнены для всех его внутренних элементов. 

\begin{proof}
Рассмотрим случайный конкретный переход:
$$\tau \in  \epp_{\mathscr{C}}
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\right\}
\right)$$
где $e_i=(e^1_i, \dots, e^n_i)$.

По определению~\ref{composite_epp_def}, это означает что
$$\forall j: 1\le j \le m: \tau \in  \epp_{\Delta_j}
\left(
\begin{pmatrix}
e^j_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e^j_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e^j_m \\
t_m 
\end{pmatrix}
\right\}
\right)$$

Возьмем случайный переход
$ \tau \tcarrow \tau', \tau=(c,g,t), g \in G, t \in T, $ и покажем, что 
$\exists e_0', \dots, e_m', \tilde{e}'_0, \dots, \tilde{e}'_{k-1}, \tilde{e}'_{k+1}, \dots, \tilde{e}'_m \in E$ и
$\tau' \in  \epp_{\mathscr{C}}
\left(
\begin{pmatrix}
e'_k \\
t_k 
\end{pmatrix},
\left\{
\begin{pmatrix}
\tilde{e'_0} \\
t_0 
\end{pmatrix},
\dots ,
\begin{pmatrix}
\tilde{e'_m} \\
t_m 
\end{pmatrix}
\right\}
\right)$ 
и при этом $\tilde{e}_0', \dots, \tilde{e}_m'$ будут получены из $e_0', \dots, e_m'$, а они -- из $e_0, \dots, e_m$ указанными в~\ref{cpa_transfer_inner_req} способами.

%enumerate
Сначала рассмотрим случай $g \neq thread\_create$

Используя требование~\ref{cpa_transfer_composite_req} для внутренних элементов, получаем, что 
\begin{align*}
& \forall 0 \le j \le m: \exists {e^j_0}', {e^j_1}', \dots, {e^j_n}' \in E: \\
& \forall 1 \leq i \leq n: e^j_i \tat{R} {e^j_i}': \exists 1 \le k \le n: t_k = t' \land \\
& \tau' \in \epp_I(({e^j_k}', t_k), \{(\tilde{e^j_i}, t_i) \mid \tilde{e^j_i} = apply({e^j_i}', {e^j_k}') \land i \neq k)\})
\end{align*}

Заметим, что $k$ является одним и тем же для всех внутренних элементов, так как есть только одно $t_k = t'$, а множество $t_0, t_1, \dots, t_n$ -- общее для всех CPA.
Поэтому можно объединить все внутренние переходы следующим способом:
$ \forall 1 \le i \le n: e_i' = ({e^1_i}', \dots, {e^m_i}')$
Таким образом, $\tau' \in \epp_{\mathscr{C}}((e_k', t_k), \{(\tilde{e_i}, t_i) \mid \tilde{e_i} = apply(e'_i, e'_k) \land i \neq k)\})$.
По условиям~\ref{cpa_strengthen_req_1},~\ref{cpa_strengthen_req_2},~\ref{cpa_strengthen_apply_req} $\tau' \in \epp_{\mathscr{C}}((\downarrow e_k', t_k), \{(\downarrow \tilde{e_i}, t_i) \mid \tilde{e_i} = apply(e'_i, e'_k) \land i \neq k)\})$.

По определению $transfer$ в композитном анализе, получаем, что $\forall 1 \le i \le n: e_i \tatarrow \downarrow e_i'$, а по определению $apply$: $\forall 1 \le i \le n: \tilde{e_i} = apply(e_i', e_k') = (\tilde{e^0_i}, \dots, \tilde{e^m_i})$.
А это означает, что выполнено условие~\ref{cpa_transfer_inner_req}.
Это как раз то, что нам нужно было доказать. 

Рассмотрим случай $g = thread\_create$.

Используя требование~\ref{cpa_transfer_composite_req} для внутренних элементов, получаем, что 
\begin{align*}
& \exists e'_0, e'_1, \dots, e'_{n+1} \in E, \forall 0 \leq i \leq n: \\
& \begin{cases}
& (s_0, (l, tc_{parent}, l')) \tat{R} e'_0 \\
& (s_0, (l, tc_{child}, l')) \tat{R} e'_{n+1} \\
& e_i \tatarrow e'_i, \text{ если } i \neq 0
\end{cases} \\
& \exists 0 \le k \le n + 1:  t_k = t' \land\\
& \tau' \in \epp_I((e_k', t_k), \{(\tilde{e}_i, t_i) \mid \tilde{e}_i = apply(e_i', e'_k) \land i \neq k)\}) 
\end{align*}

Заметим, что $k$ является одним и тем же для всех внутренних элементов, так как есть только одно $t_k = t'$, а множество $t_0, t_1, \dots, t_n$ -- общее для всех CPA.
Поэтому можно объединить все внутренние переходы следующим способом:
$ \forall 1 \le i \le n+1: e_i' = ({e^1_i}', \dots, {e^m_i}')$.
Таким образом, $\tau' \in \epp_{\mathscr{C}}((e_k', t_k), \{(\tilde{e_i}, t_i) \mid \tilde{e_i} = apply(e'_i, e'_k) \land i \neq k)\})$.
По условиям~\ref{cpa_strengthen_req_1},~\ref{cpa_strengthen_req_2},~\ref{cpa_strengthen_apply_req} $\tau' \in \epp_{\mathscr{C}}((\downarrow e_k', t_k), \{(\downarrow \tilde{e_i}, t_i) \mid \tilde{e_i} = apply(e'_i, e'_k) \land i \neq k)\})$.

По определению $transfer$ в композитном анализе, получаем, что $\forall 1 \le i \le n: e_i \tatarrow \downarrow e_i' \land e_0 \tatarrow \downarrow e'_{n+1}$, а по определению $apply$: $\forall 1 \le i \le n: \tilde{e_i} = apply(e_i', e_k') = (\tilde{e^0_i}, \dots, \tilde{e^m_i})$.
А это означает, что выполнено условие~\ref{cpa_transfer_inner_req}.
Это как раз то, что нам нужно было доказать. 
\end{proof}

\qedsymbol

\item 
Оператор слияния $merge$ может определяться различными способами, в зависимости от требований к анализу.

Самый простой способ: использовать оператор $merge$ каждого из внутренних видов анализа.

$merge_{\mathscr{C}}(e_1,e_2,\pi) = (merge_{\Delta_1}(e_1^1, e_2^1,\pi), \dots, merge_{\Delta_n}(e_1^n, e_2^n,\pi))$.
В этом случае объединение переходов каждого из внутренних вариантов анализа производится независимо друг от друга.
Проверим условие~\ref{cpa_merge_eq}.
Воспользуемся тем, что внутренние CPA удовлетворяют условию~\ref{cpa_merge_eq}, то есть $\forall 1 \le i \le n: e_2^i \sqsubseteq merge_{\Delta_i}(e_1^i, e_2^i,\pi)$.
По определению решетки $\mathscr{C}$ это означает, что $(e_2^1, \dots, e_2^n) = e_2 \sqsubseteq merge_{\mathscr{C}}(e_1,e_2,\pi)$.

Такой простой вариант объединения состояний не очень эффективен, например, состояния различных потоков не всегда имеет смысл обединять.
Для этого возможно объединение состояний, если состояния некоторого вида анализа равны. 

\begin{align*}
merge_{\mathscr{C}}(e_1,e_2,\pi) =
\begin{cases}
&(e_1^1, merge_{\Delta_1}(e_1^2, e_2^2,\pi), \dots, merge_{\Delta_n}(e_1^n, e_2^n,\pi)), \\
& \hspace{1cm} \mbox{ если } e_1^1 = e_2^1 \\
& e_2, \mbox{ иначе }
\end{cases} 
\end{align*}

В таком примере состояния объединяются только при совпадении (равенстве) состояний первого анализа ($i=1$).
Очевидно, что такой вариант оператора $merge$ тоже удовлетворяет условию~\ref{cpa_merge_eq}, так как для $i = 1: e_2^1 \sqsubseteq e_2^1$.

\item 
$stop_{\mathscr{C}}(e,R,\pi)=\forall j \mbox{ } stop_{\Delta_j}(e_j, R_j, \pi)$, где $R_j = \{e_j \mid e \in R \land e = (\dots, e_j, \dots)\}$

Проверим условие~\ref{cpa_stop_eq} для $\mathscr{C}$.
По условию~\ref{cpa_stop_eq} для внутренних CPA выполнено $\forall 1 \le i \le n, \widehat{R_i} \subseteq E_i: \conc{\widehat{R_i} \cup \{e_i\}}_{TM} \subseteq \conc{R_i \cup \widehat{R_i}}_{TM}$.
Рассмотрим множество $\widehat{R} = \widehat{R_1} \times \dots \times \widehat{R_n} \subseteq E$. 
$\conc{\widehat{R} \cup \{e\}}_{TM} = \conc{\widehat{R_1} \cup \{e_1\}}_{TM} \cap \dots \cap \conc{\widehat{R_n} \cup \{e_n\}}_{TM} \subseteq \conc{R_1 \cup \widehat{R_1}}_{TM} \cap \dots \cap \conc{R_n \cup \widehat{R_n}}_{TM} = \conc{R \cup \widehat{R}}_{TM}$.

\item 
$prec_{\mathscr{C}}(e,\pi)=(prec_{\Delta_1}(e_1, \pi_1), \dots, prec_{\Delta_n}(e_n, \pi_n)$. Условие~\ref{cpa_prec_eq} выполнено для композитного анализа, если оно выполнено для каждого из внутренних видов анализа $\Delta_j$, так как по определению $e \sqsubseteq e' \iff \forall j: e_j \sqsubseteq e_j'$.

\item 
$compatible_{\mathscr{C}}(e_1, e_2) = compatible_{\Delta_1}(e^1_1, e^1_2) \land \dots \land compatible_{\Delta_n}(e^n_1, e^n_2)$.

\item 
$composite_{\mathscr{C}}(e_1, e_2) = (composite_{\Delta_1}(e^1_1, e^1_2), \dots, composite_{\Delta_n}(e^n_1, e^n_2))$.

\item 
$e|_{p\mathscr{C}} = (e_1|_{p\Delta_1}, \dots, e_n|_{p\Delta_n})$.

\end{itemize}
\section{Простой анализ потоков}
\label{sect_thread_analysis}
Определим анализ потоков, инвариантный к переходам по окружению, 
$\mathbb{T}=(D_{T},$ $\Pi_{T}, \tatarrow_{T},$ $merge_{T}, stop_{T},$ $prec_{T}, compatible_{T},$ $composite_{T},$ $\cdot|_p)$, который будет определять идентификаторы потоков.

Анализ потоков содержит те же ограничения, что и анализ, представленный в статье~\cite{ThreadModular03}, и его применение ограничено на программы с ограниченным количеством создаваемых потоков.
Предполагаем, что программа имеет ограниченное количество потоков, определяемые точками создания этих потоков, то есть $T\subseteq L$ и для $thread\_create(pc_\nu)$ всегда создается поток с идентификатором $pc_\nu$.
Заметим, что остальные виды анализа не ограничены количеством создаваемых потоков.

Воспользуемся общим видом анализа с явным видом переходов, описанном в подразделе~\ref{subsect_transitions}.

\begin{itemize}

\item Множество абстрактных состояний $E^E_T=T \cup \{\bot^E,\top^E\}$, $\bot^E \sqsubseteq t \sqsubseteq^E \top^E$ и $t \neq t'$ $\Rightarrow$ $t \not\sqsubseteq^E t'$ для всех элементов $t, t'\in T$ 
(что означает $\bot^E \sqcup^E t = t$, $\top^E \sqcup t = \top^E$, $t \sqcup^E t' = \top^E$ для всех элементов $t,t'\in T$, $t\neq t'$).

В данном анализе требуется расширенный оператор проверки совместности:

\begin{align*}
& \forall t_0, \dots, t_j \in T: \\
& check_C((s_0, t_0), \{(s_1, t_1),\dots, (s_n,t_n)\}) = \forall i\ne j: t_i \neq t_j \land s_i \sqsubseteq t_i
\end{align*}

Оператор композиции для состояний

$\forall t_1, \dots, t_n \in T:$
\begin{equation}
\begin{aligned}
& \epp^S_T
\left(
\begin{pmatrix}
s_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
s_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
s_n \\
t_n 
\end{pmatrix}
\right\}
\right) =  \\
& \begin{cases}
& \{(c_{pc},c_l,c_g,c_s) \in C \mid dom(c) = \{t_0, \dots, t_n\}\}, \\
& \hspace{1cm} \mbox{if } check_C((s_0, t_0), \{(s_1, t_1),\dots, (s_n,t_n)\})\\
& \emptyset \mbox{, else}
\end{cases}
\end{aligned}
\end{equation}

Такое определение оператора $\epp$ очевидно удовлетворяет условиям~\ref{cpa_tm_epp_split_req_1},~\ref{cpa_tm_epp_split_req_2}, так как, фактически, результат не зависит от состояний $s_i$, которые влияют только на оператор $check_C$.

Множество абстрактных дуг содержит только тождественную дугу, которая не меняет абстрактное состояние, и верхний и нижний элементы решетки: $\mathcal{G} = \{\bot^T_T, \varepsilon, \top^T_T\}$.
Оператор конкретизации для дуг является тривиальным: $||\bot^T_T|| = \emptyset$, $||\varepsilon|| = ||\top^T_T|| = G$.

\item Множество точности не используется и состоит из одного элемента: $\Pi_T = \{\{\emptyset\}\}$.

\item Отношение переходов $\tatarrow_T$ определяет переход $e \tatarrow_T (e', \pi)$, $g=(\cdot,op,\cdot)$, если 
\begin{itemize}
\item $op\neq tc_{child}$ и $e' = (t, \top)$, то есть текущий поток не меняется.
\item $op=tc_{child}(l_\nu)$, тогда $e' = (l_\nu, \top)$, то есть текущий поток становится равным созданному.
\end{itemize}

Переход $\top \tat{\tau, g}_T (\top, \pi)$ определен для всех $g\in G$, однако на практике переход будет усилен (определение~\ref{simple_strengthen_def}) в CompositeCPA.

\item Оператор слияния не объединяет абстрактные состояния: $merge_T(e, e', \pi) = e'$. Условие~\ref{cpa_merge_eq} очевидно выполнено.

\item Оператор останова для абстрактных переходов проверяет наличие абстрактного перехода во множестве достижимых состояний: $stop_T(e, R, \pi) = (e \in R)$.
Проверим условие~\ref{cpa_stop_eq}.
Возьмем $\widehat{R} \subseteq E_T: \conc{\widehat{R} \cup e}_TM \subseteq \conc{\widehat{R} \cup e \cup R}_TM = \conc{\widehat{R} \cup R}_TM$.

\item Точность переходов никогда не меняется: $prec_T(e, \pi, R) = (e, \pi)$. Условие~\ref{cpa_prec_eq} выполнено, так как $e \sqsubseteq e$.

\item $\forall e_1, e_2 \in E_T, e_i = (s_i, q_i):compatible_T(e_1,e_2) = s_1 \neq s_2$.

\item Переходы являются {\em инвариантными к окружению}, то есть ни один поток не может изменить идентификатор другого потока.
Это означает, что проекцией является тождественный переход:
$(s, q)|_p = (s, \varepsilon)$.

\item Оператор $compose$ является обычным~\ref{default_compatible_def}.
\end{itemize}

Теперь нужно доказать, что определенные таким образом операторы $transfer$ и $apply$ удовлетворяют условиям~\ref{cpa_transfer_inner_req},~\ref{cpa_strengthen_simple_apply_req}.

\begin{proof}
Рассмотрим случайный конкретный переход:
$$\tau \in  \epp_{T}
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\right\}
\right)$$.

Если $op \neq thread\_create$, по определению $transfer$ $e'_i = (s_i, \top^T_T)$, то есть состояние не изменяется, а переходы рассматриваются все возможные. 
А значит, 
$$\tau' \in  \epp_{T}
\left(
\begin{pmatrix}
e'_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e'_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e'_m \\
t_m 
\end{pmatrix}
\right\}
\right)$$

Если $op = tc\_{Child} \lor op = tc\_{Parent}$ состояние меняется только у дочернего потока: $e_{m+1} = (l_{\nu}, \top^T_T)$.
То есть, 
$$\tau' \in  \epp_{T}
\left(
\begin{pmatrix}
e'_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e'_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e'_m \\
t_m 
\end{pmatrix} ,
\begin{pmatrix}
e'_{m+1} \\
l_{\nu} 
\end{pmatrix}
\right\}
\right)$$

Теперь проверим условие на $apply$. 
$\cancelto{g}{e} = (s, g)$, по определению $apply$: 

\end{proof}
%----------------------------------------------------
%----------------------------------------------------
%----------------------------------------------------
\section{Анализ точек программы}
\label{sect_location_analysis}

Определим анализ точек программы (LocationCPA), инвариантный к переходам по окружению,
$\mathbb{L}=(D_{L},$ $\Pi_{L}, \tatarrow_{L}, merge_{L}, stop_{L}, prec_{L},$ $compatible_{L},$ $\cdot|_p,$ $compose_L)$, который отвечает за синтаксическую достижимость точек программы.
Классический вариант этого анализа описан в~\cite{Beyer08}.
Расширим его компоненты для возможности его применения в анализе с раздельным рассмотрением потоков.

Воспользуемся общим видом анализа с явным видом переходов, описанном в подразделе~\ref{subsect_transitions}.
 
\begin{enumerate}

\item 
Множество абстрактных состояний $E^S_L$ состоит из абстрактных точек программы, которые отображаются на конкретные узлы ГПУ с помощью функции $loc: E^S_L \rightarrow 2^L$.
$\top^S_L$ означает, что анализ не может определить конкретную точку программы, формально, $loc(\top^S_L) = L$.
В общем случае анализ может работать с абстрактными точками программы, которые выражают несколько конкретных точек программы, но такой вариант является слишком общим и пока не нашел применения на практике, поэтому дальше мы будем рассматривать упрощенную вариацию этого анализа, в котором рассматриваются только одиночные точки программы: $\forall s \in E^S_L: s = \top^S_L \lor s=\bot^S_L \lor loc(s) = l \in L$.
Определенная таким образом $\mathcal{E}^S_L$ является плоской решеткой, что означает, что две различные точки программы являются несравнимыми: $l \neq l'$ $\Rightarrow$ $l \not\sqsubseteq^E l'$ для всех элементов $l, l' \in L$ 
(отсюда следует $\bot^E \sqcup^E l = l$, $\top^E \sqcup l=\top^E$, $ l\sqcup^E l' = \top^E$ для всех элементов $l,l'\in L$, $l\neq l'$), 
и

В данном анализе оператор является тривиальным, так как потоки могут находиться в любых точках программы независимо друг от друга:

\begin{align*}
& \forall t_0, \dots, t_j \in T: check_C(\{s_0, \dots, s_n,\}) \equiv true
\end{align*}

Оператор композиции для состояний

\begin{equation}
\label{location_epp_def}
\begin{aligned}
&\forall l_1, \dots, l_n \in E^S_L:\\
&\epp^S_{L}
\begin{pmatrix}
\begin{pmatrix}
l_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
l_n \\
t_n 
\end{pmatrix}
\end{pmatrix} = \\
& \left\lbrace (c_{pc},c_l,c_g,c_s) \in C 
\left| 
\begin{array}{c}
t_1, \dots, t_m \in T\\
c_{pc} = 
\left\lbrace
\begin{array}{c}
t_1 \to l_1,\\
\dots\\
t_m \to l_m\\
\end{array}
\right\rbrace, \\
dom(c_l) = \{t_1, \dots, t_m\}\\
\end{array}
\right.
\right\rbrace\\
\end{aligned}
\end{equation}

Такое определение оператора $\epp$ очевидно удовлетворяет условиям~\ref{cpa_tm_epp_split_req_1},~\ref{cpa_tm_epp_split_req_2}.

Множество абстрактных дуг содержит только тождественную дугу, которая не меняет абстрактное состояние, и верхний и нижний элементы решетки: $\mathcal{G} = \{\bot^T_T, \varepsilon, \top^T_T\}$.
Оператор конкретизации для дуг является тривиальным: $||\bot^T_T|| = \emptyset$, $||\varepsilon|| = ||\top^T_T|| = G$.
Cостояния этого анализа {\em инвариантны к окружению}, то есть ни один поток не может изменить точку в программе, на которой находится другой поток.

\item Множество точности содержит только один элемент $\Pi_L = \{\{\emptyset\}\}$, так как не подразумевается применение абстракции.

\item Отношение переходов $\tatarrow_L$ содержит переход $e \tatarrow_L (e', \pi)$, где $e = (s, q)$, если 
\begin{itemize}
\item $q \in G, q=(l_1,op,l_2)$, $l_1 \in loc(s)$ и
\begin{itemize}
\item $op \neq tc_{child}$ и $s' = l_2$ (следующее состояние в ГПУ без учета семантики операции $op$), $g' = (l_2, op, \cdot$ - все операции в ГПУ, которые соответствуют заданной точке программы.
\item $op=tc_{child}(l_\nu)$ и $l_2 = l_\nu$, $g' = (l_2, op, \cdot$ - все операции в ГПУ, которые соответствуют заданной точке программы.
\end{itemize}
\item $q = \varepsilon$, $s'=s$, $g' = (l_2, op, \cdot$ - все операции в ГПУ, которые соответствуют заданной точке программы.
\end{itemize}

Есть переход $\top \tatarrow_L (\top, \pi)$.

Проверим условие~\ref{transfer_tm_ir_stronger_for_inner}.
Возьмем случайное состояние $c \in \epp
\begin{pmatrix}
\begin{pmatrix}
l_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
l_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$

По определению~\ref{location_epp_def} это означает 
$$ c_{pc} = 
\left\lbrace
\begin{array}{c}
t_1 \to l_1,\\
\dots\\
t_m \to l_m\\
\end{array}
\right\rbrace.$$

Рассмотрим случайный переход $c \tc{g,t} c'$. Если этот переход возможен на конкретных состояниях, это означает, что $\exists k : 1 \le k \le m \land t_k = t$. Зафиксируем это значение $k$ и будем рассматривать $\tau$-переходы из состояния $l_k$. Остальные состояния не изменятся, так как переход по пустому переходу окружения не меняют состояния.

%TODO thread\_join
Рассмотрим случай $g \neq thread\_create$. В этом случае $l_k' = l_2$ -- вершине ГПУ, в который направлена дуга $g$. Изменений других состояний нет. $$ c'_{pc} = 
\left\lbrace
\begin{array}{c}
t_1 \to l_1,\\
\dots,\\
t_k \to l_k'\\
\dots,\\
t_m \to l_m\\
\end{array}
\right\rbrace.$$ Это означает, что $$с' \in \begin{pmatrix}
\begin{pmatrix}
l_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
l_k' \\
t_k 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
l_m \\
t_m 
\end{pmatrix}
\end{pmatrix}.$$

Рассмотрим случай $g = thread\_create(l_\nu)$. В этом случае также $l_k' = l_2$ -- вершине ГПУ, в который направлена дуга $g$, а $l_{m+1} = l_\nu$. Здесь $l_k \tat{tc_{parent}} l_k'$, $l_k \tat{tc_{child}} l_\nu$. При этом переходе $$ c'_{pc} = 
\left\lbrace
\begin{array}{c}
t_1 \to l_1,\\
\dots,\\
t_k \to l_k'\\
\dots,\\
t_m \to l_m,\\
t_{m+1} \to l_{m+1}\\
\end{array}
\right\rbrace.$$ Это означает, что $$ с' \in \begin{pmatrix}
\begin{pmatrix}
l_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
l_k' \\
t_k 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
l_m \\
t_m 
\end{pmatrix}& ,
\begin{pmatrix}
l_\nu \\
t_{m+1} 
\end{pmatrix}
\end{pmatrix}$$.


\item Оператор слияния не объединяет элементы: $merge^E_L(e, e', \pi) = e$. Очевидно, он удовлетворяет условию~\ref{cpa_merge_tm_e_eq}, так как $e \sqsubseteq e$.

\item Оператор останова рассматривает состояния индивидуально: $stop^E_L(e, R, \pi) = (e \in R)$. Очевидно, он удовлетворяет условию~\ref{cpa_stop_tm_e_eq}, так как
\begin{align}
&\forall e \in E, R \subseteq E, \pi \in \Pi: \nonumber \\
& (e \in R) \implies \forall \widehat{R} \subseteq E: \{e\} \cup \widehat{R} \subseteq R \cup \widehat{R} \implies \nonumber \\
& \implies (eq.\ref{cpa_conc_eq_0}) \forall \widehat{R} \subseteq E: \conctm{\{e\}\cup \widehat{R}} \subseteq \conc{R' \cup \widehat{R}}
\end{align}

\item Точность состояния никогда не изменяется: $prec^E_L(e, \pi, R) = (e, \pi)$.
Очевидно, он удовлетворяет условию~\ref{prec_tm_e_equation}, так как $e \sqsubseteq e$.

\item $compatible(l,\varepsilon) = true$.

\end{enumerate}
%----------------------------------------------------
%----------------------------------------------------
%----------------------------------------------------

\section{Анализ предикатов}
\label{sect_predicate_analysis}
Пусть $\mathscr{P}$ -- это множество предикатов над переменными программы в теории без кванторов $\mathscr{T}$.
Формула $\varphi$ является логической комбинацией предикатов из $\mathscr{P}$.

Пусть $v: X \to \mathbb{Z}$ является отображением из переменной в ее значение.
Определим $v \models \varphi$, где $v$ называется моделью $\varphi$.

Опредилим переименование переменных $\theta: X \to X'$, которое применимо к формулам $\theta(\varphi)$ и их моделям $\theta(v)$.
Обозначим
$$\theta_{X,i}= 
\left\lbrace\begin{array}{ll}
x \mapsto x\#i, & \mbox{ если } x \in X\\
x \mapsto x, &\mbox{ иначе}.\\
\end{array}
\right.
$$
и
$$\theta_{X,i}^{-1}= 
\left\lbrace\begin{array}{ll}
x\#i \mapsto x, & \mbox{ если } x \in X\\
x \mapsto x, &\mbox{ иначе}.\\
\end{array}
\right.
$$

Определим $(\varphi)^\pi$ -- логическую предикатную абстракцию формулы $\varphi$.

Определим $SP_{op}(\varphi)$ -- сильнейшее постусловие $\varphi$ и операции $op$.

Требование: $c \tc{op} c' \land (c_l, c_g) = v \models \varphi \implies (c_l', c_g') = v' \models SP_{op}(\varphi)$

Определим анализ предикатов (Predicate Analysis) $\mathbb{P}=(D_{P},$ $\Pi_{P}, \tatarrow_{P},$ $merge^E_{P}, stop^E_{P},$ $merge^I_{P}, stop^I_{P},$ $prec^E_{P},prec^I_{P},$ $compatible_{P})$, который отслеживает значение предикатов над переменными программы.

Он состоит из следующий компонентов.

{\textbf 1.} Абстрактный домен $D_{P}=(C, \mathcal{E}, \mathcal{I}, compatible^E, \epp)$:

\begin{itemize}
\item Полурешетка
$\mathcal{E}=(E, \top^E, \bot^E, \sqsubseteq^E, \sqcup^E)$, которая состоит из множества
$E = \mathcal{P}$, 
$\top^E = true$ и $\bot^E = false$.

Частичный порядок $\sqsubseteq^E \subseteq E \times E$ определяется как $e \sqsubseteq^E e' \Leftrightarrow e \implies e'$.
Объединение элементов $\sqcup^E: E \times E \to E$ определяет ближайший верхний по решетке элемент в соответствии с частичным порядком.

\item
Определим совместные частичные состояния как те, которые имеют общую глобальную часть ($X^{global}$).
Для этой цели мы переименуем локальные переменные каждого состояния, и поэтому у нас должно быть общее решение для глобальных переменных, если взять конъюнкцию всех состояний.

\begin{equation}
\begin{aligned}
& \forall e_1, \dots, e_j \in E \\
& compatible^E(\{e_1,\dots, e_j\}) = \\
& \exists v: v \models \theta_{X^{local},1}(e_1) \land \dots \land \theta_{X^{local},n}(e_n)
\end{aligned}
\end{equation}

Для совместных состояний $e_1, \dots, e_j \in E$ и для каждого решения 
$v \models \theta_{X^{local},1}(e_1) \land \dots \land \theta_{X^{local},n}(e_n)$
можно определить функцию $\hat v_g = v_{\mid X^{global}}$, представляющую общую глобальную часть состояния и функции $\hat v_1=\theta_{X^{local},1}^{-1}(v)_{\mid X^{local}}, \dots, \hat v_j=\theta_{X^{local},1}^{-1}(v)_{\mid X^{local}}$, представляющие локальные части.

Функция объединения $\epp: 2^(E \times T) \to 2^C$ сопоставляет каждому множеству абстрактных состояний сумму их совместных частичных состояний (мы рассматриваем локальную часть идивидуальных состояний $\hat v_i$ и общую глобальную часть $\hat v_g$).

\item Полурешетка
$\mathcal{I}=(I, \top^I, \bot^I, \sqsubseteq^I, \sqcup^I)$, которая состоит из двух формул $I=\mathscr{P}\times \mathscr{P}$.

Первая формула обозначает начальное состояние (используется для проверки совместности), а вторая формула представляет глобальные переменные, которые были изменены окружением.

При этом $\top^I=(true,true)$, $\bot^I=(false,false)$, 
$\sqsubseteq^I$ ($\sqcup^I$)  определяется применением  $\sqsubseteq^E$ ($\sqcup^E$) к первому и второму элементу пары.
\end{itemize}

{\textbf 2.} Множество точности $\Pi_P = 2^\mathscr{P}$ отвечает за точность абстрактного состояния и содержит в себе множество предикатов.

{\textbf 3.} Отношение переходов $e \tat{i,g}_C (e',\pi)$.

\begin{itemize}
\item Для $i=\tau$ переход $e \tat{\tau, g}_{P} (e', \pi)$ и $e \tat{\tau, g}_{P} (i', \pi)$, где $g = (\cdot, op, \cdot)$, существует, если
$$e'= 
\left\lbrace\begin{array}{ll}
(SP_{op}(e))^\pi, & \mbox{ если } op=assign(w, expr) \lor op=assume(expr)\\
e, &\mbox{ иначе}.\\
\end{array}
\right.
$$
и 
$$i'= 
\left\lbrace
\begin{array}{ll}
(\theta_{X^{local},env}(e),\theta_{X^{local},env}(SP_{op}(e))),&\mbox{если } op=assign(w, expr),\\
(\theta_{X^{local},env}(e),true),&\mbox{иначе}.\\
\end{array}
\right.
$$


\item Для $i=(\hat e,\hat \varphi)$ переход вычисляет абстракцию для формулы $\hat \varphi \land e$ для совместных состояний $e$ и $\hat e$.

Определим совместность состояния и эффекта окружения $compatible(e, i)$, где  $i=(\hat e,\hat \varphi)$.

\begin{equation}
\label{cpa_predicate_compatible}
\begin{aligned}
& compatible_{TM}(e, i) = \exists v: v \models e \land \hat e
\end{aligned}
\end{equation}

Переход $e \tat{i, g}_{C} (e', \pi')$, где $i=(\hat e,\hat \varphi)$, существует, если
$compatible_{TM}(e,i)$ и $e'= (\hat \varphi \land e)^{\pi'}$.
\end{itemize}

\begin{proof}

Покажем, что определение отношения переходов удовлетворяют условию~\ref{transfer_tm_ir_stronger}. 

Рассмотрим случайное состояние $c \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$ и переход $c \tcarrow{t, g} c'$.

Не будем подробно рассматривать случаи $g = thread\_create$, $g = thread\_join$, так как эти переходы не меняют состояния анализа предикатов и не меняют состояние памяти ($c_l$ и $c_g$). Поэтому в этом случае $c, c' \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$.

Рассмотрим теперь случай $g = assign$ или $g = assume$. Зафиксируем значение $k$ такое, что $t_k = t$. Будем рассматривать переход в потоке из состояния $e_k$.

$e_k \tatarrow{\tau} e_k'$, $e_k \tat{\tau} i' = (\theta_{X^{local},env}(e),\theta_{X^{local},env}(SP_{op}(e_k))$. 
$\forall j \neq k: e_j \tat{i'} e_j'$.
Переход по эффекту окружения возможен, так как состояния являются совместными -- к ним был применим оператор $epp$.

Проверим совместность состояний $e_k'$ и $e_j'$ ($j \neq k$), где $e_k' = (SP_{op}(e_k))^\pi$, $e_j' = (e_j \land \theta_{X^{local},env}(SP_{op}(e_k))^\pi$. 
Заметим, что $\exists v': v' \models e_k'$, иначе перехода $c \tat{t, g} c'$ не было бы.
Кроме того, известно, что $\exists v: v \models e_k \land e_j$, так как состояния были совместны.
Если же не существует такого $\widehat{v}$, который $v' \models e_k' \land e_j'$, это означает, что не существует одинаковых значений глобальных переменных для всех потоков, то есть, перехода $c \tat{t, g} c'$ быть не может.

%Consider an arbitrary $c = (c_{pc}, c_l, c_g, c_s) \in \conc{R}$ and an arbitrary $c'= (c_{pc}', c_l', c_g', c_s'): c \tcarrow c'$.

%\begin{align}
%& c \in \conc{R} \Leftrightarrow \exists e_1 \dots e_n \in R: compatible^E(\{e_1, \dots, e_n\}) \land c \in \epp (\{e_1, \dots, e_n\}) \nonumber 
%\end{align}

%\begin{enumerate}
%\item If $c \tcarrow c'$ does not change $c_g$ and $c_l$, it means $c' \in \conc{R}$, as $\epp$ operator does not limit $c_{pc}$ and $c_s$.
%
%\item If $c \tcarrow c'$ changes only $c_l$.
%So, $\exists i: (t_i \mapsto cl_i) \in c_l$ changed into $(t_i \mapsto cl_i') \in c_l'$.
%We do not know the particular $i$, anyway we consider all $e \tat{\tau} e', e \in R$.
%By the definition $e' = (SP_{op}(e))^\pi$.
%The requirement for $SP_{op}(e)$: $cl_i \models e \implies cl_i' \models e' = SP_{op}(e)$.
%That means $c' \in \epp (\{e_1, \dots, e_i', \dots, e_n\})$
%
%\item If $c \tcarrow c'$ changes $c_g$. So, $\exists g \in G, t \in T: c \tc{g, t} c'$.
%The operation $g$ can be applied to one of $e_i$: $e_i \tat{\tau} e_i'$ and $e_i \tat{\tau} i'$. $compatible^E(\{e_1, \dots, e_n\}) \implies compatible_{TM}(e_i, i')$
%That means we may apply $e_i' \tat{i'} e_i''$. The requirement $\forall i: c_g \models e_i \implies c_g' \models e_i'' = SP_{op}(e_i)$.
%Then, $c' \in \epp (\{e_1'', \dots, e_n''\})$.
%
%\end{enumerate}
\end{proof}

{\textbf 4.} Оператор слияния состояний не объединяет элементы: $merge^E_{P}(e, e', \pi) = e'$. Требование~\ref{cpa_merge_tm_e_eq} очевидно выполнено, так как $e' \sqsubseteq e'$.

{\textbf 5.} Оператор слияния состояний не объединяет элементы: $merge^I_{Sep}(i, i', \pi) = i'$. 
Требование~\ref{cpa_merge_tm_i_eq} очевидно выполнено, так как $i' \sqsubseteq i'$.

Options: 
\begin{enumerate}
\item merge second elements of inference objects (modifications) for equal (or covered) first elements (start states).
$$merge^I_{Eq}(i, i', \pi)= 
\left\lbrace\begin{array}{ll}
(e, \varphi \lor \varphi'), & \mbox{ if } e = e' \\
i', &\mbox{ otherwise}.\\
\end{array}
\right.$$
\item merge first and second elements
$$merge^I_{Join}(i, i', \pi)= 
(e \lor e', \varphi \lor \varphi')$$
\end{enumerate}

{\textbf 6.} Оператор останова проверяет, покрыто ли состояние $e$ другим состоянием из множества достижимых состояний: $stop^E_{P}(e, R, \pi) = \exists e'\in R: (e \sqsubseteq e')$.

\begin{proof}
Проверим, что требование~\ref{cpa_stop_tm_e_eq} выполнено.
\begin{align}
&\forall e \in E, R, \widehat{R} \subseteq E, \pi \in \Pi: \nonumber \\
& e \sqsubseteq e' \implies (eq.~\ref{cpa_conc_eq_2}) \implies \conctm{\widehat{R} \cup R \cup e} \subseteq \conctm{\widehat{R} \cup R \cup e'} \implies \nonumber \\
& \implies (eq.~\ref{cpa_conc_eq_0}) \implies \conctm{\widehat{R} \cup e} \subseteq \conctm{\widehat{R} \cup R} \nonumber
\end{align}
\end{proof}

{\textbf 7.} Оператор останова для эффектов окружения проверяет, может ли изменить состояние этот эффект и не покрыт ли он другим эффектом окружения, находящимся во множестве достижимых состояний:  $i=(\psi,\varphi)$
$stop^I_{P}(i, R, \pi) = (\varphi=true) \lor \exists i'\in R: i' \sqsubseteq i$.

\begin{proof}
Требование~\ref{cpa_stop_tm_i_eq} может быть проверено по аналогии с п. 6. 
\end{proof}

{\textbf 8.} $prec^E_{P}(e, \pi, R) = (e, \pi)$. Условие~\ref{prec_tm_e_equation} выполнено, так как $e \sqsubseteq e$.

{\textbf 9.} $prec^I_{P}(i, \pi, R) = (i, \pi)$. Условие~\ref{prec_tm_i_equation} выполнено, так как $e \sqsubseteq e$.

{\textbf 10.} Проверка совместности была определена в~\ref{cpa_predicate_compatible}.

\section{Анализ примитивов синхронизации}
\label{sect_lock_analysis}

\newcommand{\bots}{\bot_\mathcal{S}}
\newcommand{\tops}{\top_\mathcal{S}}

Определим анализ примитивов синхронизации (Lock Analysis), инвариантный к переходам по окружению, $\mathbb{S}=(D_{S},$ $\Pi_{S}, \tatarrow_{S},$ $merge^E_{S}, stop^E_{S},$ $prec^E_{S},$ $compatible_{S})$, который будет следить за множеством захваченных блокировок для каждого потока.

Он состоит из следующих компонент.

{\textbf 1.} Абстрактный домен $D_{S}=(C, \mathcal{E}, \mathcal{I},compatible^E, \epp)$ использует полурешетку
$\mathcal{E}=(E, \top^E, \bot^E, \sqsubseteq^E, \sqcup^E)$, которая состоит из множества 
$E: 2^S \cup \{\top^E, \bot^E\}$ подмножеств всех переменных синхронизации, 
где 
$\bot^E \sqsubseteq ls \sqsubseteq^E \top^E$ и $ls \subseteq ls'$ $\Rightarrow$ $ls \sqsupseteq^E ls'$ для всех элементов $ls, ls' \subseteq S$ 
(откуда следует $\bot^E \sqcup^E ls = ls$, $\top^E \sqcup ls=\top^E$, $ ls\sqcup^E ls' = ls \cap ls'$ для всех элементов $ls,ls'\subseteq S$, $ls\neq ls'$), 
и 
\begin{itemize}
\item $\forall ls_1, \dots, ls_m \in S:$
\begin{equation}
\begin{aligned}
& \epp_S \begin{pmatrix}
\begin{pmatrix}
ls_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix} = \nonumber \\
& = \begin{cases}
& \left\lbrace (c_{pc},c_l,c_g,c_s,c_t) \in C 
\left| 
\begin{array}{c}
\exists \mathbb{M} \subseteq \{1, \dots,m\} \\
dom(c) = \{t \mid t_i \in \{t_1,\dots,t_m\} \land i \in \mathbb{M}\}\\
\forall s \in S:
c_s(s) = 
\left\lbrace
\begin{array}{ll}
t_1,&\mbox{if } s \in ls_1,\\
\dots\\
t_j,&\mbox{if } s \in ls_j,\\
\cdot,& \mbox{otherwise}\\
\end{array}
\right.\\
\end{array}
\right.
\right\rbrace\\
& \mbox{if } \forall i \neq j: compatible_{TM}(ls_i, ls_j), t_i \in T, t_i \neq t_j \\
& \emptyset \mbox{ else}
\end{cases}
\end{aligned}
\end{equation}

\begin{proof}
Покажем, что требование~\ref{cpa_tm_abstract_domain_2} выполнено.

Пусть $ls \sqsubseteq ls', ls, ls', ls_1, \dots,ls_m \in E_S, t_1, \dots, t_m \in T$.

Если $\exists i, j: compatible_S(ls_i, ls_j) = false$, значит $\epp_S \begin{pmatrix}
\begin{pmatrix}
ls \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix}=\emptyset \subseteq \epp_S(ls', \dots)$.

Теперь рассмотрим случай $\forall i, j: compatible_S(ls_i, ls_j)$. 
Воспользуемся определением совместности состояний: $\forall i: ls \sqsubseteq ls' \land compatible(ls, ls_i) \implies compatible(ls', ls_i)$.

Пусть $\exists s \in S: s \in ls \setminus ls'$. Тогда
$\forall c \in \epp_S \begin{pmatrix}
\begin{pmatrix}
ls \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix}: c_s(s) = t_1$.
И $\forall c \in \epp_S \begin{pmatrix}
\begin{pmatrix}
ls' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix}: c_s(s) = \cdot$.
Это означает
$\forall c \in \epp_S \begin{pmatrix}
\begin{pmatrix}
ls \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix}: c \in \epp_S \begin{pmatrix}
\begin{pmatrix}
ls' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$

Это означает $\epp_S \begin{pmatrix}
\begin{pmatrix}
ls \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix} \subseteq \epp_S \begin{pmatrix}
\begin{pmatrix}
ls' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$
\end{proof}

\item $\mathcal{I}=\mathcal{E}$.
\end{itemize}

{\textbf 2.} В анализе применяется только одна точность: $\Pi_S = \{\pi_o\}$.

{\textbf 3.} Отношение переходов $\tatarrow_S$ содержит переход $ls \tat{\tau, g}_S (ls', \pi)$, с $g=(\cdot,op,\cdot')$ если 
\begin{itemize}
\item $op=acquire(s)$ и $s \notin ls \land ls' = ls \cup \{s\}$,
\item $op=release(s)$ и $ls' = ls \setminus \{s\}$,
\item $op=tc_{child}(l_\nu)$ и $ls' = \emptyset$. 
\item $op \neq acquire$ и $op \neq release$ и $op \neq tc_{child}$ и $ls' = ls$.
\end{itemize}

Переход $\top^E \tat{\tau, g}_S (\top^E, \pi)$ доступен для всех $g\in G$.

$\forall s,i \in E_S: compatible^E_S({s,i}) \implies s \tat{i, g}_S (s, \pi)$, потому что 
\begin{itemize}
\item переход по окружению не возможен, только если он происходит с теми же захваченными блокировками,
\item состояния являются {\em инвариантными к окружению}, то есть ни один поток не может изменить статус блокировки, захваченной в другом потоке.
\end{itemize}

Покажем, что выполнено условие~\ref{transfer_tm_ir_stronger_for_inner}. 
Рассмотрим случайное состояние $c \in \epp
\begin{pmatrix}
\begin{pmatrix}
ls_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$ и переход $c \tcarrow{t, g} c'$.

Не будем подробно рассматривать случаи $g = thread\_create$, $g = thread\_join$, так как эти переходы не меняют состояния анализа предикатов и не меняют состояние примитивов синхронизации ($c_s$). Поэтому в этом случае $c, c' \in \epp
\begin{pmatrix}
\begin{pmatrix}
ls_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$.

Рассмотрим теперь случай $g = acquire$. Зафиксируем значение $k$ такое, что $t_k = t$. Будем рассматривать переход в потоке из состояния $ls_k$.

$c \tcarrow{t, acquire s} c'$, $ls_k \tat{acquire s} ls_k'$, нужно показать, что 
$c' \in \epp
\begin{pmatrix}
\begin{pmatrix}
ls_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_k' \\
t_k 
\end{pmatrix}
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$

По определению отношения переходов $c_s'(s) = t_k$, $ls_k' = ls_k \cup \{s\}$.
Заметим, что если переход есть на конкретных состояниях, это означает, что блокировка $s$ не захвачена ни одним из потоков $t_1, \dots, t_n$.
А это, в свою очередь, означает, что $s \notin e_i, 1 \le i \le n, i \neq k$.
Таким образом, новое состояние $ls_k'$ остается совместным с остальными частичными состояниями $ls_i, i \neq k$.
По определению $\epp_S$
\begin{align}
 \begin{pmatrix}
\begin{pmatrix}
ls_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
ls_k' \\
t_k 
\end{pmatrix}
\dots& ,
\begin{pmatrix}
ls_m \\
t_m 
\end{pmatrix}
\end{pmatrix} = \nonumber \\
& = 
& \left\lbrace (c_{pc},c_l,c_g,c_s,c_t) \in C 
\left| 
\begin{array}{c}
\exists \mathbb{M} \subseteq \{1, \dots,m\} \\
dom(c) = \{t \mid t_i \in \{t_1,\dots,t_m\} \land i \in \mathbb{M}\}\\
\forall s \in S:
c_s(s) = 
\left\lbrace
\begin{array}{ll}
t_1,&\mbox{if } s \in ls_1,\\
\dots\\
t_j,&\mbox{if } s \in ls_j,\\
\cdot,& \mbox{otherwise}\\
\end{array}
\right.\\
\end{array}
\right.
\right\rbrace \subseteq \nonumber \\
& \subseteq \left\lbrace (c_{pc},c_l,c_g,c_s,c_t) \in C 
\left| 
\begin{array}{c}
dom(c) = dom(c_0)\\
c_s = c_s \cup \{s \mapsto t_k\}
\end{array}
\right.
\right\rbrace = C_0
\end{align}

Очевидно, $c' \in C_0$.
Аналогично можно проверить, что операция $g = release s$ удовлетворяет условию~\ref{transfer_tm_ir_stronger_for_inner}. 

{\textbf 4.} Оператор слияния не объединяет абстрактные состояния: $merge^E_S(e, e', \pi) = e'$.

{\textbf 5.} Оператор останова проверяет, существует ли состояние, которое содержит меньше захваченных блокировок: $stop^E_S(e, R, \pi) = (\exists e' \in R \land e \sqsubseteq e')$.
Проверим, что требование~\ref{cpa_stop_tm_e_eq} выполнено.
\begin{proof}
\begin{align}
&\forall e \in E, R, \widehat{R} \subseteq E, \pi \in \Pi: \nonumber \\
& e \sqsubseteq e' \implies (eq.~\ref{cpa_conc_eq_2}) \implies \conctm{\widehat{R} \cup R \cup e} \subseteq \conctm{\widehat{R} \cup R \cup e'} \implies \nonumber \\
& \implies (eq.~\ref{cpa_conc_eq_0}) \implies \conctm{\widehat{R} \cup e} \subseteq \conctm{\widehat{R} \cup R} \nonumber
\end{align}
\end{proof}

{\textbf 6.} Точность анализа никогда не изменяется: $prec^E_S(e, \pi, R) = (e, \pi)$.

{\textbf 7.} $compatible_S(e,i) = (e \cap i = \emptyset)$

\section{Расширенный анализ потоков}
\label{sect_simple_extended_thread_analysis}

Определим анализ потоков
$\mathbb{M}=(D_{M},$ $\Pi_{M}, \tatarrow_{M},$ $merge^E_{M}, stop^E_{M},$ $prec^E_{M},$ $compatible_{M})$, который отслеживает идентификаторы потоков.

\textbf{Основные предположения } этого анализа следующие
\begin{enumerate}
\item 
\begin{equation}
\label{main_assumption_1}
\begin{aligned}
& \forall c \tat{t, g} c': g = thread\_exit() \\
& \forall t_c \in T: (t_c, t) \notin c_m
\end{aligned}
\end{equation}
\item 
\begin{equation}
\label{main_assumption_2}
\begin{aligned}
& \forall c \tat{t, g} c': g = thread\_create(var, num, l_{\nu}) \\
& \forall n: c_t(var, n) \notin T \\
\end{aligned}
\end{equation}
\item 
\begin{equation}
\label{main_assumption_4}
\begin{aligned}
& \mbox{Для любой программы существует }{TCT}_g \subseteq X_t \to X_t: \\ % here we strongly use 2.
& \forall c,c'\in C, t\in T: c \tat{t, g} c': g = thread\_create(var, num, l_{\nu})\\
& \forall v \in X_t, n \in \mathbb{N}: c_t(v, n) = t \implies TCT_g(var) = (v)\\
& \mbox{Для создания потока в родительском потоке }t\mbox{ в } var \\
& \mbox{ та же переменная содержится в }TCT_g
\end{aligned}
\end{equation}
\end{enumerate}

%The Thread Analysis inherits the limitations of~\cite{ThreadModular03} and restricted to the programs with bounded thread creation. We suppose that the program has finite number of threads identified by the locations where they are created, i.e $T\subseteq L$ and for $thread\_create(pc_\nu)$ we always create a thread with identifier $pc_\nu$. Note, that the other analyses are not bounded.

{\textbf 1.} Абстрактный домен $D_M$ основан на плоской решетке для переменных потока $X_t$: 
$D_M = (C, \mathcal{E}, \mathcal{I}, \epp)$, with $\mathcal{E}=(E_M, \top^E, \bot^E, \sqsubseteq^E, \sqcup^E)$, $E_M = X_t \times Paths \times Paths \{Alive, Dead\} \cup \{\bot^E,\top^E\}) $,
где $Paths$ -- это множество всех возможных последовательностей $\{label_n\}^{\infty}_1$ и $label_n \in X_t \times \{Child, Parent\}$

$e = (l, pSet, tSet, status)$. $l \in X_t$, $tSet, pSet \in Paths$, $status \in \{Alive, Dead\}$.
$\bot^E \sqsubseteq \{(v, \cdot)\} \sqsubseteq^E \top^E$ и $v \neq v'$ $\Rightarrow$ $v \not\sqsubseteq^E v'$ для всех элементов $v, v'\in X_t$ 
(откуда следует $\bot^E \sqcup^E \{(v, \cdot)\} = \{(v, \cdot)\}$, $\top^E \sqcup \{(v, \cdot)\} = \top^E$, $\{(v, \cdot)\} \sqcup^E \{(v', \cdot)\} = \top^E$ для всех элементов $v,v'\in X_t$, $v\neq v'$)

\begin{itemize}
\item $\forall e_1, \dots, e_m \in E$ обозначим
\begin{equation}
\label{tct}
\begin{aligned}
& TCT(\{e_1, \dots, e_m\}) = \\
& \left\lbrace (v_j, v_i) \left|
\begin{array}{c}
\exists a > 0, 1 \le x \le m, 1 \le b \le m - a: \\
(v_i, Child) = label_a \in tSet_x \land \\
(v_j, \cdot) = label_{a+b} \in tSet_x \land \\
\forall 1 \le c < b: status_{a+c} \neq Child
\end{array}
\right.
\right\rbrace
\end{aligned}
\end{equation}

\item $\forall e_1, \dots, e_m \in E:$
\begin{equation}
\label{compatible_E_thread_M}
\begin{aligned}
& compatible_{E}(\{e_1, \dots, e_m\}) = \\
& \forall (v_i, v_j) \in TCT(\{e_1, \dots, e_m\}): \\
& (v_i, v_k) \in TCT(\{e_1, \dots, e_m\}) \implies v_k = v_j \land \\
& \forall i \neq j: compatible_{TM}(e_i, e_j) \land \\
& \forall 1 \le i \le m: status_i = Dead \implies pSet_i = tSet_i \land \\
& \forall 1 \le i \le m: (l_i, Child) \in pSet_i \land \\
& \forall 1 \le i \le m, 0 \le x \le \infty, y > x: \\
& (l_i, Child) = label_x \in tSet_i \implies \\
& \forall label_y = (v_y, status_y) \in tSet_i \land status_y = Parent
\end{aligned}
\end{equation}

Определение означает, что дерево создания потоков (ДСП) является одинаковым для каждого состояния, то есть, существует общий префикс и только один поток, в котором путь создания потоков разветвляется на два, а все остальные потоки, которые возникают после раветвления, являются уникальными.

\item $\forall e_1, \dots, e_m \in E, \forall t_1, \dots, t_m \in T:$
\begin{equation}
\label{epp_thread_M}
\begin{aligned}
& \epp_{M}
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix} = \\
& = \begin{cases}
& \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, pSet_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \mathbb{N} \\
\forall i, j \in \overline{1..m}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = \{ t_j \mapsto t_i \mid (l_j, l_i) \in TCT(\{e_1, \dots, e_m\}) \\
\end{array}
\right.
\right\rbrace, \\
& \mbox{if } compatible_{E}(e_1, \dots, e_m), t_i \neq t_j \\
& \emptyset \mbox{ else}
\end{cases}
\end{aligned}
\end{equation}

\item $\mathcal{I}=\mathcal{E}$. 
\end{itemize}

{\textbf 2.} Множество точности содержит только один пустой элемент.

{\textbf 3.} Отношение переходов $\tatarrow_F$ содержит переход $e \tat{\tau, g}_F (e', \pi)$, $g=(\cdot,op,\cdot)$, $e = (l, pSet, tSet, rSet, status), e' = (l', pSet', tSet', rSet', status')$ и $e \tat{\tau}_F (i, \pi)$, если $status = Alive$ и $i = e$ и если
\begin{itemize}
\item $op \neq tc_{parent}$, $op \neq tc_{child}$, $op \neq thread\_exit$ и $op \neq thread\_join$, $e' = e$.
\item $op=tc_{child}(var, l_\nu)$, $l' = var$. $tSet' = tSet \cup (var, Child)$, $pSet' = tSet'$ .
\item $op=tc_{parent}(var, l_\nu)$, $l' = l$. $tSet' = tSet \cup (var, Parent)$, $pSet' = pSet$.
\item $op=thread\_exit$, $l' = l$, $tSet = pSet$, $tSet' = tSet$, $status' = \{Dead\}$.
\item $op=thread\_join(var)$, $e' = e \setminus (var, Parent)$ -- это и есть абстракция: анализ не знает, завершен ли соответствующий поток или нет. Поэтому переход всегда выполняется.
\end{itemize}

Покажем, что требование ~\ref{transfer_tm_ir_stronger_for_inner} выполнено.

Рассмотрм случайное состояние $c_0 \in C: \exists m \in \mathbb{N}, e_1, \dots, e_m \in E_M, t_1, \dots, t_m \in T: c_0 \in \epp_M
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$
и случайный переход $c_0 \tc{g,t} c'$.

Так как $c_0 \in \epp_M
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$ и $c_0 \tc{t} c'$, поэтому $t \in dom(c_0)$, откуда следует $\exists k: t_k = t$. 
Зафиксируем это значение $k$, тогда $\tau$-переход выполняется из соответствующего $e_k$.
В соответствии с определением $\epp$~\ref{epp_thread_M}, зафиксируем подмножество $\widehat{\mathbb{N}} \subseteq \mathbb{N}$, такое что $\widehat{\mathbb{N}}=\{num \mid (\cdot, num) \in c^0_l\}$

По определению отношения переходов 3 имеется $e_k \tat{\tau} i_q=e_k$, $\forall q: 1 \le q \le m$. Возьмем $i_q=e_k$.

Замети, что по определению~\ref{epp_thread_M} $\forall q: 1 \le q \le m \land q \neq k: compatible(e_q, e_k)$ и определению отношения переходов 3 следует $e_q \tat{i_q} e_q$. 
Поэтому переход по эффекту окружения может быть применен, но он не изменит состояния.
Возьмем $\forall q: 1 \le q \le m \land q \neq k:$ $e_q' = e_q$ .

Пусть $c_0 = (c_{pc}^0, c_l^0, c_g^0, c_s^0, c^0_t, c^0_m)$, $c' = (c_{pc}', c_l', c_g', c_s', c_t', c_m')$, $e_k=(l_k, pSet_k, tSet_k, status_k)$, $e_k'=(l_k', pSet_k', tSet_k', status_k')$.
Обозначим $TCT(e_1, \dots, e_k, \dots, e_m) = TCT_0$;

{\textit 1)} Рассмотрим случай $g \neq thread\_create$, $g \neq thread\_join$, $g \neq thread\_exit$.

В этом случае по определению отношения переходов 3 $e_k' = e_k$. Поэтому нам нужно показать, что
$c' \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$.

По определению операций $g \neq thread\_create$, $g \neq thread\_join$, $g \neq thread\_exit$ получаем $c_t = c_t'$, $dom(c) = dom(c')$. Отсюда следует $c' \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$, так как $\epp_M$ не зависит от других частей состояний.

{\textit 2)} Рассмотрим случай $g = thread\_exit$. Нам нужно показать 
\begin{align}
& \exists k : 1 \le k \le m \land t_k = t \nonumber \\
& \exists e_1', \dots, e_m' \in E: \nonumber \\
& c' \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m' \\
t_m 
\end{pmatrix}
\end{pmatrix} \nonumber \\
& \mbox{ where } e_1', \dots, e_m' \mbox{ such that } \nonumber \\
&\exists i_1, \dots, i_{k-1}, i_{k+1}, \dots, i_m: \nonumber \\
&
\begin{cases}
\forall q \neq k, q \neq r: e_q \tat{i_q} e_q' \land i_q \in \{i \mid e_k \tat{\tau} i\} \\
e_k \tat{\tau} e_k'
\end{cases} \nonumber 
\end{align}

В этом случае по определению отношения переходов 3 $l_k'=l_k$, $tSet_k'=pSet_k$, $status_k'=Dead$ , то есть $e_k' = (l_k, pSet_k, tSet_k, Dead)$.

По определению $thread\_exit$ получаем $c_t = c_t'$, $dom(c') = (dom(c) \setminus \{t\})$.
По предположению анализа~\ref{main_assumption_1} $(\cdot, t) \notin c_m$, $c_m = c_m'$.

\begin{align}
& \epp_M
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_k' \\
t_k 
\end{pmatrix},
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix} = (def.~\ref{epp_thread_M}) =\nonumber \\
& = \begin{cases}
& \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, pSet_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \mathbb{N} \\
\forall i, j \in \overline{1..m}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = \{ t_j \mapsto t_i \mid (l_j, l_i) \in TCT(\{e_1, \dots, e_m\}) \\
\end{array}
\right.
\right\rbrace, \\
& \mbox{if } compatible_{E}(\{e_1, \dots, e_k', \dots, e_m), t_i \in T, t_i \neq t_j \\
& \emptyset \mbox{ else}
\end{cases} = \nonumber
\end{align}

Заметим, что $\forall i: 1 \le i \le m, i \neq k: tSet_i' = tSet_i$ и $tSet_k' = pSet_k$.
По предположению~\ref{main_assumption_1} $(\cdot, t) \notin c_m$, $c_m = c_m'$.
По определению $\epp$~\ref{epp_thread_M} это означает $(\cdot, l_k) \notin TCT(\{e_1, \dots, e_m\})$.
По определению $TCT$~\ref{tct} $\forall 1 \le x \le m, 0 \le a \le \infty: (\cdot, \cdot) = label_a \in tSet_x \land (l_k, Child) = label_b \in tSet_x \implies a > b$.
Поэтому это также верно для $x = k$, это означает, что $tSet$ не содержит никакую пару $(\cdot, \cdot)$ после $(l_k, Child)$.
Итак, мы показали, что $tSet_k$ не содержит никакую метку после $(l_k, Child)$, что означает
$tSet_k = pSet_k$ и $tSet_k = tSet_k'$. 
Это означает $\forall i: 1 \le i \le m: tSet_i' = tSet_i$.
$TCT$ зависит только от $tSet$ части состояния, поэтому $TCT' = TCT_0$.
Единственное условие совместности состояний, которое поменялось, это $\forall 1 \le i \le m: status_i = Dead \implies pSet_i = tSet_i$.
Так как мы только что доказали, что $pSet_k = tSet_k$ и другие состояния не изменилися, поэтому $compatible_E(e_1, \dots, e_k, \dots, e_m) = true$.

\begin{align}
& = \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \mathbb{N} \\
\forall i, j \in \overline{1..m}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = \{ t_j \mapsto t_i \mid (l_j, l_i) \in TCT(\{e_1, \dots, e_m\}) \\
\end{array}
\right.
\right\rbrace \supseteq \nonumber
\end{align}
Выберем только одно подмножество $\mathbb{N} = \widehat{\mathbb{N}}$.
\begin{align}
& \supseteq \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \widehat{\mathbb{N}} \\
\forall i, j \in \overline{1..m}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = \{ t_j \mapsto t_i \mid (l_j, l_i) \in TCT(\{e_1, \dots, e_m\}) \\
\end{array}
\right.
\right\rbrace = \nonumber
\end{align}

Заметим, что $TCT(\{e_1, \dots, e_k', \dots, e_m\}) = TCT(\{e_1, \dots, e_k, \dots, e_m\})$, откуда следует $\forall t_i: c_m(t_i) = c^0_m(t_i)$.

\begin{align}
& = \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \widehat{\mathbb{N}} \\
\forall i, j \in \overline{1..m}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = c^0_m \\
\end{array}
\right.
\right\rbrace = \nonumber
\end{align}

Заметим, что $c_0 \in \epp_M
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$.

Обозначим $dom_M\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix} = \{t \mid t = t_i \land e_i=(\cdot, \cdot, status_i) \land status_i = Alive \land i \in \overline{1..m}\}$.

Используя определение $\epp_M$~\ref{epp_thread_M} 
для $e_1, \dots, e_m$, получаем
$dom(c_0) = dom_M\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix} = \mathbb{T}$.
Для нового перехода $e_k \tatarrow e_k'$ получаем $dom_M\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_k' \\
t_k 
\end{pmatrix} ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix} = (status_k' = Dead) = dom_M\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix} \setminus \{t_k\} = \mathbb{T} \setminus \{t_k\}$
\begin{align}
& = \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, tSet_i, status_i) \\
dom(c) = \mathbb{T} \setminus \{t_k\} \\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \widehat{\mathbb{N}} \\
\forall i, j \in \overline{1..m}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = c^0_m \\
\end{array}
\right.
\right\rbrace = \tilde{C} \nonumber
\end{align}

Заметим, что $c'$ отличается от $c_0$ только $dom(c') = dom(c_0) \setminus \{t_k\}$.
Мы можем сказать, что

$c' \in \{c \mid dom(c) = dom(c_0) \setminus \{t_k\} \land c_t = c^0_{t} \land c_m = c^0_m\} = \tilde{C}$

Это означает $c' \in \epp_M
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_k' \\
t_k 
\end{pmatrix},
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$.

{\textit 3)} Рассмотрим случай $g = thread\_create(var, num, l_\nu)$, теперь нужно показать, что

\begin{align}
& \exists k : 1 \le k \le m \land t_k = t \nonumber \\
& \exists e_1', \dots, e_{m+1}' \in E: \nonumber \\
& c' \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_{m+1}' \\
t_{m+1} 
\end{pmatrix}
\end{pmatrix} \nonumber \\
& \mbox{ where } e_1' \dots e_{m+1}' \mbox{ such that } \nonumber \\
&\exists i_1, \dots, i_{k-1}, i_{k+1}, \dots, i_m: \nonumber \\
&
\begin{cases}
\forall q \neq k: e_q \tat{i_q} e_q' \land i_q \in \{i \mid e_k \tat{\tau} i\} \\
e_k \tat{\tau, tc_{parent}} e_k' \\
e_k \tat{\tau, tc_{child}} e_{m+1}'
\end{cases} \nonumber 
\end{align}

По определению $thread\_create$ 
$dom(c') = dom(c_0) \cup \{\nu\}$, $c_t' = c^0_t \cup \{(var, num) \mapsto \nu\}$, $c_m'(t) = c_m(t) \cup \{\nu\}$ и
$\forall q: 1\le q\le m: \nu \ne t_q$.
По основному предположению~\ref{main_assumption_2} 
$\forall n: c_t(var, n) \notin T$.
Пусть $t_{m+1} = \nu$ и обозначим $e_k' = (l_k', pSet_k', tSet_k', status_k')$, а $e_{m+1}' = (l_{m+1}', pSet_{m+1}', tSet_{m+1}', status_{m+1}')$.

В соответсвтии с определением переходов 3, %tc_child, tc_parent
$l_k' = l_k$ и $l_{m+1}' = var$. Поэтому
\begin{align}
& \epp_M
\begin{pmatrix}
\begin{pmatrix}
e_1' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_{m+1}' \\
\nu 
\end{pmatrix}
\end{pmatrix} = (def.~\ref{epp_thread_M}) = \nonumber \\
& = \begin{cases}
& \left\lbrace (c_{pc},c_l,c_g,c_s,c_t, c_m) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, pSet_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \mathbb{N} \\
\forall i, j \in \overline{1..m+1}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = \{ t_j \mapsto t_i \mid (l_j, l_i) \in TCT(\{e_1, \dots, e_k', \dots, e_{m+1}'\}) \\
\end{array}
\right.
\right\rbrace, \\
& \mbox{if } \forall i \neq j: compatible_{E}(\{e_1, \dots, e_k', \dots, e_{m+1}'\}), t_i \in T, t_i \neq t_j \\
& \emptyset \mbox{ else}
\end{cases} = \nonumber
\end{align}

Покажем, что $compatible_E(e_1, \dots, e_k', \dots, e_{m+1}')$.
Обозначим $e_k' = (l_k', pSet_k', tSet_k', status_k')$, $e_{m+1}' = (l_{m+1}', pSet_{m+1}', tSet_{m+1}', status_{m+1}')$.
$tSet_k' = tSet_k \cup (var, Parent)$, $tSet_{m+1}' = tSet \cup (var, Child)$.
$TCT' = TCT(\{e_1, \dots, e_k', \dots, e_{m+1}'\}) = TCT_0 \cup {(var, l_k)}$. 
Чтобы проверить $compatible_E(e_1, \dots, e_k', \dots, e_{m+1}')$, нам нужно показать три основные части:
\begin{enumerate}
\item $\forall (v_i, v_j) \in TCT(\{e_1, \dots, e_k', \dots, e_{m+1}'\}): (v_i, v_k) \in TCT(\{e_1, \dots, e_k', \dots, e_{m+1}'\}) \implies l_k = l_j$
Так как $TCT' = TCT_0 \cup {(var, l_k)}$ нам нужно проверить, есть ли другая пара $(var, \cdot)$.
Предствим, что условие нарушено и $\exists 1 \le f \le m: (var, l_f) \in TCT_0$.
Это означает, что $\exists n_v, n_f \in \mathbb{N}: c^0_m(var, n_v) = t_f \land t_f = c_t(l_f, n_f) \land TCT_g(var, l_f)$.
Теперь попытаемся выполнить переход$c_0 \tat{t, g} c'$, $g = thread\_create(var, num, l_{\nu})$ и $t \neq l_f$. 
%??????
% how follows
Этот случай противоречит основному предположению~\ref{main_assumption_4}.
Поэтому $(var, \cdot) \notin TCT_0$ и условие выполнено.
\item $\forall i \neq j: compatible_{TM}(e_i, e_j)$
Так как $\forall 1 \le i \le m, i \neq k: tSet_i' = tSet_i$ нам нужно только проверить $i = k$ и $i = m +1$.
\begin{itemize}
\item Рассмотрим $e_j:j \neq k \land j \neq m + 1$ и $e_k'$. 
$tSet_k' = tSet_k \cup (var, Parent)$. Рассмотрим случайное множество $tSet_j$. Так как известно, что $compatible(e_j, e_k)$, это означает, что 
\begin{align}
& \exists 0 \le p_1, p_2 \le \infty: var^k_{p_1} = var^j_{p_2} \land status^k_{p_1} \neq status^j_{p_2} \nonumber
\end{align}
Теперь представим, что $compatible(e_k', e_j) = false$. Так как множество $tSet_k'$ только шире, это означает, что существует такие же $p_1, p_2: var^{k'}_{p_1} = var^j_{p_2} \land status^{k'}_{p_1} \neq status^j_{p_2}$.
\item Рассмотрим $e_j:j \neq k \land j \neq m + 1$ и $e_{m+1}'$. Этот случай такой же, как и предыдущий.
\item Рассмотрим $e_k'$ и $e_{m+1}'$.
$\exists(var, Parent) \in tSet_k' \land (var, Child) \in tSet_{m+1}'$. Эта пара удовлетворяет условию на $compatible$, что означает$compatible_M(e_k, e_{m+1}')$
\end{itemize}
Так, мы показали, что все новые состояния $e_i'$ и $e_j'$ являются совместными.
\item $\forall 1 \le i \le m+1: status_i = Dead \implies pSet_i = tSet_i$.
Заметим, что $\forall 1 \le i \le m: status_i' = status_i$ и $status_{m+1}' = Alive$.
Если предыдущие состояния были совместны, тогда следующие состояния также удовлетворяют этому условию.
\item $\forall 1 \le i \le m+1: (l_i, Child) \in pSet_i$.
Заметим, что $\forall 1 \le i \le m: pSet_k' = pSet_k$. Ничего не изменилось
$pSet_{m+1} = tSet_{m+1}' = tSet_k \cup \{(var, Child)\}$ и $l_{m+1} = var$. Поэтому условие выполнено.
\item $\forall 1 \le i \le m, 0 \le x \le \infty, y > x: (l_i, Child) = label_x \in tSet_i \implies \forall label_y = (v_y, status_y) \in tSet_i \land status_y = Parent$.
Заметим, что $\forall 1 \le i \le m, i \neq k: tSet_i' = tSet_i$. Ничего не изменилось.
$tSet_k' = tSet_k \cup \{(var, Parent)\}$. Условие все еще вероне, так как мы не добавили метку $Child$.
$tSet_{m+1}' = tSet_k \cup \{(var, Child)\}$. Условие верное, так как после метки $Child$ нет ни одной метки.
\end{enumerate}

\begin{align}
& = \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \mathbb{N} \\
\forall i, j \in \overline{1..m+1}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = \{ t_j \mapsto t_i \mid (l_j, l_i) \in TCT(\{e_1, \dots, e_k', \dots, e_{m+1}'\}) \\
\end{array}
\right.
\right\rbrace \supseteq \nonumber
\end{align}

Выберем $\tilde{\mathbb{N}} = \widehat{\mathbb{N}} \cup \{num\}$.

\begin{align}
& \supseteq \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \tilde{\mathbb{N}} \\
\forall i, j \in \overline{1..m+1}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = \{ t_j \mapsto t_i \mid (l_j, l_i) \in TCT(\{e_1, \dots, e_k', \dots, e_{m+1}'\}) \\
\end{array}
\right.
\right\rbrace = \nonumber
\end{align}

Заметим, что $TCT' = TCT(\{e_1, \dots, e_k', \dots, e_{m+1}'\}) = TCT_0 \cup {(var, l_k)}$. Откуда следует $c_m'(\nu) = c_m(t_k)$.

\begin{align}
& = \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \tilde{\mathbb{N}} \\
\forall i, j \in \overline{1..m+1}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m(t_i) = \begin{cases}
c^0_m(t_i)&, \mbox{ if } i \neq m+1 \\
t&, \mbox{ if } i = m+1 \\
\end{cases}
\end{array}
\right.
\right\rbrace = \nonumber
\end{align}

Используя определение $\epp_M$~\ref{epp_thread_M}
для $e_1, \dots, e_m$ получаем
$dom(c_0) = dom_M\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix} = \mathbb{T}$.
Для нового перехода $e_k \tatarrow e_k'$ и $e_k \tatarrow e_{m+1}'$ получаем $dom_M\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_k' \\
t_k 
\end{pmatrix} ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix},
\begin{pmatrix}
e_{m+1}' \\
\nu 
\end{pmatrix}
\end{pmatrix} = (status_{m+1}' = Alive) = dom_M\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix} \cup \{\nu\} = \mathbb{T} \cup \{\nu\}$

\begin{align}
& = \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, tSet_i, status_i) \\
dom(c) = \mathbb{T} \cup \{\nu\}\\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \tilde{\mathbb{N}} \\
\forall i, j \in \overline{1..m+1}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m(t_i) = \begin{cases}
c^0_m(t_i)&, \mbox{ if } i \neq m+1 \\
t&, \mbox{ if } i = m+1 \\
\end{cases}
\end{array}
\right.
\right\rbrace = \tilde{C} \nonumber 
\end{align}.

Заметим, что $c'$ отличается от $c_0$ только $dom(c') = dom(c_0) \cup \{\nu\}$, $c_t' = c^0_t \cup \{(var, num) \mapsto \nu\}$ и $c_m'(t_k) = c^0_m(t_k) \cup \{\nu\}$.
Можно сказать, что

$c' \in \{c \in C \mid dom(c) = dom(c_0)  \cup \{\nu\} \land c_t' = c^0_t \cup \{(var, num) \mapsto \nu\} \land c_m' = c^0_m \cup \{\nu \mapsto t_k\} \} = \tilde{C}$

Это означает $c' \in \epp_M
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_k' \\
t_k 
\end{pmatrix},
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix},
\begin{pmatrix}
e_{m+1} \\
\nu 
\end{pmatrix}
\end{pmatrix}$.

{\textit 4)} Рассмотрим случай $g = thread\_join(var, num)$, теперь нужно показать, что

\begin{align}
& \exists k : 1 \le k \le m \land t_k = t \nonumber \\
& \exists r \in \overline{1..m}: \exists e_1', \dots, e_m' \in E: \nonumber \\
& c' \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_{r-1}' \\
t_{r-1} 
\end{pmatrix} ,
\begin{pmatrix}
e_{r+1}' \\
t_{r+1} 
\end{pmatrix},
\dots& ,
\begin{pmatrix}
e_m' \\
t_m 
\end{pmatrix}
\end{pmatrix} \nonumber \\
& \mbox{ where } e_1', \dots, e_{r-1}, e_{r+1}, \dots, e_m' \mbox{ such that } \nonumber \\
&\exists i_1, \dots, i_{k-1}, i_{k+1}, \dots, i_m: \nonumber \\
&
\begin{cases}
\forall q \neq k, q \neq r: e_q \tat{i_q} e_q' \land i_q \in \{i \mid e_k \tat{\tau} i\} \\
e_k \tat{\tau} e_k'
\end{cases} \nonumber 
\end{align}

По определению $thread\_join$
$\exists t: t = c_t(var, num) \land t \notin dom(c)$, $c_t' = c^0_t \setminus \{(var, num) \mapsto t\}$, $c_m' = c^0_m \setminus (t, \cdot)$.
По определению отношения переходов $transfer$~3
$e_k' = (l_k', pSet_k', tSet_k', Active)$, $tSet_k' = tSet_k \setminus \{(var, Parent)\}$, $pSet_k' = pSet_k$.

Так как $\exists t: t \notin dom(c) \land c_t(var, num) = t \land c \in \epp_M
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$, 
, это означает $\exists r: t_r = t \land e_r = (l_r, pSet_r, tSet_r, Exit)$ (определение $\epp$~\ref{epp_thread_M}).

Заметим, что $r \neq k$, потому что ни одна операция не может быть выполнена после $thread\_join$.

Сейчас нужно показать, что
$c' \in \epp_M
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}&,
\dots& ,
\begin{pmatrix}
e_{r-1} \\
t_{r-1} 
\end{pmatrix},
\begin{pmatrix}
e_{r+1} \\
t_{r+1} 
\end{pmatrix},
\dots& ,
\begin{pmatrix}
e_k' \\
t_k 
\end{pmatrix} ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}
$

\begin{align}
& \epp_M
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}&,
\dots&,
\begin{pmatrix}
e_{r-1} \\
t_{r-1} 
\end{pmatrix},
\begin{pmatrix}
e_{r+1} \\
t_{r+1} 
\end{pmatrix},
\dots& ,
\begin{pmatrix}
e_k' \\
t_k 
\end{pmatrix} ,
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix} = (def.~\ref{epp_thread_M}) = \nonumber \\
& = \begin{cases}
& \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, pSet_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
c_t = \{(l_i, num_i) \mapsto t_i\}, num_i \in \mathbb{N} \\
\forall i, j \in \overline{1..m}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = \{ t_j \mapsto t_i \mid (l_j, l_i) \in TCT(\{e_1, \dots, e_{r-1}, e_{r+1}, \dots, e_k', \dots, e_m\}) \\
\end{array}
\right.
\right\rbrace, \\
& \mbox{if } \forall i \neq j: compatible_{E}(\{e_1, \dots, e_{r-1}, e_{r+1}, \dots, e_k', \dots, e_m\}), t_i \in T, t_i \neq t_j \\
& \emptyset \mbox{ else}
\end{cases} = \nonumber
\end{align}

Покажем, что новые состояний все еще совместны.
В соответствии с основным предположением~\ref{main_assumption_1} $\forall t_c \in T: c^0_m(t_c) \neq t_r$.
Нам нужно проверить только

\begin{enumerate}
\item $\forall (v_i, v_j) \in TCT(\{e_1, \dots, e_{r-1}, e_{r+1}, \dots, e_m\}): (v_i, v_k) \in TCT(\{e_1, \dots, e_{r-1}, e_{r+1}, \dots, e_m\}) \implies v_k = v_j$.
Удаление одного состояния $e_r$ и одной метки $(l_r, Parent)$ из состояния $e_k$ может только удалить дуги и не может изменить существующие направления. Поэтому глобальная структура графа не может измениться.
\item $\forall i \neq j: compatible_{TM}(e_i, e_j)$.
По определению $\epp$~\ref{epp_thread_M} $(l_r, l_k) \in TCT_0$.
По определению TCT~\ref{tct} $\forall 1 \le x \le m: (l_r, \cdot) \in tSet_x \implies (l_k, Child) \in tSet_x$.
По определению $compatible_E$~\ref{compatible_E_thread_M} $status_r = Dead \implies pSet_r = tSet_r$.
По определению $compatible_E$~\ref{compatible_E_thread_M} $(l_r, Child) \in pSet_r = tSet_r$.
Так как $(l_r, l_k) \in TCT_0$, $tSet_r = \{\dots, (l_k, Child), (\cdot, Parent), \dots, (\cdot, Parent), (l_r, Child)\}$.
По определению $compatible_E$~\ref{compatible_E_thread_M} $tSet_k = \{\dots, (l_k, Child), (\cdot, Parent), \dots, (\cdot, Parent)\}$.
Заметим, что части последовательностей $tSet_r$ и $tSet_k$ до $(l_k, Child)$ должны быть одинаковы, иначе $TCT$ будет отличаться.
По определению $compatible_E$~\ref{compatible_E_thread_M} $compatible_{TM}(e_k, e_r)$.
Единственная возможность, чтобы быть совместными -- это $(l_r, Parent) \in tSet_k$, $l_r = var$.
Сейчас нужно показать, что после удаления $(l_r, Parent)$ из $tSet_k$ другие состояния остаются совместными.
Представим, что $\exists s \neq r: compatible(e_s, e_k) \land (compatible(e_s, e_k') = false)$. 
Это означает, что $(var, Child) \in tSet_s$. Так как $s \neq r$, $l_s \neq l_r$~\ref{main_assumption_4}.
%!!!!!!!!!!!!!!!!!

По определению $compatible_E$~\ref{compatible_E_thread_M}, $(l_s, Child) \in tSet_s$.
Более того, соответствующая метка $(l_s, Child)$ должна быть последней меткой в последовательности $tSet_s$.
$tSet_s = \{\dots, (l_r, Child), \dots, (l_s, Child)\}, (\cdot, Parent), \dots\}$.
Заметим, что части до $(l_r, Child)$ должны быть равны для обоих $tSet_r$ и $tSet_s$, иначе TCT разрушится.
Это означает, что $compatible_E(e_s, e_r) = false$.
И $\forall s: compatible(e_s, e_k) \land compatible(e_s, e_k')$
\item $\forall 1 \le i \le m: status_i = Dead \implies pSet_i = tSet_i$.
Так как статусы не менялись, условие выполнено.
\item $\forall 1 \le i \le m: (l_i, Child) \in pSet_i$.
Так как $\forall 1 \le i \le m: pSet_i' = pSet_i$ соответствующее условие выполнено.
\item $\forall 1 \le i \le m, 0 \le x \le \infty, y > x: (l_i, Child) = label_x \in tSet_i \implies  \forall label_y = (v_y, status_y) \in tSet_i \land status_y = Parent$.
Так как $\forall 1 \le i \le m, i \neq k, i \neq r: tSet_i' = tSet_i$ соответствующее условие выполнено.
$tSet_k' = tSet_k \setminus \{(l_r, Parent)\}$. Метки$(\cdot, Child)$ не изменились, поэтому условие выполено.
\end{enumerate}

\begin{align}
& = \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
\exists \mathbb{M} \subseteq \overline{1..m}: \\
c_t = \{(l_i, num_i) \mapsto t_i\} \land i \in \mathbb{M} \\
num_i \in \mathbb{N}, e_i = (l_i, \cdot), i \in \mathbb{M} \\
\forall i, j \in \mathbb{M}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = \{t_i \mapsto W_i \mid W_i = \{t_j \mid (l_j, \cdot) \in tSet_i \setminus pSet_i \}\} \\
\end{array}
\right.
\right\rbrace \supseteq \nonumber
\end{align}

Выберем $\tilde{\mathbb{M}} = \widehat{\mathbb{M}} \setminus \{r\}$.

\begin{align}
& \supseteq \left\lbrace (c_{pc},c_l,c_g,c_s, c_t) \in C 
\left| 
\begin{array}{c}
e_i = (l_i, tSet_i, status_i) \\
dom(c) = \{t \mid t = t_i \land status_i = Alive\}\\
c_t = \{(l_i, num_i) \mapsto t_i\} \land i \in \tilde{\mathbb{M}} \\
num_i \in \mathbb{N}, e_i = (l_i, \cdot), i \in \tilde{\mathbb{M}} \\
\forall i, j \in \widehat{\mathbb{M}}, i \neq j: (l_i, num_i) \neq (l_j, num_j)\\
c_m = \{t_i \mapsto W_i \mid W_i = \{t_j \mid (l_j, \cdot) \in tSet_i \setminus pSet_i \}\} \\
\end{array}
\right.
\right\rbrace = \tilde{C} \nonumber
\end{align}

$c'$ отличается от $c_0$ только удалением $(var, num)$ из $c_t$. 
Можно сказать, что

$c' \in \{c \in C \mid dom(c) = dom(c_0)  \cup \{\nu\} \land c_t' = c^0_t \setminus \{(var, num) \mapsto t_r\} \} = \tilde{C}$

Это означает $c' \in \epp_M
\begin{pmatrix}
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_k' \\
t_k 
\end{pmatrix},
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}$.

%We have the transfer $\top \tat{\tau, g}_T (\top, \pi)$ for all $g\in G$.

%$\forall t,i \in E_T: compatible^E(t,i) \implies t \tat{i, g}_T (t, \pi)$, because 
%\begin{itemize}
%\item inference object guards the transfer by checking inequality of thread identifiers in compatible,
%\item states are {\em invariant to environment}, i.e. no thread can change an identifier of the other thread.
%\end{itemize}

{\textbf 4.} Оператор слияния состояний не объединяет элементы: $merge^E_T(e, e', \pi) = e'$. Как уже было показано ранее, такой оператор слияния удовлетворяет условию~\ref{cpa_merge_tm_e_eq}.

{\textbf 5.} Оператор останова для состояний рассматривает абстрактные состояния по одному: $stop^E_T(e, R, \pi) = (e \in R)$. Как уже было показано ранее, такой оператор останова удовлетворяет условию~\ref{cpa_stop_tm_e_eq}.

{\textbf 6.} Состояния и точностть никогда не изменяются: $prec^E_T(e, \pi, R) = (e, \pi)$. Как уже было показано ранее, такой оператор удовлетворяет условию~\ref{prec_tm_e_equation}.

{\textbf 7.} 
\begin{equation}
\label{compatible_thread}
\begin{aligned}
& e = (l^e, tSet^e, status^e), i = (l^i, tSet^i, status^i), \\
& compatible_T(e,i) = \exists (var, \cdot): \\
& (var, s_e) \in tSet_e \land  (var, s_i) \in tSet_i \land s_e \neq s_i \land \\
& (var, s_e') \in tSet_e \implies s_e = s_e' \land \\
& (var, s_i') \in tSet_i \implies s_i = s_i'
\end{aligned}
\end{equation}

\section{Метод поиска состояния гонки}

Метод поиска состояний гонки содержит в себе комбинацию рассмотренных выше анализов: анализ точек программы $\mathcal{L}$, анализ потоков $\mathbb{M}$, анализ примитивов синхронизации $\mathbb{S}$ и анализ предикатов $\mathbb{P}$. 
Все эти анализы объединяются с помощью композитного анализа $\mathbb{C}$.
Операторы каждого из этих видов анализа удовлетворяют условиям~\ref{cpa_transfer_eq},~\ref{cpa_merge_tm_e_eq},~\ref{cpa_merge_tm_i_eq},~\ref{cpa_merge_tm_e_eq},~\ref{cpa_merge_tm_i_eq},~\ref{prec_tm_e_equation},~\ref{prec_tm_i_equation}, а значит, позволяют утверждать по теореме~\ref{thrm_soundness}, что множество вычесленных абстрактных состояний аппроксимирует свержу множество конкретных состояний программы.
Таким образом, если в числе абстрактных состояний программы присутствует ошибочное, значит, программа не соответствует поставленной спецификации.

Покажем, что для программы, содержащей состояний гонки в смысле определения~\ref{raceDef}, будет найдено состояние гонки.
Пусть у нас есть множество достижимых состояний $R: \exists c, c_1, c_2 \in \conc{R} \subseteq C, g_1, g_2 \in G, \widehat{t}, \overline{t} \in T, \widehat{t} \neq \overline{t}: c \tcarrow{g_1, \widehat{t}} c_1, c \tcarrow{g_2, \overline{t}} c_2$, то есть присустствует состояние гонки.
По требованию~\ref{transfer_tm_ir_stronger} 
\begin{align}
\exists e_1,\dots,e_m,e_1', \dots, e_m', e_1'',\dots,e_m'' \in R, \nonumber \\
t_1, \dots, t_n \in T, k, l \in \mathbb{N}: t_k = \widehat{t}, t_l = \overline{t} \nonumber \\
c \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1^1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_k \\
t_k 
\end{pmatrix},
\dots& ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\end{pmatrix}, \nonumber \\
e_k \tat{\tau, g_1} e_k', e_k \tat{\tau} i', e_j \tat{i'} e_j', j \neq k, \nonumber \\
e_l \tat{\tau, g_2} e_l'', e_l \tat{\tau} i'', e_j \tat{i''} e_j'', j \neq l, \nonumber \\
c_1 \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_k' \\
t_k 
\end{pmatrix},
\dots& ,
\begin{pmatrix}
e_m' \\
t_m 
\end{pmatrix}
\end{pmatrix},\nonumber \\
c_2 \in \epp
\begin{pmatrix}
\begin{pmatrix}
e_1'' \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
e_l'' \\
t_l 
\end{pmatrix},
\dots& ,
\begin{pmatrix}
e_m'' \\
t_m 
\end{pmatrix}
\end{pmatrix} \nonumber
\end{align}

Таким образом, необходимым условием состояния гонки в программе, являются четыре состояния $e_k, e_k', e_l, e_l'' \in R: e_k \tat{\tau, g_1} e_k', e_l \tat{\tau, g_2} e_l''$. 
При этом такие состояния должны быть совместнымы по требованию оператора $\epp$, а операции $g_1, g_2$ теми же, что и в определении состояния гонки~\ref{raceDef}: доступ к одной области памяти, и хотя бы одна операция записи.

Можно упростить это условие еще сильнее, так как на самом деле состояния $e_k', e_l''$ также не важны для определения состояния гонки, важен лишь сам факт наличия перехода.
Итак, можно сформулировать определение состояния гонки наабстрактных состояниях.

\begin{defn}
\label{raceDef_abstract}
Программа, для которой получено множество достижимых абстрактных состояний $R$, содержит \textbf{состояние гонки}, если $\exists e_1, e_2 \in R$, $g_1, g_2 \in G: e_1 \tat{\tau, g_1} \cdot \land e_2 \tc{\tau, g_2} \cdot$ и операции $g_1, g_2$ выполняются над одной и той же глобальной переменной $x \in X^{global}$ и хотя бы одна операция является присваиванием (то есть $assign(x, expr)$).
\end{defn}


%\newpage
%============================================================================================================================
%\section{Длинное название параграфа, в котором мы узнаём как сделать две картинки с~общим номером и названием} \label{sect2_2}
%
%А это две картинки под общим номером и названием:
%\begin{figure}[ht]
%  \begin{minipage}[ht]{0.49\linewidth}\centering
%    \includegraphics[width=0.5\linewidth]{knuth1} \\ а)
%  \end{minipage}
%  \hfill
%  \begin{minipage}[ht]{0.49\linewidth}\centering
%    \includegraphics[width=0.5\linewidth]{knuth2} \\ б)
%  \end{minipage}
%  \caption{Очень длинная подпись к изображению, на котором представлены две фотографии Дональда Кнута}
%  \label{img:knuth}  
%\end{figure}
%
%Те~же~две картинки под~общим номером и~названием, но с автоматизированной нумерацией подрисунков:
%\begin{figure}[ht]
%    {\centering
%        \hfill
%        \subbottom[List-of-Figures entry][Первый подрисунок\label{img:knuth_2_1}]{%
%            \includegraphics[width=0.25\linewidth]{knuth1}}
%        \hfill
%        \subbottom[\label{img:knuth_2_2}]{%
%            \includegraphics[width=0.25\linewidth]{knuth2}}
%        \hfill
%        \subbottom[Третий подрисунок]{%
%            \includegraphics[width=0.3\linewidth]{example-image-c}}
%        \hfill
%    }
%    \legend{Подрисуночный текст, описывающий обозначения, например. Согласно
%    ГОСТ 2.105, пункт 4.3.1, располагается перед наименованием рисунка.}
%    \caption[Этот текст попадает в названия рисунков в списке рисунков]{Очень
%    длинная подпись к второму изображению, на котором представлены две
%    фотографии Дональда Кнута}
%    \label{img:knuth_2}
%\end{figure}
%
%\section{Традиции русского набора}
%
%\subsection{Пробелы}
%
%В~русском наборе принято:
%\begin{itemize}
%    \item единицы измерения, знак процента отделять пробелами от~числа: 10~кВт, 15~\% (согласно ГОСТ 8.417, раздел 8);
%    \item $\tg 20^\circ$, но: 20~${}^\circ$C (согласно ГОСТ 8.417, раздел 8);
%    \item знак номера, параграфа отделять от~числа: №~5, \S~8;
%    \item стандартные сокращения: т.\:е., и~т.\:д., и~т.\:п.;
%    \item неразрывные пробелы в~предложениях.
%\end{itemize}
%
%\subsection{Математические знаки и символы}
%
%Русская традиция начертания греческих букв и некоторых математических
%функций отличается от~западной. Это исправляется серией
%\verb|\renewcommand|.
%\begin{itemize}
%%Все \original... команды заранее, ради этого примера, определены в Dissertation\userstyles.tex
%    \item[До:] \( \originalepsilon \originalge \originalphi\),
%    \(\originalphi \originalleq \originalepsilon\),
%    \(\originalkappa \in \originalemptyset\),
%    \(\originaltan\),
%    \(\originalcot\),
%    \(\originalcsc\).
%    \item[После:] \( \epsilon \ge \phi\),
%    \(\phi \leq \epsilon\),
%    \(\kappa \in \emptyset\),
%    \(\tan\),
%    \(\cot\),
%    \(\csc\).
%\end{itemize}
%
%Кроме того, принято набирать греческие буквы вертикальными, что
%решается подключением пакета \verb|upgreek| (см. закомментированный
%блок в~\verb|userpackages.tex|) и~аналогичным переопределением в
%преамбуле (см.~закомментированный блок в \verb|userstyles.tex|). В
%этом шаблоне такие переопределения уже включены.
%
%Знаки математических операций принято переносить. Пример переноса
%в~формуле \eqref{eq:equation3}.

%\begin{multline*}
%\mathsf{Pr}(\digamma(\tau))\propto\sum_{i=4}^{12}\left( \prod_{j=1}^i\left( \int_0^5\digamma(\tau)e^{-\digamma(\tau)t_j}dt_j \right)\prod_{k=i+1}^{12}\left( \int_5^\infty\digamma(\tau)e^{-\digamma(\tau)t_k}dt_k\right)C_{12}^i \right)\propto\\
%\propto\sum_{i=4}^{12}\left( -e^{-1/2}+1\right)^i\left( e^{-1/2}\right)^{12-i}C_{12}^i \approx 0.7605,\quad \forall\tau\neq\overline{\tau}
%\end{multline*}
%
%
%%Большая фигурная скобка только справа
%\[\left.                                                          %ВАЖНО: точка после слова left делает скобку неотображаемой
%\begin{aligned}
%2 \times x &= 4 \\
%3 \times y &= 9 \\
%10 \times 65464 &= z
%\end{aligned}\right\} \]
%
