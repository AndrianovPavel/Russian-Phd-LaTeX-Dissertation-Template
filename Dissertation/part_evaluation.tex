\chapter{Экспериментальная оценка предложенного метода}
\label{chapter_evaluation}

\newcommand{\theory}{CPALockator-Reach}
\newcommand{\theoryraces}{CPALockator-TM}
\newcommand{\combatmode}{CPALockator-Inv}
% Опции:
% Composite lattice

\section{Общая схема проведения экспериментов}

Основными целями проведения экспериментов являются:
\begin{enumerate}
\item cравнение с ведущими инструментами в области поиска состояний гонки и верификации многопоточных программ;
\item оценка различных конфигураций инструмента.
\end{enumerate}

Сравнение с ведущими инструментами статической верификации будет проводиться на наборе тестовых задач SV-COMP\footnote{https://sv-comp.sosy-lab.org/2020/}.
Категория {\em ConcurrencySafety} состоит из 1082 задач, большая часть из которых являются небольшими примерами около 100 строк кода
Для всех задач требуется доказать достижимость некоторого ошибочного состояния. 
В основном, используются т.н. выражения \textit{assert}, и требуется доказать, что условия в них не нарушаются. 
Этот набор задач содержит редко встречающиеся сложные конструкции, например, нетривиальные механизмы синхронизации, в том числе алгоритмы Деккера, Петерсона и др.
7 задач были подготовлены на основе драйверов ОС Linux. Все задачи доступны в официальном репозитории SV-COMP\footnote{https://github.com/sosy-lab/sv-benchmarks}.

Сравнение различных конфигураций инструмента будет проводиться на трех множествах задач: набор тестовых задач SV-COMP, набор задач, подготовленных на основе драйверов операционной системы Linux, и задачи, подготовленные на основе ядер закрытых операционных систем реального времени.
Верификационные задачи, основанные на драйверах операционной системы Linux, были подготовлены системой Klever, которая предназначена для верификации различного программного обеспечения~\cite{kleverPsi},~\cite{kleverIsola}.
Она разделяет большой объем целевого исходного кода на отдельные небольшие верификационные задачи.
Для ядра операционной системы Linux верификационная задача соответствует одному модулю.
Система Klever автоматически готовит модель окружения модуля, которая включает в себя модель потоков, модель сердцевины ядра и операций над модулем.
После подготовки верификационной задачи Klever запускает верификацию через общий интерфейс -- BenchExec~\cite{benchexec2019}.
Сравнение проводилось на подсистеме \textit{drivers/net/} ядра операционной системы Linux 4.2.6, для которой Klever подготовил 425 верификационных задач.

Верификационные задачи на основе ядра операционных систем реального времени были подготовлены для двух закрытых операционных систем.
Для этого были вручную выделены и закодированы те активности, которые могут выполняться параллельно при реальой работе ОС, в том числе, обработчики прерываний, системные вызовы, системные потоки и т.д.
Одна задача на основе ядра ОС РВ занимает более пятисот тысяч строк кода и содержит 497 потоков, а другая -- 350 тысяч строк кода и 37 потоков.
Так как эти задачи содержат большое количество предупреждений, в том числе истинных, в итоге при любой конфигурации становится невозможным доказать корректность.
Таким образом, для таких задач становится бессмысленным сравнивать общий вердикт, поэтому далее будет проводится сравнение количества найденных предупреждений, а также общего времени работы инструмента.

Эксперименты на наборе задач SV-COMP и наборе драйверов проводились с использованием кластера из 191 машины VerifierCloud\footnote{https://vcloud.sosy-lab.org/cpachecker/webclient/master/info}.
В нем были выбраны машины с одним типом процессора Intel Xeon E3-1230 v5, 3.40 GHz.
Были использованы ограничения по памяти в 8 Гб и по времени 15 минут.
Эксперименты на задачах, основанных на ядрах операционных систем реального времени были проведены на локальных машинах Intel Core i5-2500, 3.30 GHz.
Для проведения экспериментов была использована реализация инструмента CPALockator, которая доступна в репозитории https://svn.sosy-lab.org/software/cpachecker/branches/CPALockator-combat-mode, ревизия 32869.

Оценка различных конфигураций анализа будет проводиться для следующих настроек:
\begin{itemize}
\item PredicateCPA.
\begin{itemize}
\item Варианты реализации cpa-оператора $merge$:
\begin{itemize}
\item Join;
\item Eq;
\item Sep;
\end{itemize}
\item Оптимизация ABE (раздел~\ref{sect_predicate_abe}).
\item Оптимизация с присваиванием неопределенных функций (раздел~\ref{sect_predicate_opt}).
\item Оптимизация с применением только релевантных эффектов (раздел~\ref{sect_predicate_opt});
%\item Использование единственного эффекта "* = *";
\item Игнорирование разделяемых данных в формуле пути (раздел~\ref{sect_predicate_opt});
\item Использование локального уточнения (раздел~\ref{sect_predicate_refinement});
\end{itemize}
\item ThreadCPA.
\begin{itemize}
\item Варианты теории, лежащей в основе.
\begin{itemize}
\item Простой вариант инвариантный к эффектам окружения (раздел~\ref{sect_thread_analysis}).
\item Вариант с эффектами окружения (раздел~\ref{sect_thread_analysis_env}).
\item Сложный вариант инвариантный к эффектам окружения (раздел~\ref{sect_thread_analysis_ext}).
\end{itemize}
\item Варианты обработки повторно создаваемого потока (раздел~\ref{sect_thread_create}).
\begin{itemize}
\item Падение.
\item Игнорирование повторно создаваемого потока.
\item Абстракция от повторно создаваемого потока (создание самопараллельного потока).
\end{itemize}
\end{itemize}
\item LockCPA.
\begin{itemize}
\item Варианты реализации cpa-оператора $merge$:
\begin{itemize}
\item Join;
\item Sep;
\end{itemize}
\item Варианты реализации cpa-операторов $reduce/expand$ (раздел~\ref{subsect_lock_bam}):
\begin{itemize}
\item Использование абстракции от счетчика рекурсивных захватов блокировки.
\item Использование абстракции от неиспользуемых примитивов синхронизации.
\end{itemize}
\item Использование уточнения.
%\item Остановка анализа при превышении количества максимально-допустимого количества рекурсивных захватов блокировки.
\end{itemize}
\item Использование анализа разделяемых данных (раздел~\ref{sect_shared_analysis}).
% \item Использование ограничения на количество разрешенных уточнений.
\item Использование оптимизации BAM (раздел~\ref{sect_impl_bam}).
\item Использование анализа предикатов (раздел~\ref{sect_impl_predicate}).
% \item Использование различных способов вычисления одинаковых точек программы.
% \item Игнорирование предупреждений о состоянии гонки с пустым множеством блокировок.
\end{itemize}

Как уже было сказано, тестовые программы из набора SV-COMP содержат задачу достижимости, а для программ, построенных на основе драйверов и ядер ОС РВ, решается задача поиска состояний гонки.
Несмотря на то, что основная структура инструмента, в том числе дерево CPA, остается неизменным в обоих случаях, тем не менее, общая конфигурация требует изменений.
Кроме того, некоторые из оптимизаций накладывают дополнительные ограничения на используемую конфигурацию инструмента.
В частности, оптимизация BAM, требует использования CPA, инвариантных к окружению.
Другие опции, наоборот, определяют варианты работы с эффектами окружения, то есть, невозможно использовать единственную начальную конфигурацию инструмента для сравнения всех опций.
Чтобы отличать различные базовые конфигурации инструмента, далее будем использовать обозначение \textit{\theory} для обозначения конфигурации инструмента для решения задачи достижимости, \textit{\theoryraces} -- для обозначения конфигурации инструмента с эффектами окружения для решения задачи поиска гонок, и \textit{\combatmode} -- для обозначения конфигурации инструмента, инвариантного к эффектам окружения, для решения задачи поиска гонок.
Таким образом влияние части опций будет оценено на нескольких конфигурациях, а там, где это невозможно, будет указан тот вариант конфигурации инструмента, который поддерживает ту или иную опцию.

В следующих разделах будут представлены экспериментальные результаты для оценки влияния той или иной опции. 
После проведения всех экспериментов будут подведены итоги и сделаны выводы по результатам экспериментов.

%Было реализовано две основные модификации анализа с раздельным рассмотрением потоков с эффектами окружения
%\begin{enumerate}
%\item $\mathbb{C_1}(\mathbb{L}, \mathbb{CS}, \mathbb{T}, \mathbb{S}, \mathbb{P})$ -- включает анализ потоков, ограниченный количеством создаваемых потоков;
%\item $\mathbb{C_2}(\mathbb{L}, \mathbb{CS}, \mathbb{S}, \mathbb{P})$ -- поддерживает неограниченное создание потоков;
%\end{enumerate}
%с объединением эффектов окружения анализа предикатов $\mathbb{P}$ при равных состояниях другив видов анализа $\mathbb{T}$, $\mathbb{S}$
%(то есть, равных точках программы, стеках вызова, потоках и множествах захваченных блокировок),\\
%где
%\begin{itemize}
%\item Анализ точек программы $\mathbb{L}$~(раздел \ref{sect_location_analysis})
%\item Анализ стеков вызова $\mathbb{CS}$~(служебный анализ, не описан в теории)
%\item Анализ потоков $\mathbb{T}$~(раздел \ref{sect_thread_analysis}),
%\item Анализ примитивов синхронизации $\mathbb{S}$~(раздел \ref{sect_lock_analysis}), 
%с опцией 
%\begin{enumerate}
%\item {\em EmptyLockset=true/false}
%\begin{itemize}
%\item true -- отключить эффекты окружения, используя $empty$ эффект окружения (всегда является совместным)
%\item false -- использовать множества захваченных блокировок, как эффект окружения (проверять пересечение захваченных блокировок при вычислении совместности).
%\end{itemize}
%\end{enumerate}
%
%\item Анализ предикатов $\mathbb{P}$~(раздел~\ref{sect_predicate_analysis}).
%с опциями:
%\begin{itemize}
%\item {\em Merge=Join}. Объединение первой (условие) и второй (формула перехода) части эффекта окружения.
%\item {\em Merge=Eq}. Объединение эффектов окружения при одинаковом условии (то есть, при равных предикатных абстракциях).
%\item {\em Merge=Sep}. Не объединять эффекты никогда.
%\end{itemize}
%\end{itemize}
%
%TODO: Добавить $\mathbb{C_2}$?
%%Now only $\mathbb{C_1}$ is presented.
%
%Подходы для сравнения
%\begin{enumerate}
%\item Варианты анализа с эффектами окружения
%\begin{enumerate}
%\item {\textbf EmptyLockset} -- отключение условие на проверку множества захваченных блокировок {\em EmptyLockset=true} и {\em Merge=Join} опции в анализе предикатов.
%\item Включенная опция {\em EmptyLockset=false} с вариантами объединения для анализа предикатов
%\begin{enumerate}
%\item {\textbf MergeJoin}. Объединять обе части эффекта окружения({\em Merge=Join}). 
%\item {\textbf MergeEq}. Объединять эффекты только для равных условий ({\em Merge=Eq}).
%\item {\textbf MergeSep}. Не объединять эффекты ({\em Merge=Sep}). 
%\end{enumerate}
%\end{enumerate}
%\item {\textbf Threading}. Анализ с перебором различных чередований потоков, реализованный в концепции CPA~\cite{MEMICS16-Multi-Threaded}, который использует классический вариант теории(см. раздел~\ref{sect_classic_cpa}).
%\item Другие ведущие инструменты YogarCBMC, SMACK, CSeq, ESBMC
%\end{enumerate}

%----------------------------------------------------
\section{Сравнение различных инструментов статической верификации}

Для проведения экспериментов были выбраны следующие инструменты:

\begin{itemize}
\item PredicateTM. Реализация подхода с раздельным рассмотрением потоков с использованием анализа предикатов. 
Включает в себя следующие CPA: ThreadModularCPA, ARGCPA, CompositeCPA, LocationCPA, CallstackCPA, LockCPA, ThreadCPA, PredicateCPA.
\item ValueTM. Реализация подхода с раздельным рассмотрением потоков с использованием анализа явных значений. 
Включает в себя следующие CPA: ThreadModularCPA, ARGCPA, CompositeCPA, LocationCPA, CallstackCPA, LockCPA, ThreadCPA, ValueCPA.
\item Threading. Реализация классического варианта анализа с чередованиями потоков~\cite{MEMICS16-Multi-Threaded}. 
Реализован в том же фреймворке CPAchecker, но с использованием классической версии теории.
\item Yogar-CBMC. Победитель соревнования SV-COMP'19, реализует подход ограничиваемой проверки моделей с некоторыми оптимизациями.
\item Lazy-CSeq. Серебряный призер соревнования SV-COMP'19, реализует подход секвенциализации программы.
\end{itemize}

Результаты экспериментов представлены в таблице~\ref{table-sv-comp-tools}.
В ней представлена информация о том, сколько у каждого инструмента было выдано сообщений об ошибке (False вердикт), для скольких тестовых примеров было доказано отсутствие ошибок (True вердикт) и для скольких инструмент не смог определить вердикт.

\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-sv-comp-tools}
    \caption{Запуск на наборе задач SV-COMP}
    \begin{tabular}{ | l | c | c | c | c | c | c |}
      \hline
      		& 		\multicolumn{2}{c|}{\theory} & \multicolumn{3}{c|}{Другие инструменты}  \\
      Подход         				& PredicateTM   & ValueTM 	& Threading & Yogar-CBMC 	& Lazy-CSeq  \\ \hline
      Вердикт <<ошибка>> 			& 1028    		& 241       & 727      	& 773       	& 811       \\ 
  \hspace{0.5cm} из них корректных 	& 805 			& 59 		& 727      	& 773       	& 811       \\ 
  \hspace{0.5cm} из них некорректных & 223 			& 182 		& 0    		& 0       		& 0          \\ \hline
      Вердикт <<нет ошибки>>  		& 21      		& 20        & 165       & 284        	& 256     \\ 
  \hspace{0.5cm} из них корректных 	& 21 			& 20    	& 165       & 284        	& 256       \\
  \hspace{0.5cm} из них некорректных & 0 			& 0    		& 0       	& 0         	& 0        \\ \hline
      Анализ не завершен       		& 33     		& 821       & 190      	& 25        	& 15      \\ \hline
      Время CPU (с)   				& 23 700 		& 38 200    & 111 000  	& 7 000    		& 29 000    \\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}

Общие выводы из полученных результатов являются следующими.

Результаты подтверждают, что подход с раздельным анализом потоков не пропускает ошибок при некоторых заранее известных ограничениях.

Конфигурация ValueTM является достаточно простым и быстрым анализом, но иногда она вынуждена рассматривать все возможные варианты значений переменных, что приводит к исчерпанию ресурсов по времени.
В данном эксперименте был использован вариант анализа без уточнения, что привело к значительному повышению количества тестовых примеров, анализ которых был незавершен за отведенный лимит времени. 
Так как данный анализ является достаточно простым и используется, в основном, на модельных примерах, то реализация полноценного варианта с уточнением не была приоритетной задачей.

Классический анализ Threading является корректным и точным и не выдает ложных вердиктов.
Однако, он требует значительного числа ресурсов, это является главным недостатком подхода.
Эта конфигурация решила только один из семи сложных задач, основанных на драйверах операционной системы Linux.
Подход с раздельным анализом потоков (PredicateTM) решает пять из семи таких задач. 

Большая часть новых доказательств корректности, полученных подходом с раздельным рассмотрением потоков, (26 из 27 для PredicateTM) не находились классическим методом (Threading). Это также является одним из важных вкладов данного метода.

Подход с раздельным рассмотрением потоков выдает большое количество ложных предупреждений об ошибке. 
Большинство из них связаны с неподдерживаемыми атомарными конструкциями, такими как 'compare and swap' {\em \_\_VERIFIER\_atomic\_CAS}.
Еще в некоторых случаях данный подход не способен определить отношение happens-before между созданием потока (дочерний поток не может работать одновременно с родительским до точки своего создания).
Текущие ограничения процедуры уточнения не позволяют определять и расставлять интерполянты на поток, исходный для эффекта окружения.
В небольшой части случаев требовалось точное рассмотрение переключений между потоками.

Инструменты, основанные на других подходах, показывают отличные результаты почти на всех тестовых примерах, но ни один из них не справился со сложными задачами, основанными на драйверах ОС Linux. 
Таким образом, это подтверждает тот факт, что для решения задач, основанных на реальных программных системах, такие инструменты не подходят. 

\section{Сравнение различных вариантов анализа предикатов}

\subsection{Сравнение различных реализаций cpa-оператора merge}

Для проведения экспериментов были использованы следующие конфигурации:

\begin{itemize}
\item MergeJoin. Реализация cpa-оператора $merge_{Join}$.
\item MergeEq. Реализация cpa-оператора $merge_{Eq}$.
\item MergeSep. Реализация cpa-оператора $merge_{Sep}$.
\end{itemize}

Результаты сравнения на множестве задач SV-COMP представлены в таблице~\ref{table-sv-comp-merge}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе задач SV-COMP}
  	\label{table-sv-comp-merge}
    \begin{tabular}{ | l | c | c | c | }
      \hline
      		& 		\multicolumn{3}{c|}{\theory}  \\
      Подход         				& MergeJoin & MergeEq 	& MergeSep   \\ \hline
      Вердикт <<ошибка>> 			& 1028    	& 1028		& 977         \\ 
  \hspace{0.5cm} из них корректных 	& 805 		& 805 		& 762      \\ 
  \hspace{0.5cm} из них некорректных & 223 		& 223 		& 215        \\ \hline
      Вердикт <<нет ошибки>>  		& 21      	& 21        & 31       \\ 
  \hspace{0.5cm} из них корректных 	& 21 		& 21    	& 31        \\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0         \\ \hline
      Анализ не завершен       		& 33     	& 33        & 74       \\ \hline
      Время CPU (с)   				& 23 700 	& 24 600    & 68 100    \\ 
      \hline
    \end{tabular}
  \end{table}

MergeJoin показывает результаты лучше, чем конфигурация MergeSep.
Это происходит, в основном, из-за большого количества переходов в окружении, которые MergeSep рассматривает по одному, что приводит к большому количеству проверок совместности, вызовов cpa-операторов $stop$ и $transfer$.
MergeJoin объединяет все эффекты в один и применяет за один раз. Это позволяет сохранить огромное количество времени.
Однако, это приводит к небольшому падению точности даже на таких искусственных примерах.
%В то же время MergeSep позволяет избежать некоторых неточностей из-за анализа переходов по-отдельности и выдает меньшее количество ложных сообщений об ошибках. 

Два лишних некорректных результата были получены из-за того, что в данной конфигурации отсутствует падение инструмента при уточнении, которое присутствует в первых двух конфигурациях.
%Подробности?
Небольшое отличие времен работы MergeJoin и MergeEq объясняется некоторыми флуктуациями работы внешнего компонента -- решателя. 
Например, в некоторых примерах при одинаковом количестве уточнений построение абстракции для MergeEq занимает меньше времени, чем для MergeJoin.

Результаты экспериментов на множестве задач \textit{drivers/net/} представлены в таблице~\ref{table-drivers-merge}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе задач \textit{drivers/net/}}
  	\label{table-drivers-merge}
    \begin{tabular}{ | l | c | c | c | }
      \hline
      		& 		\multicolumn{3}{c|}{\theoryraces}  \\
      Подход         				& MergeJoin	& MergeEq 	& MergeSep   \\ \hline
      Вердикт <<ошибка>> 			& 8	    	& 7  		& 5         \\ 
  \hspace{0.5cm} из них корректных 	& 8 		& 7 		& 5      \\ 
  \hspace{0.5cm} из них некорректных & 0 		& 0 		& 0        \\ \hline
      Вердикт <<нет ошибки>>  		& 261      	& 260       & 259       \\ 
  \hspace{0.5cm} из них корректных 	& 261 		& 260    	& 259        \\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0         \\ \hline
      Анализ не завершен       		& 156     	& 158       & 161       \\ \hline
      Время CPU (с)   				& 139 000 	& 139 000   & 143 000    \\ 
      \hline
    \end{tabular}
  \end{table}

Данные результаты подтверждают основные выводы, полученные в предыдущем пункте: MergeJoin и MergeEq требуют меньше времени для получения вердикта, а использование конфигурации MergeSep не приводит к более корректным результатам. 
Значительно меньшая разница в затраченном времени между конфигурациями объясняется большим количеством таймаутов, которые возникают для всех трех конфигураций. 
Если же вычислить затраченное время для полученных вердиктов (за исключением задач, для которых анализ не был завершен), в этом случае картина будет более полярной.
Кроме того, следует помнить, что незавершенный анализ не всегда означает именно исчерпание отведенного времени, иногда это могут быть падения инструмента, которые могут случиться на первых секундах.

Основным выводом данного пункта является тот факт, что конфигурация MergeJoin является наиболее оптимальной для большинства задач: как искусственных, так и приближенных к реальным программам. 
Это объясняется тем, что при проверке многопоточной программы к ошибке обычно приводит ситуация, при которой имеет место одновременный доступ к переменной, при этом уже становится неважным, какие еще области памяти были изменены вместе с ней.
Таким образом, перебирать все возможные изменения памяти по одному, как это делает MergeSep, становится бессмысленно.

\subsection{Сравнение влияния оптимизаций}

Для проведения экспериментов были использованы следующие конфигурации:

\begin{itemize}
\item Base. Базовая реализация предикатного анализа с отключенными оптимизациями, в том числе использование SBE (англ. Single Block Encoding).
\item Undef. Оптимизация с присваиванием неопределенного значения.
\item Relevance. Оптимизация с применением только релевантных эффектов.
\item ABE. Оптимизация ABE.
%\item Havoc. Использование единственного эффекта "* = *".
% Проблемы с восстановлением пути для уточнения: какой дугой представить * = *?
\item Havoc. Игнорирование разделяемых данных в формуле пути.
\item Imprecise. Использование локального уточнения.
\end{itemize}

Результаты cравнения на множестве задач SV-COMP представлены в таблице~\ref{table-sv-comp-opt}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение оптимизаций на наборе SV-COMP}
  	\label{table-sv-comp-opt}
    \begin{tabular}{ | l | c | c | c | c | c | c | }
      \hline
      		& 		\multicolumn{6}{c|}{\theory}  \\
      Подход         				& Base 	& Undef 	& Relevance & ABE 	& Havoc 	&  Imprecise \\ \hline
      Вердикт <<ошибка>> 			& 1027  & 1033  	& 1025      & 1026  & 1052     	& 1052       \\ 
  \hspace{0.5cm} из них корректных 	& 802 	& 805 		& 802     	& 803   & 808    	& 808     	\\ 
  \hspace{0.5cm} из них некорректных & 225 	& 228 		& 223     	& 225  	& 244      	& 244       \\ \hline
      Вердикт <<нет ошибки>>  		& 21    & 21    	& 23    	& 21   	& 5     	& 2       \\ 
  \hspace{0.5cm} из них корректных 	& 21 	& 21    	& 23     	& 21   	& 5     	& 2       \\
  \hspace{0.5cm} из них некорректных & 0 	& 0    		& 0     	& 0   	& 0     	& 0       \\ \hline
      Анализ не завершен       		& 34     & 28     	& 34     	& 33   	& 25     	& 28      	\\ \hline
      Время CPU, с   				& 29 900 & 21 300 	& 29 200  	& 25 700 & 11 600   & 13 700     	\\ 
      \hline
    \end{tabular}
  \end{table}

Оптимизация Undef, как и следовало ожидать, позволяет достаточно сильно сократить затрачиваемое на анализ время, но это приводит не только к новым корректно найденным ошибкам, но и к ложным предупреждениям.
Ложные предупреждения возникают как раз из-за того, что мы абстрагируемся от конкретных значений, которые могут быть записаны в соответсвующие разделяемые переменные. 

Оптимизация Relevance практически ничего не дает, а небольшое изменение времени находится в рамках погрешности. 
Это связано с тем, что данная оптимизация показывает себя в тех случаях, когда используется достаточно большой набор предикатов для построения абстракции.
В этом случае, вычисление тех предикатов, которые являются релевантными при изменении окружения будет иметь смысл.
Для искусственных примеров SV-COMP обычно требуется лишь несколько предикатов, чтобы отсечь или подтвердить ошибку.

Оптимизация ABE заметно повышает скорость анализа, хотя и не так сильно как оптимизация Undef. Однако, в отличие от нее, ABE не приводит к некорректным результатам. 
Такой результат также является закономерным.

Оптимизации Havoc и Imprecise, по сути, являются двумя реализациями одной и той же идеи: исключение из абстракции разделяемых переменных.
Havoc исключает разделяемые переменные еще на этапе построения формулы в PredicateCPA, а Imprecise -- на этапе уточнения.
Собственно, результаты подтверждают, что исключение данных на более ранних этапах является эффективным.
Однако, что и следовало ожидать, предположение, что все разделяемые данные могут принимать любые значения, не позволяет доказать корректность нескольких примеров, что увеличивает количество ложных предупреждений об ошибках.
Положительным эффектом является обнаружение корректных ошибок в тех примерах, которые раньше приводили к исчерпанию времени в более точных конфигурациях.

Результаты сравнения на множестве драйверов \textit{drivers/net/} представлены в таблицах~\ref{table-drivers-opt}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе задач \textit{drivers/net/}}
  	\label{table-drivers-opt}
    \begin{tabular}{ | l | c | c | c | c | c | c | c |}
      \hline
      		& 		\multicolumn{6}{c|}{\theoryraces}  \\
      Подход         				& Base 		& Undef		& Relevance & ABE 		& Havoc   	& Imprecise	\\ \hline
      Вердикт <<ошибка>> 			& 5  		& 5   		& 5       	& 7   		& 17     	& 16		\\ 
  \hspace{0.5cm} из них корректных 	& 5 		& 5 		& 5     	& 7   		& 13     	& 12 		\\ 
  \hspace{0.5cm} из них некорректных & 0 		& 0 		& 0     	& 0  		& 4      	& 4 		\\ \hline
      Вердикт <<нет ошибки>>  		& 258    	& 258    	& 258     	& 260   	& 255    	& 254		\\ 
  \hspace{0.5cm} из них корректных 	& 258 		& 258    	& 258       & 260   	& 255    	& 254    	\\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0      	& 0   		& 0     	& 0     	\\ \hline
      Анализ не завершен       		& 162    	& 162    	& 162     	& 158   	& 153    	& 155    	\\ \hline
      Время CPU, с   				& 121 000 	& 116 000 	& 117 000  	& 97 400   	& 96 800    & 107 000   \\ 
      \hline
    \end{tabular}
  \end{table}

Интересное отличие от предыдущего пункта заключается в том, что оптимизация Undef не влияет на вердикты.
Это объясняется тем, что в драйверах ОС Linux редко встречается присваивание явных значений во внутренние структуры.
В основном, это может быть инициализация, которая обычно происходит в начале работы в однопоточном режиме.
А все штатные сценарии работы драйвера манипулируют внутренними данными, то есть, вычислить явное их значение при статическом анализе не удается. 
Это означает, что почти все эффекты окружения и так записывают в разделяемую память неопределенное значение, то есть оптимизация Undef теряет смысл.

Оптимизация Relevance в этом наборе более заметна, хотя и не позволяет получить новые вердикты. 
Это связано с тем, что данный набор задач является более сложным, и в некоторых случаях требуется большое количество уточнений, чтобы получить вердикт.
В том случае, если было накоплено большое множество предикатов, данная оптимизация способна ускорить работу.

Для достаточно длинных ошибочных трасс оптимизация ABE вносит более весомый вклад, так как блоки получаются более длинные за счет большого количества работы с локальными данными, чего не было в искусственных примерах SV-COMP.
Это позволяет даже получить несколько дополнительных вердиктов.

Оптимизации Havoc и Imprecise позволяют найти несколько дополнительных ошибок за счет своей скорости, однако приводит к появлению некоторых ложных предупреждений.
Тем не менее, стоит заметить, что ее точности хватает, чтобы доказать отсутствие ошибок у большого множества задач. 
Таким образом, в некоторых случаях имеет смысл жертвовать точностью, отказываясь от точного рассмотрения разделяемых данных для того, чтобы получить новые вердикты.

Сравнение оптимизации ABE на конфигурации $\combatmode$ не проводилось, так как в этом случае бы, по сути, использовалась бы исходная реализация ABE, то есть без каких-либо модификаций, а значит, никакой научной новизны такие результаты не представляют.

%  \begin{table}[h]\footnotesize \centering
%    \caption{Сравнение оптимизаций на наборе задач \textit{drivers/net/}}
%  	\label{table-drivers-opt-2}
%    \begin{tabular}{ | l | c | c |}
%      \hline
%      		& 		\multicolumn{2}{c|}{\combatmode}  \\
%      Подход         				& Base		& ABE	  	\\ \hline
%      Вердикт <<ошибка>> 				& 19  		& 33   			\\ 
%  \hspace{0.5cm} из них корректных 	& 14 		& 25 		  	\\ 
%  \hspace{0.5cm} из них некорректных & 5 		& 8 		    \\ \hline
%      Вердикт <<нет ошибки>>  		& 254    	& 255    	    \\ 
%  \hspace{0.5cm} из них корректных 	& 254 		& 255    	  	\\
%  \hspace{0.5cm} из них некорректных & 0 		& 0    		   	\\ \hline
%      Анализ не завершен       		& 152    	& 137    	   	\\ \hline
%      Время CPU, с   				& 114 000 	& 93 400 	 	\\ 
%      \hline
%    \end{tabular}
%  \end{table}
%
%Для конфигурации \combatmode также заметно большое влияние оптимизации ABE, которая позволяет получить много новых вердиктов за счет ускорения.
%
%Результаты сравнения на ядрах ОС РВ представлены в таблицах~\ref{table-os-opt-1},~\ref{table-os-opt-2}.
%
%  \begin{table}[h]\footnotesize \centering
%    \caption{Сравнение оптимизации ABE на ядрах ОС РВ}
%  	\label{table-os-opt-1}
%    \begin{tabular}{ | l | c | c | c | c |}
%      \hline
%      		& 		\multicolumn{4}{c|}{\combatmode / ОС РВ 1}  \\
%      		& 		\multicolumn{2}{c|}{Без уточнения} & \multicolumn{2}{c|}{10 итераций уточнения}  \\
%      Подход         								& Base 	& ABE 	& Base 	& ABE 		\\ \hline
%      Число предупреждений 							& 521  	& 461   & --   	& --  		\\ 
%      Общее время CPU, с							& 586  	& 582   & 10000 & 10000  		\\ 
%\hspace{0.5cm} Время на построение абстракции, с 	& 87 	& 54   	& 87 	& 48   	\\
%\hspace{0.5cm} Время на уточнение, с 				& 0 	& 0   	& 8987 	& 8121   	\\
%      \hline
%    \end{tabular}
%  \end{table}
%  
%\todo{странное отличие на ABE!}
%  
%    \begin{table}[h]\footnotesize \centering
%    \caption{Сравнение оптимизации ABE на ядрах ОС РВ}
%  	\label{table-os-opt-2}
%    \begin{tabular}{ | l | c | c | c | c |}
%      \hline
%      		& 		\multicolumn{4}{c|}{\combatmode / ОС РВ 2}  \\
%      		& 		\multicolumn{2}{c|}{Без уточнения} & \multicolumn{2}{c|}{10 итераций уточнения}  \\
%      Подход         								& Base 	& ABE 	& Base 	& ABE 		\\ \hline
%      Число предупреждений 							& 1037 	& 981   & --   	& 898  		\\ 
%      Общее время CPU, с							& 798  	& 886   & 10000 & 9881  		\\ 
%\hspace{0.5cm} Время на построение абстракции, с 	& 116 	& 71   	& 579 	& 1213   	\\
%\hspace{0.5cm} Время на уточнение, с 				& 0 	& 0   	& 6457 	& 782   	\\
%      \hline
%    \end{tabular}
%  \end{table}
%  
%В обоих случаях применение оптимизации ABE позволяет снизить количество найденных предупреждений.

\section{Сравнение различных вариантов реализации ThreadCPA}

\subsection{Сравнение различных подходов }

Для проведения экспериментов были использованы следующие конфигурации:

\begin{itemize}
\item Simple. Простой вариант инвариантный к эффектам окружения.
\item Env. Вариант с эффектами окружения.
\item Base. Расширенный вариант инвариантный к эффектам окружения.
\end{itemize}

Результаты сравнения представлены в таблице~\ref{table-svcomp-thread}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе SV-COMP}
  	\label{table-svcomp-thread}
    \begin{tabular}{ | l | c | c | c | }
      \hline
      		& 		\multicolumn{3}{c|}{\theory}  \\
      Подход         				& Simple   	& Env 		& Base  	\\ \hline
      Вердикт <<ошибка>> 			& 982    	& 973       & 972       \\ 
  \hspace{0.5cm} из них корректных 	& 793 		& 793 		& 793    	\\ 
  \hspace{0.5cm} из них некорректных & 189 		& 180 		& 179     	\\ \hline
      Вердикт <<нет ошибки>>  		& 9      	& 21        & 19       	\\ 
  \hspace{0.5cm} из них корректных 	& 9 		& 21    	& 19      	\\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0     	\\ \hline
      Анализ не завершен       		& 91     	& 88        & 91    	\\ \hline
      Время CPU, с   				& 26 800 	& 25 100    & 21 500  	\\
      \hline
    \end{tabular}
  \end{table}

% Для конфигураций Simple и Env присутствуют некоторое множество падений инструмента в различных частях инструмента, не связанных напрямую с ThreadCPA.
% Это приводит к тому, что количество выданных вердиктов уменьшается при том что общее количество затраченного времени практически не меняется.
% Тем не менее, можно заключить, что конфигурации Env и Base демонстрируют похожую точность анализа, в то время как Simple не способен доказать отсутствие ошибок для большей части примеров.
Все конфигурации демонстрируют примерно одинаковые результаты. 
Как и ожидалось, конфигурация Simple является самой слабой, что не позволяет доказать корректность нескольких задач.
Конфигурация Base немного быстрее из-за того, что она не рассматривает переходы в окружении, как Env, и является более точной, чем Simple, что также сокращает количество состояний.
% Много падений в Env из-за counterexample could not be ruled out...

Результаты сравнения на наборе \textit{drivers/net/} представлены в таблице~\ref{table-drivers-thread}.

  \begin{table}[h]\footnotesize \centering
  	\label{table-drivers-thread}
    \caption{Сравнение  на наборе \textit{drivers/net/}}
    \begin{tabular}{ | l | c | c | c | c | c |}
      \hline
      					& \multicolumn{3}{c|}{\theoryraces} 			& \multicolumn{2}{c|}{\combatmode} 	\\
      Подход         				& Simple 	& Env 		& Base 		& Simple 	& Base  	\\ \hline
      Вердикт <<ошибка>> 			& 120    	& 9   		& 10   		& 147       & 38  	 	\\ 
  \hspace{0.5cm} из них корректных 	& 10 		& 9 		& 10   		& 28       	& 29   		\\ 
  \hspace{0.5cm} из них некорректных & 110 		& 0 		& 0   		& 119       & 9     	\\ \hline
      Вердикт <<нет ошибки>>  		& 150      	& 262    	& 262    	& 145      	& 256     	\\ 
  \hspace{0.5cm} из них корректных 	& 150 		& 262    	& 262    	& 145       & 256   	\\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0     	& 0         & 0   		\\ \hline
      Анализ не завершен       		& 155     	& 154    	& 152    	& 133      	& 131   	\\ \hline
      Время CPU, с   				& 136 000 	& 136 000 	& 133 000 	& 111 000  	& 109 000   \\ 
      \hline
    \end{tabular}
  \end{table}

Реализация Simple не может точно определить, что некоторые эффекты являются несовместным, и из-за этого выдает лишние предупреждения.
При этом, такая простота реализации никак не помогает при поиске дополнительных ошибок, и время анализа, наоборот, увеличивается, так как много времени тратится на применение большого количества эффектов окружения.

Реализация Env с использованием эффектов окружения потока демонстрирует примерно такие же результаты, как и Base, так как обычно эффектов создания/удаления потока небольшое количество, и их присутствие не усложняет анализ.

Результаты сравнения реализаций ThreadCPA на ОС РВ представлены в таблице~\ref{table-os-thread}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на ядрах ОС РВ}
  	\label{table-os-thread}
    \begin{tabular}{ | l | c | c | c | c |}
      \hline
      		& 		\multicolumn{4}{c|}{\combatmode}  \\
      		& 		\multicolumn{2}{c|}{ОС РВ 1} & \multicolumn{2}{c|}{ОС РВ 2} 	\\
      Подход         					& Simple 	& Base 	& Simple 	& Base 		\\ \hline
      Число предупреждений 				& 461    	& 461   & 981     	& 981  		\\ 
      Общее время CPU, с				& 534      	& 582   & 887     	& 886  		\\ 
  \hspace{0.5cm} время ThreadCPA, с 	& 0,11 		& 0,17  & 0,148    	& 0,213   	\\
      \hline
    \end{tabular}
  \end{table}

В этом случае играет определенную роль свойство исходного кода.
Дело в том, что для ядра ОС РВ искусственно подготавливатся код, который создает все требуемые потоки, которые при реальном выполнении ОС могут быть запущены после каких-нибудь событий, например, после возникновения прерывания.
Все выделенные потоки создаются последовательно в одной функции, и в этом случае даже простой анализ потоков способен справиться, так как доступов к разделяемым данным до создания потока нет.

Основной вывод заключается в том, что в данном случае нет определенно бесполезных конфигураций. 
Env и Base обеспечивают корректные результаты на любых примерах, а конфигурация Simple может использоваться тогда, когда известны дополнительные свойства исходного кода.


\subsection{Сравнение различных вариантов обработки повторно создаваемого потока }

Для проведения экспериментов были использованы следующие конфигурации:

\begin{itemize}
\item Fail. Падение при попытке повторно создать поток.
\item Skip. Игнорирование повторно создаваемого потока.
\item Self. Абстракция от повторно создаваемого потока (создание самопараллельного потока).
\end{itemize}

Результаты сравнения на наборе SV-COMP представлены в таблице~\ref{table-svcomp-thread-create}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе SV-COMP}
  	\label{table-svcomp-thread-create}
    \begin{tabular}{ | l | c | c | c |}
      \hline
      		& 		\multicolumn{3}{c|}{\theory}  \\
      Подход         				& Fail 	& Skip 	& Self  	\\ \hline
      Вердикт <<ошибка>> 			& 972   & 989   & 1028       \\ 
  \hspace{0.5cm} из них корректных 	& 793 	& 802 	& 805    	\\ 
  \hspace{0.5cm} из них некорректных & 179 	& 187 	& 223     	\\ \hline
      Вердикт <<нет ошибки>>  		& 19    & 63    & 21       	\\ 
  \hspace{0.5cm} из них корректных 	& 19 	& 60    & 21      	\\
  \hspace{0.5cm} из них некорректных & 0 	& 3    	& 0     	\\ \hline
      Анализ не завершен       		& 91    & 30    & 33    	\\ \hline
      Время CPU, с   				& 21 500 & 22 500 & 23 600  \\ 
      \hline
    \end{tabular}
  \end{table}

Результаты реализации Fail демонструют, что в наборе SV-COMP присутствуют задачи, в которых используется создание потока с присваиванием в уже использованную структуру потока. 
Если игнорировать такие случаи и не создавать такой поток заново, это позволяет успешно доказать отсутствие ошибки для большого количества задач, однако такой подход позволяет пропустить ошибку, если ее появление зависит как раз от взаимодействия таких потоков.
Это демонстрируют три примера, в которых была пропущена ошибка.
Наиболее правильным вариантом в таком случае будет абстракция от количества созданных потоков, то есть конфигурация Self. 
Она не позволяет пропустить ошибку, но может получить большее количество вердиктов, чем конфигурация Fail.

Результаты сравнения на наборе \textit{drivers/net/} представлены в таблице~\ref{table-drivers-thread-create}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе \textit{drivers/net/}}
  	\label{table-drivers-thread-create}
    \begin{tabular}{ | l | c | c | c | c | c | c |}
      \hline
      				& 		\multicolumn{3}{c|}{\theoryraces} 		& \multicolumn{3}{c|}{\combatmode} \\
      Подход         				& Fail 		& Skip 		& Self 		& Fail 	& Skip 		& Self  \\ \hline
      Вердикт <<ошибка>> 			& 10   		& 10   		& 7   		& 37   	& 36   		& 35   \\ 
  \hspace{0.5cm} из них корректных 	& 10 		& 10 		& 7   		& 29   	& 28   		& 27   \\ 
  \hspace{0.5cm} из них некорректных & 0 		& 0 		& 0   		& 8   	& 8   		& 8   \\ \hline
      Вердикт <<нет ошибки>>  		& 262    	& 262    	& 261   	& 256   & 255  		& 255   \\ 
  \hspace{0.5cm} из них корректных 	& 262 		& 262    	& 261   	& 256   & 255   	& 255   \\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0     	& 0   	& 0   		& 0   \\ \hline
      Анализ не завершен       		& 153    	& 153    	& 157    	& 132   & 134   	& 135   \\ \hline
      Время CPU, с   				& 132 000 	& 133 000 	& 139 000 	& 110 000 & 110 000 & 116 000   \\ 
      \hline
    \end{tabular}
  \end{table}

Полученные результаты демонстрируют, что для задач из набора \textit{drivers/net/} конфигурация Self является избыточной, хотя и по-прежнему является наиболее точной.
Это объясняется особенностями модели окружения, которая отвечает за создание потоков. 
Дело в том, что для такой конфигурации становится невозможным ситуация, при которой несколько созданных потоков привязываются к одной структуре.
Зная этот факт, мы можем использовать более эффективные конфигурации Fail или Skip, которые становятся равнозначными, так как такие ситуации, приводящие к падению, произойти не могут.

Результаты cравнения на ОС РВ представлены в таблице~\ref{table-os-thread-create}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на ядрах ОС РВ}
  	\label{table-os-thread-create}
    \begin{tabular}{ | l | c | c | c | c | c | c |}
      \hline
      				& 		\multicolumn{3}{c|}{\combatmode} 		& \multicolumn{3}{c|}{\combatmode} \\
      						& 		\multicolumn{3}{c|}{ОС РВ 1} 		& \multicolumn{3}{c|}{ОС РВ 2} \\
      Подход         				& Fail 		& Skip 		& Self 		& Fail 		& Skip 		& Self  \\ \hline
      Число предупреждений			& 461   	& 461  		& 461  		& 981   	& 981   	& 981   \\ 
  	  Общее время CPU, с 			& 582 		& 565 		& 607  		& 886   	& 836	  	& 937   \\ 
\hspace{0.5cm} Время работы ThreadCPA & 0,15	& 0,17 		& 0,12 		& 0,213   	& 0,22 		& 0,16   \\ \hline
      Число созданных потоков  		& 497    	& 497    	& 497   	& 37   		& 37  		& 37   \\ 
      \hline
    \end{tabular}
  \end{table}

Эти результаты демонстрируют тот же эффект, что и результаты  сравнени на наборе \textit{drivers/net/}: используя особенности исходного кода, можно применять более эффективные в данном случае решения.
Однако, следует помнить, что такие конфигурации являются некорректными в общем случае, что подтверждают результаты на наборе SV-COMP.


\section{Сравнение различных вариантов реализации LockCPA}

\subsection{Сравнение вариантов реализации cpa-оператора $merge$}

Для проведения экспериментов были использованы следующие конфигурации:

\begin{itemize}
\item Sep. Базовая реализация LockCPA с cpa-оператором $merge_{Sep}$, при котором состояния никогда не объединяются.
\item Join. Реализация LockCPA с cpa-оператором $merge_{Join}$, при котором объединение состояний задается пересечением их множеств захваченных блокировок.
\end{itemize}

Результаты экспериментов на наборе SV-COMP представлены в таблице~\ref{table-svcomp-lock-merge}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе SV-COMP}
  	\label{table-svcomp-lock-merge}
    \begin{tabular}{ | l | c | c |}
      \hline
      		& 		\multicolumn{2}{c|}{\theory}  \\
      Подход         				&  Sep		& Join 		\\ \hline
      Вердикт <<ошибка>> 			& 1028   	& 1028   	\\ 
  \hspace{0.5cm} из них корректных 	& 805 		& 805 	 	\\ 
  \hspace{0.5cm} из них некорректных & 223 		& 223 	   	\\ \hline
      Вердикт <<нет ошибки>>  		& 21    	& 21     	\\ 
  \hspace{0.5cm} из них корректных 	& 21 		& 21    	\\
  \hspace{0.5cm} из них некорректных & 0 		& 0    	  	\\ \hline
      Анализ не завершен       		& 33    	& 33      	\\ \hline
      Время CPU, с   				& 25 600 	& 27 300  	\\ 
      \hline
    \end{tabular}
  \end{table}

Результаты не демонстрируют никакой разницы между подходами.
Это объясняется тем, что задачи в этом наборе достаточно простые, и в них практически невозможны ситуации, при которых в одной и той же точке программы могут быть захвачены различные блокировки.
Более того, почти во всех примерах вообще используется единственная блокировка, в то время как для объединения необходима хотя бы пара отличающихся состояний.

Результаты сравнения на наборе \textit{drivers/net/} представлены в таблице~\ref{table-drivers-lock-merge}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе \textit{drivers/net/}}
  	\label{table-drivers-lock-merge}
    \begin{tabular}{ | l | c | c | c | c | }
      \hline
      		& 		\multicolumn{2}{c|}{\theoryraces} 	& \multicolumn{2}{c|}{\combatmode}  \\
      Подход         				& Sep 		& Join 		& Sep 		& Join   	\\ \hline
      Вердикт <<ошибка>> 			& 31   		& 31   		& 37   		& 36   		\\ 
  \hspace{0.5cm} из них корректных 	& 23 		& 23 		& 29   		& 28     	\\ 
  \hspace{0.5cm} из них некорректных & 8 		& 8 		& 8   		& 8     	\\ \hline
      Вердикт <<нет ошибки>>  		& 253    	& 253   	& 256    	& 256      	\\ 
  \hspace{0.5cm} из них корректных 	& 253 		& 253   	& 256    	& 256     	\\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0     	& 0  		\\ \hline
      Анализ не завершен       		& 141    	& 141   	& 132    	& 133     	\\ \hline
      Время CPU, с   				& 121 000 	& 120 000 	& 110 000 	& 110 000   \\ 
      \hline
    \end{tabular}
  \end{table}

В данном случае имеют место минимальные отличия случайного характера, так как в данных задачах также используется небольшое количество блокировок. 
И даже если возможны некоторые ситуации, в которых возникнет отличие работы одного варианта LockCPA от другого, они не будут влиять на общий вердикт задачи.

Результаты сравнения на ядрах ОС РВ представлены в таблице~\ref{table-os-lock-merge}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на ядрах ОС РВ}
  	\label{table-os-lock-merge}
    \begin{tabular}{ | l | c | c | c | c | }
      \hline
      		& 		\multicolumn{4}{c|}{\theory}  \\
      		& 		\multicolumn{2}{c|}{ОС РВ 1} & \multicolumn{2}{c|}{ОС РВ 2}  \\
      Подход         					& Sep 	& Join 	& Sep 	& Join   	\\ \hline
      Число предупреждений				& 461   & 461   & 981   & 981   	\\ 
  	  Общее время CPU (с) 				& 582 	& 592 	& 886   & 889     	\\ 
  \hspace{0.5cm} Время работы LockCPA, с & 1,6 	& 1,3 	& 3,0   & 3,1     	\\ \hline
   	  Операций с блокировками			& 38526 & 41604 & 108367 & 108367      	\\ 
      \hline
    \end{tabular}
  \end{table}

%\todo{счетчик захватов}

Несмотря на некоторые отличия в количестве операций, изменение cpa-оператора $merge$ снова никак не влияет на результаты.
Таким образом, можно сделать вывод о том, что состояния LockCPA являются слишком малочисленными для каждой конкретной точки программы.
Даже если там возникают несколько состояний, одно из них будет старше по решетке, чем другие, например, не будет содержать блокировок вообще. 
А значит, операции объединения становятся бессмысленными.

\subsection{Сравнение оптимизаций BAM}

Как было описано в разделе~\ref{subsect_lock_bam}, возможно применение различных стратегий для операций $reduce$/$expand$ для LockCPA: удаление неиспользуемых примитивов синхронизации и сокращение счетчика рекурсивных захватов. 
Для сравнения были выбраны следующие варианты:

\begin{itemize}
\item None. Базовая реализация LockCPA с отключенными оптимизациями, то есть операция $reduce$ является тождественной.
\item Block. Использование абстракции от счетчика рекурсивных захватов блокировки только для тех абстрактных блоков, где не производится никаких действий с данной блокировкой.
\item All. Использование абстракции от счетчика рекурсивных захватов блокировки для всех абстрактных блоков.
\item Locks. Использование абстракции от неиспользуемых примитивов синхронизации.
\item Block-Locks. Одновременное использование и оптимизации Block, и оптимизации Locks.
\end{itemize}

Результаты сравнения на наборе \textit{drivers/net/} представлены в таблице~\ref{table-drivers-lock-reduce}

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе \textit{drivers/net/}}
  	\label{table-drivers-lock-reduce}
    \begin{tabular}{ | l | c | c | c | c | c |}
      \hline
      		& 		\multicolumn{5}{c|}{\combatmode}  \\
      Подход         				& None 	& Block 	& All 		& Locks 	& Block-Locks \\ \hline
      Вердикт <<ошибка>> 			& 35   	& 34       	& 35    	& 32       	& 32     \\ 
  \hspace{0.5cm} из них корректных 	& 27 	& 26 		& 27    	& 25       	& 25   \\ 
  \hspace{0.5cm} из них некорректных & 8 	& 8 		& 8     	& 7       	& 7    \\ \hline
      Вердикт <<нет ошибки>>  		& 255   & 255       & 255   	& 255       & 255     \\ 
  \hspace{0.5cm} из них корректных 	& 255 	& 255    	& 255   	& 255       & 255     \\
  \hspace{0.5cm} из них некорректных & 0 	& 0    		& 0     	& 0       	& 0  \\ \hline
      Анализ не завершен       		& 135    & 136      & 135    	& 138       & 134  \\ \hline
      Время CPU (с)   				& 89 600 & 91 000   & 90 000    & 90 400    & 91 700  \\ 
      \hline
    \end{tabular}
  \end{table}

В данном случае отличия являются минимальными и в рамках погрешности. 
Это объясняется тем, что в драйверах обычно используется небольшое множество примитивов синхронизации, которые редко предполагают возможность рекурсивного захвата.

Результаты сравнения на ядрах ОС РВ представлены в таблицах~\ref{table-os-lock-reduce-1},~\ref{table-os-lock-reduce-2}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на ядре ОС РВ 1}
  	\label{table-os-lock-reduce-1}
    \begin{tabular}{ | l | c | c | c | c | c | c | }
      \hline
      		& 		\multicolumn{5}{c|}{\combatmode}  \\
      Подход         						& None 			& Block 	& All		& Locks 	& Block-Locks	\\ \hline
      Число предупреждений 					& 461   		& 461       & 461   	& 461   	& 461       	\\ 
      Общее время CPU, с 					& 963 			& 759 		& 717   	& 616 		& 606 	 		\\ 
\hspace{0.5cm} Время reduce/expand при анализе, с & 0,3		& 0,4 		& 0,4   	& 0,5 		& 0,6 	  		\\ \hline
% \hspace{0.5cm} Время reduce/expand в конце, с & 0,06		& 0,08 		& 0,08   	& 0,13 		& 0,15 	  		\\ \hline
      Количество попаданий в BAM кэш		& 34305  		& 33893   	& 31656   	& 32893  	& 32893  	\\ 
      										& (47\%)		& (50\%)  	& (48\%)	& (63\%)	& (63\%)	\\
      \hline
    \end{tabular}
  \end{table}

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на ядре ОС РВ 2}
  	\label{table-os-lock-reduce-2}
    \begin{tabular}{ | l | c | c | c | c | c | c | }
      \hline
      		& 		\multicolumn{5}{c|}{\combatmode}  \\
      Подход         						& None 		& Block 	& All 		& Locks 	& Block-Locks 	\\ \hline % & All-Locks	 
      Число предупреждений 					& 981  		& 981      	& 892   	& 981   	& 981  		\\ % & 979  
      Общее время CPU, с 					& 1211 		& 1090 		& 777   	& 909 		& 858 			\\ % & 601  
\hspace{0.5cm} Время reduce/expand
 							при анализе, с	& 1,5 		& 3,7 		& 1,3   	& 1,5 		& 1,7 	 		\\ \hline % & 1,5 
% \hspace{0.5cm} Время reduce/expand в конце, с & ?		& ? 		& ?   		& ? 		& ? 	  		& 	\\ \hline
      Количество попаданий в BAM кэш		& 284253  	& 285655  	& 157505   	& 239473  	& 239473  		\\ % & 148996 	 
      										& (85\%)	& (89\%)	& (87\%)	& (91\%) 	& (91\%) 		\\ % & (91\%)	
      \hline
    \end{tabular}
  \end{table}

Для случая с ОС РВ можно сделать вывод, что использование эффективного варианта реализации $reduce/expand$ является принципиально важным, и может значительно ускорить анализ.
Это объясняется тем, что, в отличие от драйверов, в ядре операционной системе достаточно много сильно связанного кода, который может вызываться под различными блокировками.

Снижение количества найденных предупреждений для варианта All объясняется наличием сложных случаев захвата блокировки под условиями.
Например, в начале функции может быть проверка, если данная блокировка еще не захвачена, то она захватывается. 
Тогда, в случае All состояние на входе в функцию не будет содержать информацию о захваченной ранее блокировке, и она захватится второй раз.
Но на самом деле она будет захвачена дважды, что может сыграть определенную роль при ее освобождении. 

\subsection{Использование уточнения}

\begin{itemize}
\item Base. Базовая реализация LockCPA, которая рассматривает все возможные примитивы синхронизации с самого начала.
\item Refinement. Реализация LockCPA с использованием уточнения.
\end{itemize}

Результаты сравнения на наборе \textit{drivers/net/} представлены в таблице~\ref{table-drivers-lock-refinement}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе \textit{drivers/net/}}
  	\label{table-drivers-lock-refinement}
    \begin{tabular}{ | l | c | c | }
      \hline 
      		& 		\multicolumn{2}{c|}{\combatmode}  \\
      Подход         				& Base   	& Refinement \\ \hline
      Вердикт <<ошибка>> 			& 33    	& 31       \\ 
  \hspace{0.5cm} из них корректных 	& 25 		& 23 		\\ 
  \hspace{0.5cm} из них некорректных & 8 		& 8 		\\ \hline
      Вердикт <<нет ошибки>>  		& 255      	& 255       	\\ 
  \hspace{0.5cm} из них корректных 	& 255 		& 255    	\\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		\\ \hline
      Анализ не завершен       		& 137     	& 139        \\ \hline
      Время CPU (с)   				& 95 200 	& 94 100    \\ 
      \hline
    \end{tabular}
  \end{table}

В целом, результаты двух конфигураций на наборе \textit{drivers/net/} отличаются не сильно.
Это объясняется тем, что обычно используется небольшой набор примитивов синхронизации, который может быть легко вычислен за одну дополнительную итерацию уточнения.

Результаты сравнения на ядрах ОС РВ представлены в таблице~\ref{table-os-lock-refinement}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на ядрах ОС РВ}
  	\label{table-os-lock-refinement}
    \begin{tabular}{ | l | c | c | c | c | }
      \hline
      		& 		\multicolumn{4}{c|}{\combatmode}  \\
      		& 			 \multicolumn{2}{c|}{ОС РВ 1} & 		\multicolumn{2}{c|}{ОС РВ 2}\\
      Подход         					& Base  & Refinement  	& Base  & Refinement 	\\ \hline
      Выданные предупреждения			& 461   & 488    		& 981   & 1128  		\\ 
  	  Время CPU, с 						& 582   & 4952 			& 886   & 5170  		\\ 
  \hspace{0.5cm} Время на LockCPA, с	& 1,6   & 15    		& 1,7   & 4,8  			\\ \hline
      Операций с блокировками  			& 38526	& 310422   		& 108367 & 645978  		\\ 
      Количество уточнений  			& 0   	& 10   			& 0   	& 10  			\\ 
      \hline
    \end{tabular}
  \end{table}

В случае ОС РВ отличия становятся более масштабными, так как количество примитивов синхронизации резко возрастает и требуется значительное количество итераций, чтобы исключить все ложные предупреждения об ошибках, которые появились именно из-за неточностей LockCPA.
При этом возможный выигрыш из-за построения менее точной абстракции существенно меньше. 

Таким образом, можно сделать вывод, что реализация LockCPA с использованием уточнения является неэффективной и для небольших программ, и для достаточно объемных.

%На Refinement - таймаут! Поэтому не все unsafe успели уточниться.


\section{Сравнение вклада в точность анализа дополнительных CPA}

\subsection{Оценка эффекта оптимизации BAM}

\begin{itemize}
\item Base. Вариант анализа без использования BAM.
\item BAM. Использование оптимизации BAM.
\end{itemize}

Результаты сравнения на наборе \textit{drivers/net/} представлены в таблице~\ref{table-drivers-bam}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе \textit{drivers/net/}}
  	\label{table-drivers-bam}
    \begin{tabular}{ | l | c | c | }
      \hline
      		& 		\multicolumn{2}{c|}{\combatmode}  \\
      Подход         				& Base  	& BAM 	\\ \hline
      Вердикт <<ошибка>> 			& 5   		& 37    \\ 
  \hspace{0.5cm} из них корректных 	& 3 		& 29 	\\ 
  \hspace{0.5cm} из них некорректных & 2		& 8 	\\ \hline
      Вердикт <<нет ошибки>>  		& 248    	& 256    \\ 
  \hspace{0.5cm} из них корректных 	& 248 		& 256    \\
  \hspace{0.5cm} из них некорректных & 0 		& 0    	\\ \hline
      Анализ не завершен       		& 172    	& 132    \\ \hline
      Время CPU (с)   				& 51 500 	& 110 200 \\ 
      \hline
    \end{tabular}
  \end{table}

Результаты наглядно демонстрируют, что оптимизация BAM позволет значительно ускорить анализ, при этом новые ложные вердикты связаны не с самой оптимизацией BAM, а с другими свойствами анализа.
Оптимизация BAM лишь позволяет проявить эти свойства, избежав исчерпания лимита времени или памяти.
Отдельно отметим, что общее время с использованием оптимизации BAM было затрачено больше из-за большого количества падений конфигурации Base из-за нехватки памяти. 
Такие падения происходили достаточно быстро, что сокращало общее время работы.
% Большая часть Out of Memory

Результаты сравнения на ядрах ОС РВ представлены в таблице~\ref{table-os-bam}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на ядрах ОС РВ}
  	\label{table-os-bam}
    \begin{tabular}{ | l | c | c | c | c |  }
      \hline
      		& 		\multicolumn{4}{c|}{\combatmode}  \\
      		& 			 \multicolumn{2}{c|}{ОС РВ 1} & 	\multicolumn{2}{c|}{ОС РВ 2}\\ \hline
      Подход         					& Base  & BAM  		& Base  & BAM 	\\ \hline
      Выданные предупреждения			& -   	& 461  	   	& -		& 981  			\\ 
  	  Время CPU, с 						& 10024 & 582		& 7843  & 886   		\\ 
      Проанализированных потоков		& 92    & 497   	& 1  	& 37  			\\ \hline
    \end{tabular}
  \end{table}

Для анализа такого сложного исходного кода, как ядро ОС РВ, оптимизация BAM является принципиально важной.
По количеству проанализированных потоков можно оценить насколько эта оптимизация ускоряет анализ.
Дело в том, что в отличие от драйверов в ядре ОС РВ присутствует большое количество сильно связанного кода, то есть кода, доступного из многих мест. 
Это приводит к большому количеству повторно анализируемых функций, что является очень затратным, если не переиспользовать предыдущие результаты.

%\subsection{Оценка эффекта использования ограничения на количество уточнений}
%
%\begin{itemize}
%\item Unlimit. Вариант анализа без ограничения на количество уточнений.
%\item Limit = 0. Вариант анализа без уточнений.
%\item Limit = 10. Вариант анализа c использованием 10 уточнений.
%\end{itemize}
%
%% график?

\subsection{Оценка эффекта использования анализа разделяемых данных}

\begin{itemize}
\item Base. Конфигурация инструмента без использования анализа разделяемых данных.
\item Shared. Конфигурация инструмента с использованием анализа разделяемых данных.
\end{itemize}

Результаты сравнения на наборе \textit{drivers/net/} представлены в таблице~\ref{table-drivers-shared}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе \textit{drivers/net/}}
  	\label{table-drivers-shared}
    \begin{tabular}{ | l | c | c |}
      \hline
      		& 		\multicolumn{2}{c|}{\combatmode}  \\
      Подход         				& Base 	& Shared 	\\ \hline
      Вердикт <<ошибка>> 			& 31   	& 33    	\\ 
  \hspace{0.5cm} из них корректных 	& 23 	& 24 		\\ 
  \hspace{0.5cm} из них некорректных & 8 	& 9 		\\ \hline
      Вердикт <<нет ошибки>>  		& 255   & 254    	\\ 
  \hspace{0.5cm} из них корректных 	& 255 	& 254    	\\
  \hspace{0.5cm} из них некорректных & 0 	& 0    		\\ \hline
      Анализ не завершен       		& 139    & 138     	\\ \hline
      Время CPU (с)   				& 93 300 & 95 100  	\\ 
      \hline
    \end{tabular}
  \end{table}

%Из-за других уточнений наставилось много предикатов.
В данном случае использование анализа разделяемых данных не приводит к значительному улучшению.
Это объясняется тем, что выделение новой памяти и ее инициализация производится обычно на начальном этапе загрузки модуля в однопоточном режиме, и только после этого обработчики драйвера регистрируются в системе и становятся доступными для вызова. 
Таким образом, анализ потоков успешно справляется с задачей исключения таких ложных ситуаций без анализа разделяемых данных.

Некоторое незначительное ухудшение работы связано с тем, что, тем не менее, некоторые пути к доступам к данным, ранее считавшихся разделяемыми, были отброшены в конфигурации Shared.
И вместо отброшенных путей стали рассматриваться другие, которые содержали более сложные условия для анализа предикатов, что привело к более длительной процедуре уточнения и построению более детальной абстракции.

Результаты сравнения на ядрах ОС РВ представлены в таблице~\ref{table-os-shared}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на ядрах ОС РВ}
  	\label{table-os-shared}
    \begin{tabular}{ | l | c | c | c | c |  }
      \hline
      		& 		\multicolumn{4}{c|}{\combatmode}  \\
      		& 			 \multicolumn{2}{c|}{ОС РВ 1} & 	\multicolumn{2}{c|}{ОС РВ 2}\\
      Подход         					& Base  & Shared  	& Base  & Shared 	\\ \hline
      Выданные предупреждения			& 461   & 218    	& 981   & 447  			\\ 
  	  Время CPU, с 						& 582   & 1034  	& 886   & 568  		\\ 
  	  \hspace{0.5cm} Преданализ, с 		& --   	& 21  		& --   	& 19  		\\ 
      \hline
    \end{tabular}
  \end{table}

В данном случае анализ разделяемых данных значительно сокращает количество ложных предупреждений об ошибках, так как отсутствуют секции инициализации данных.
Таким образом, только анализ разделяемых данных может определить, что предупреждения является ложным.

Некоторое увеличения времени анализа не связано напрямую с анализом разделяемых данных, а происходит из-за дополнительных расходов на вычисление статистики.
% Время тратится на вычисления покрытия с BAM внутри restartAlgorithm, в ОС 1 кэш устроен значительно сложнее.
Это время является незначительным для второго случая из-за отличий кода.

\subsection{Оценка эффекта использования предикатного анализа}

\begin{itemize}
\item Predicate. Вариант анализа с использованием предикатной абстракции.
\item Lightweight. Использование анализа без использования предикатной абстракции
\end{itemize}

Результаты экспериментов на наборе SV-COMP представлены в таблице~\ref{table-svcomp-without-predicate}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе SV-COMP}
  	\label{table-svcomp-without-predicate}
    \begin{tabular}{ | l | c | c |}
      \hline
      		& 		\multicolumn{2}{c|}{\combatmode}  \\
      Подход         				&  Predicate	& Lightweight 		\\ \hline
      Вердикт <<ошибка>> 			& 1028   		& 1058   	\\ 
  \hspace{0.5cm} из них корректных 	& 805 			& 808 	 	\\ 
  \hspace{0.5cm} из них некорректных & 223 			& 250 	   	\\ \hline
      Вердикт <<нет ошибки>>  		& 21    		& 0     	\\ 
  \hspace{0.5cm} из них корректных 	& 21 			& 0    		\\
  \hspace{0.5cm} из них некорректных & 0 			& 0    	  	\\ \hline
      Анализ не завершен       		& 33    		& 24      	\\ \hline
      Время CPU, с   				& 25 600 		& 8 020  	\\ 
      \hline
    \end{tabular}
  \end{table}

Результаты подтверждают тот факт, что без анализа предикатов невозможно доказать недостижимость ошибочной метки, то есть корректность задачи, так как во всех задачах так или иначе присутствует условие.
Другими словами, все ошибочные метки являются синтаксически достижимыми.
% Сравнивать на sv-comp глупо, так как там всегда есть зависимости по данным

Результаты сравнения на наборе \textit{drivers/net/} представлены в таблице~\ref{table-drivers-predicate}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе \textit{drivers/net/}}
  	\label{table-drivers-predicate}
    \begin{tabular}{ | l | c | c | c | c |}
      \hline
      & 			 \multicolumn{2}{c|}{\theoryraces} & 	\multicolumn{2}{c|}{\combatmode}\\
      Подход         				& Predicate & Lightweight 	& Predicate & Lightweight\\ \hline
      Вердикт <<ошибка>> 			& 31   		& 144   	& 37   		& 168  	\\ 
  \hspace{0.5cm} из них корректных 	& 23 		& 86 		& 29   		& 86 	\\ 
  \hspace{0.5cm} из них некорректных & 8 		& 58 		& 8   		& 82 	\\ \hline
      Вердикт <<нет ошибки>>  		& 253    	& 226    	& 256   	& 226 	\\ 
  \hspace{0.5cm} из них корректных 	& 253 		& 226    	& 256   	& 226 	\\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0   		& 0 	\\ \hline
      Анализ не завершен       		& 128    	& 55    	& 132   	& 31  	\\ \hline
      Время CPU (с)   				& 121 000 	& 37 700 	& 110 000  	& 14 200\\ 
      \hline
    \end{tabular}
  \end{table}

Результаты показывают, что использование анализа предикатов существенно повышает точность анализа, хотя для некоторых примеров оказывается возможным доказать отсутствие состояний гонки и без него.

Результаты сравнения на ядрах ОС РВ представлены в таблице~\ref{table-os-predicate}.

  \begin{table}[h] \footnotesize \centering
    \caption{Сравнение различных вариантов реализации cpa-оператора $merge$}
  	\label{table-os-predicate}
    \begin{tabular}{ | l | c | c | c | c |  }
      \hline
      		& 		\multicolumn{4}{c|}{\combatmode}  \\
      		& 			 \multicolumn{2}{c|}{ОС РВ 1} & 	\multicolumn{2}{c|}{ОС РВ 2}\\
      Подход         					& Predicate  & Lightweight 	& Predicate  & Lightweight 	\\ \hline
      Выданные предупреждения			& 461   	& 521    		& 981   	& 1037  			\\ 
  	  Время CPU, с 						& 582   	& 107  			& 886   	& 195  		\\ 
      \hline
    \end{tabular}
  \end{table}
  
Заметим, что даже без использования уточнения предикатный анализ способен сократить количество ложных срабатываний за счет оптимизации ABE, которая способна отсекать недостижимые пути в рамках одного блока, в котором строится полная формула пути.
При этом для дальнейшего отсеивания ложных предупреждений необходмо проведение процедуры уточнения для добавления предикатов.

%----------------------------------------------------
\section{Анализ причин пропуска ошибок}

Анализ причин пропуска ошибок производился на множестве задач, полученных на основе существующих исправлений в стабильных версиях ядра Linux\,\footnote{https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git} за 2014 год.
Из всего множества в 4047 коммитов по ключевым словам было выделено 795 коммитов, которые были проанализированы вручную.
Ключевыми словами были слова, связанные с исправлением ошибки: fix, error, race, bug, failure, crash и др. 
Подробно методика анализа коммитов описана в работе~\cite{commit_analysis_12}.
Из полученного списка были выделены коммиты, исправляющие ошибки, связанные с состояниями гонки по данным.
То есть, в это множество не включались высокоуровневые гонки.
Из полученных 43 коммитов были исключены те, в которых встречались примитивы синхронизации, не основанные на блокировках, так как инструмент в данный момент не поддерживает другие примитивы синхронизации.
Далее, из множества в 28 коммитов были исключены те, которые не относились к модулям ядра, так как это является ограничением системы подготовки задач Klever.
В полученном списке осталось 13 коммитов, для каждого из которых была запущена система Klever с целью подготовки верификационных задач.
Для 5 модулей не были получены задачи из-за внутренних проблем системы Klever (падения компонентов).
Оставшиеся 8 задач были получены, и на них производился запуск иструмента CPALockator с целью проверить, обнаруживается ли то состояние гонки, которое исправляется в данном коммите.


  \begin{table}[h] \footnotesize \centering
    \caption{Результаты запуска инструмента на известных ошибках в стабильных версиях ядра ОС Linux}
  	\label{table-commits}
    \begin{tabular}{ | l | l | c | l |}
      \hline
      Коммит         	& Модуль    & Рез-т  & Комментарий \\ \hline
      0e2400e			& drivers/char/virtio\_console.ko    & $+$   		& 	\\ 
      7357404			& fs/hfsplus/hfsplus.ko    & $\pm$   		& 	Спец. конфигурация\\ \hline
      f1a8a3f			& drivers/net/bonding/bonding.ko    & $\mp$   		& Спец. конфигурация; нецелевая ошибка \\ %Nontarget bug was found	\\ 
      1a81087			& net/ipv4/tcp\_illinois.ko    & $\pm$   		& Найдена нецелевая ошибка \\
      f0c626f			& drivers/target/iscsi/iscsi\_target\_mod.ko    & $\mp$   		& Спец. конфигурация; нецелевая ошибка \\ \hline %Nontarget bug was found	\\ \hline
      aea9dd5			& fs/btrfs/btrfs.ko    & $-$   		& \\ %Timeout	\\ 
      10ef175			& sound/soc/snd-soc-core.ko    & $-$   		& Таймаут	\\ 
      4036523			& drivers/gpu/drm/i915/i915.ko    & $-$   		& \\ 
      \hline
    \end{tabular}
  \end{table}

Результаты анализа полученных 8 задач представлены в таблице~\ref{table-commits}.
Ошибки обозначаются идентификаторами коммитов, исправляющими ошибку.
Соответственно, верификационная задача была получена для состояния репозитория для предыдущего коммита, то есть, до исправления.
Подробное описание исправлений приведено в приложении~\ref{sect_commits_desc}.

Таким образом, из 8 коммитов
\begin{itemize}
\item В двух модулях однаруживаются именно те ошибки, которые исправляются в коммитах.
Для этих задач были подготовлены парные задачи для состояния репозитория после исправления.
Для одного модуля соответствующее предупреждение пропадает полностью, а для другого выдается новое предупреждение об ошибке, но уже ложное.
Это подтверждает корректность обнаружения ошибки.

\item Еще в трех модулях однаруживаются другие, нецелевые состояния гонки на ту же переменную, что и исправляется в коммите. 
Из-за того, что CPALockator выдает только одно предупреждение для каждой переменной, целевой исправление не было обнаружено.

\item Три модуля являются слишком объемными, что приводит к исчерпанию лимита времени (15 минут) при их анализе.

\end{itemize}

Ошибки, которые исправляются в коммитах 7357404, f1a8a3f, f0c626f, находятся только при ограниченном количестве итераций CEGAR.
В противном случае за отведенные лимиты времени CPALockator не успевает исключить все ложные пути. 
При ограничении количества итераций CEGAR уточнение будет прервано, и все оставшиеся предупреждения будут выданы.

%Так как высокоуровневые гонки, ошибки использования памяти после исправления не являются гонками по данным в смысле определения~\ref{raceDef}, такие ошибки не являются целевыми для инструмента CPALockator в текущей конфигурации, хотя в перспективе он может быть расширен для поддержки других типов ошибок.
%Подготовка модели окружения не является задачей инструмента CPALockator.
%Таким образом, 10 из 18 исправлений не могут быть найдены по внешним причинам.

Таким образом, 5 из 8 (62,5\%) выбранных исправлений так или иначе находятся.
Для оставшихся трех задач был выдан вердикт \textit{unknown}.
Это демонстрирует, что инструмент CPALockator способен не пропускать ошибки при заранее известных ограничениях.

\section{Анализ причин ложных срабатываний}

\subsection{Ложные предупреждения на драйверах ОС Linux}

Анализ ложных предупреждений проводился на задачах, основанных на драйверах подсистемы \textit{drivers/net/} ОС Linux, которые были использованы для сравнения конфигураций.
%Стоит отметить, что в данном случае будут рассматриваться ложные предупреждения в целом, а не только из-за инструмента CPALockator.
%Таким образом, количество ложный предупреждений будет выше, чем при анализе различных конфигураций, так как в тех разделах не учитывались неточности, связанные с подготовкой верификационной задачи.
Для 473 задач из подсистемы \textit{drivers/net/} было подготовлено 425 задач.
Для 261 было доказано отсутствие ошибок.
Потенциальные состояния гонки были обнаружены в 22 задачах.
При этом только для 8 задач был выдан финальный вердикт \textit{false}.
На остальных 161 задаче анализ завершился с вердиктом \textit{unknown} из-за исчерпания лимита времени в 15 минут.
При этом для 14 задач инструмент выдал некоторое количество предупреждений, несмотря на завершение по таймауту.
Так, для 22 задач было получено 85 предупреждений. 
Эти предупреждения были проанализированы вручную, и в таблице~\ref{table-unsafes} представлены результаты их анализа.

\begin{table}[h] \footnotesize \centering
    \caption{Анализ предупреждений в модулях ядра ОС Linux}
  	\label{table-unsafes}
    \begin{tabular}{ | l | c | l |}
      \hline
      Количество &	Процент    	& Описание \\ \hline
      41		&	48\%     	& Истинных предупреждений	\\ 
      25		&	29\%     	& Неточность подготовки задачи	\\ 
      19		&	22\%     	& Неточность метода	\\ \hline
      \hspace{1cm}8   &	9\%     	& Неточность модели памяти	\\ 
      \hspace{1cm}7	  &	8\%     	& Специфика ядра ОС (прерывания)  \\
      \hspace{1cm}4	  &	5\%     	& Неточность отдельных CPA 	\\ 
      \hline
    \end{tabular}
  \end{table}

Потенциальным ошибкам соответствовало 41 предупреждений (48\%).
При этом 10 из них были отмечены, как безобидные. 
Это, например, состояния гонки на счетчиках статистики, при печати вспомогательной информации на экран и т.~п.
Большая часть найденных ошибок (18 предупреждений) соответствует ситуации, при которой новый поток создается в тот момент, когда еще не завершена инициализация основных данных драйвера.
Например, регистрация структуры девайса или регистрация обработчиков прерывания может происходить до того, как выделяется память под те данные, которые могут быть использованы в обработчиках этого девайса. 
При этом для каждого устройства возможно некоторая защита на уровне железа. 
Например, обработчик прерывания регистрируется в системе, однако соответствующие прерывания само устройство может генерировать только значительно позже.
Такие свойства очень сложно обнаружить только по исходному коду драйвера.
Важно отметить, что для одного состояния гонки может быть выдано несколько предупреждений на различные переменные, работа с которыми производится похожим образом.
Поэтому число предупреждений значительно превышает число уникальных состояний гонки.
Так, полученные 41 предупреждение соответствует лишь 15 модулям.
%Таким образом, получается, что около \todo{1\%} проверенных модулей содержат ошибки, связанные с состоянием гонки.

Значительная часть ложных сообщений об ошибках связана с несовершенством модели окружения.
Из-за этой причины было получено 25 ложных предупреждений (29\%).
Заметим, что весь этот класс ошибок не связан с инструментом CPALockator.
В основном, неточность модели окружения приводит к тому, что параллельно выполняются участки кода, которые не могут выполняться одновременно при реальном исполнении программы.
Еще одним подклассом данного типа ложных предупреждений является неточная модель для отсутствующих функций.
Например, некоторые функции могут активировать некоторые потоки, вызывать функции по указателю, но их код не включается в верификационную задачу.
В этом случае должна быть подготовлена модель, которая содержит в себе необходимые действия (активацию потока, вызов функции и т.д.). 
Другим подклассом данного типа ошибок является неточное выделение памяти под структуры драйвера. 
Это приводит к последующим неточностям в процессе анализа, в первую очередь, <<потери значений>> в анализе предикатов.
То есть, при чтении значения из невыделенной памяти считается, что там может быть любое значение.

Оставшиеся ложные предупреждения связаны непосредственно с инструментом CPALockator.
Наиболее значительный класс ложных предупреждений связан с неточностью модели памяти -- 8 ложных предупреждений.
Из-за неточной модели памяти анализ не может определить, что данные на самом деле являются разными.
В первую очередь это касается полей структур, доступ к которым встречается наиболее часто.
Из-за использования указателей на структуры мы не можем определить, что в двух потоках используется различная память одного типа, и, чтобы не пропустить ошибку, вынуждены выдавать предупреждения.

Еще одной важной причиной ложных предупреждений является низкоуровневые особенности ядра, в первую очередь прерываний.
В данный момент считается, что обработчик прерывания выполняется в обычном потоке, однако в реальной системе это не так.
Выполнение прерывания может быть прервано только в некоторых случаях и только другим прерванием, что означает, что при выполнении его с другим обычным потоком оно должно выполниться атомарно.
Кроме того, регистрация обработчика прерывания не всегда означает, что они могут быть активны.
В некоторых случаях необходимо активировать их на устройстве отдельно.

Далее идут незначительные классы ложных предупреждений, связанных с неточностями анализа разделяемых данных (4 предупреждений), особенностями работы со сложными структурами данных (1 предупреждение) и модельными переменным (1 предупреждения)


\subsection{Ложные предупреждения на ОС РВ}

Из анализа 52 предупреждений было найдено:
\begin{itemize}
\item 11 реальных предупреждений, из них 4 безобидных;
\item 43 ложных предупреждений, из которых
\begin{itemize}
\item 11 связанны с неточностью модели окружения;
\item 16 связанных с неточностью анализа разделяемых данных;
\item 9 связанных с неточностью анализа примитивов синхронизации;
\item 4 связанных с неточностью модели памяти;
\end{itemize}
\end{itemize}

Модель окружения для ОС РВ представляет собой набор потоков, которые выполняют код заранее заданных системных вызовов, обработчиков прерываний и т.д.
Таким образом, для всех потоков известно, что они могут выполняться в любой момент времени, а значит, снижается число ложных предупреждений об ошибках из-за неточности модели окружения.

Как и следовало ожидать, при анализе ОС РВ повышается роль анализа разделяемых данных, и несколько снижаются требования к модели окружения.
Слишком малое количество ложных предупреждений из-за неточности модели памяти, скорее всего, связано с тем, что такие проблемы проявляются в последнюю очередь.
То есть, после решения проблем, связанных с неточностью модели окружения и анализа разделяемых данных, могут возникнуть проблемы из-за неточной модели памяти.

%Покрытие!

\section{Выводы по результатам экспериментов}

\subsection{Выводы по использованным конфигурациям}

Как невозможно создать универсальный инструмент, способный находить любые ошибки в любых программах, так и невозможно указать универсальную конфигурацию, которая будет лучше для всех задач. 
Однако, имеет смысл обозначить те или иные случаи, в которых будет лучше та или иная конфигурация.

Среди различных видов реализации cpa-оператора $merge$ для PredicateCPA в большинстве случаев оказывается достаточным реализация Join. 
Sep является слишком медленной, а ее точность не нужна почти во всех случаях. Реализация Eq близка к Join как по временным показателям, так и по количеству найденных вердиктов.

Оптимизации PredicateCPA обладают различными характеристиками. ABE позволяет ускорить анализ во всех случаях, но для больших задач полученное ускорение становится наиболее заметным. 
Оптимизация с применением релевантных эффектов становится значимой только при большом количестве уточнений, то есть для сложных задач.
Тем не менее, эти оптимизации не снижают точность анализа, а значит, могут применяться в любых случаях.
Оптимизация с присваиванием неопределенных значений ускоряет анализ, но для искусственных тестов это сопровождается снижением точности.
Для исходного кода более сложных задач такое падение точности не наблюдается, а значит, такая оптимизация может применяться в таких случаях.
Оптимизации с игнорированием разделяемых данных значительно снижают точность, но позволяют ускорить анализ.
Но более важное их свойство состоит в том, что они делают анализ предикатов инвариантным к эффектам окружения, что позволяет применять более сложные оптимизации, в том числе, BAM.
Таким образом, они могут быть использованы при анализе большого объема исходного кода, который не позволяет провести полноценный точный анализ.

Реализации ThreadCPA с эффектами окружения и без них практически равнозначны, однако, для использования других оптимизаций выгоднее иметь такой вариант анализа потоков, который будет инвариантным к эффектам окружения.
Простая реализация ThreadCPA является слишком простой для решения задач, в которых предполагается порождение потоков внутри других, однако является достаточным при анализе искуственно подготовленного кода для некоторых ОС РВ.
Повторно создаваемые потоки могут встречаться в различных искусственных тестах, однако это является нетипичным случаем для модели окружения драйверов и ОС РВ.
Таким образом, в общем случае вариант с абстракцией от повторно создаваемого потока поможет обеспечить отсутствие пропуска ошибки, а при решении прикладных задач более эффективным будет вариант с игнорированием таких ситуаций.

Реализации LockCPA с использованием cpa-оператора $merge_{Join}$ и с использованием уточнения являются бессмысленными на всех наборах, на которых проводилось исследование. 
Таким образом, эффективнее становится использовать простой вариант анализа примитивов синхронизации, в котором отсутствует объединение состояний.
Реализации $reduce/expand$ становятся значимыми только при анализе большого объема исходного кода.
Тем не менее, существуют вариант реализации этих cpa-операторов, которые могут привести к пропуску ошибок в определенных ситуациях, хотя при этом позволяют получить существенное ускорение анализа.

Использование анализа разделяемых данных не приводит к сколько-нибудь заметному снижению скорости анализа, но при этом возможно снижение числа выданных ложных предупреждений об ошибках. 
Это число сильно зависит от возможностей анализа потоков, который также может отсеивать часть ложных сообщений, связанных с инициализацией, поэтому наиболее заметный эффект достигается при анализе кода, который не содержит таких зависимостей (ядро ОС РВ).

Использование оптимизации BAM позволяет существенно сократить требования по расходуемой памяти и времени для проведения анализа.
Существенное ограничение данной оптимизации состоит в том, что она требует инвариантности к эффектам окружения, хотя это и не является принципиальным ограничением.
Другими словами, оптимизация позволяет расширение на случай подхода с раздельным рассмотрением потоков, однако это не является темой данной работы и может быть дальнейшим развитием.

Использование анализа предикатов позволяет существенно повысить точность анализа, однако имеется возможность полностью отказаться от него, что, по сути, является реализацией варианта простого легковесного анализа потоков данных. 
Такой вариант также может иметь место для поиска ошибок в большом объеме исходного кода или в жестких временных рамках.

\subsection{Выводы по результатам анализа предупреждений об ошибках}

Одной из важных причин и ложных срабатываний, и пропуска ошибок при анализе реального кода становится подготовка неточной верификационной задачи.
С точки зрения инструмента статической верификации это является сторонним процессом, и ложное предупреждение из-за неточности модели окружения является истинным с точки зрения инструмента.
Для реального пользователя интересен результат, и поэтому задача соответствия верификационной задачи реальному процессу выполнения программы является достаточно важной.
Однако, эта тема выходит за рамки данной работы.

При этом подготовка качественной модели окружения требуется для того исходного кода, который подразумевает сложную схему работы.
Так, при анализе ОС РВ, при котором требовалось проверить корректную работу системных вызовов при любом варианте выполнения, было достаточно самой простой модели. 
В то время как для драйверов ОС Linux была нужна более точная модель, так как различные обработчики драйвера могут активироваться в различное время.

Наиболее частой причиной ложных предупреждений для системного программного обеспечения является неточная модель памяти, при которой отождествляются различные объекты.
Данная проблема возникает почти у всех инструментов статического анализа. 
Попытки применения более точных моделей совместно с анализом алиасов приводят к другим проблемам, связанным с эффективностью, а также проблемам применения к недоопределенному коду.
Таким образом, данное направление является одним из приоритетных для дальнейшего развития инструмента.

Другие причины ложных срабатываний, связанных с неточностями различных компонентов анализа проявляются в различной степени на различном целевом исходном коде. 
Например, ложные предупреждения из-за неточности анализа разделяемых данных почти не проявляются на драйверах ОС Linux из-за особенностей их устройства и анализа потоков, который способен повысить точность.
Однако, для ОС РВ процент ложных предупреждений из-за анализа разделяемых данных повышается, так как анализ потоков играет меньшую роль.

Тоже самое верно и для длугих CPA, в том числе LockCPA. Для того исходного кода, который использует обычные блокировки для синхронизации, данный анализ работает достаточно точно, однако, он становится бесполезным при анализе кода с другими примитивами синхронизации, например, с помощью посылки сообщений.
И для такого кода будет требоваться разработка нового CPA.

Таким образом, можно заключить, что разработанный инструмент поиска состояний гонки способен обеспечивать высокую точность анализа
%\newpage
%============================================================================================================================

\clearpage