\chapter{Результаты экспериментов}
\label{chapter_evaluation}

Основными целями проведения экспериментов являются 
\begin{enumerate}
\item cравнение с ведущими инструментами в области поиска состояний гонки и верификации многопоточных программ;
\item оценка влияния различных конфигураций анализа;
\end{enumerate}

Было реализовано две основные модификации анализа с раздельным рассмотрением потоков с эффектами окружения
\begin{enumerate}
\item $\mathbb{C_1}(\mathbb{L}, \mathbb{CS}, \mathbb{T}, \mathbb{S}, \mathbb{P})$ -- включает анализ потоков, ограниченный количеством создаваемых потоков;
\item $\mathbb{C_2}(\mathbb{L}, \mathbb{CS}, \mathbb{S}, \mathbb{P})$ -- поддерживает неограниченное создание потоков;
\end{enumerate}
с объединением эффектов окружения анализа предикатов $\mathbb{P}$ при равных состояниях другив видов анализа $\mathbb{T}$, $\mathbb{S}$
(то есть, равных точках программы, стеках вызова, потоках и множествах захваченных блокировок),\\
где
\begin{itemize}
\item Анализ точек программы $\mathbb{L}$~(раздел \ref{sect_location_analysis})
\item Анализ стеков вызова $\mathbb{CS}$~(служебный анализ, не описан в теории)
\item Анализ потоков $\mathbb{T}$~(раздел \ref{sect_thread_analysis}),
\item Анализ примитивов синхронизации $\mathbb{S}$~(раздел \ref{sect_lock_analysis}), 
с опцией 
\begin{enumerate}
\item {\em EmptyLockset=true/false}
\begin{itemize}
\item true -- отключить эффекты окружения, используя $empty$ эффект окружения (всегда является совместным)
\item false -- использовать множества захваченных блокировок, как эффект окружения (проверять пересечение захваченных блокировок при вычислении совместности).
\end{itemize}
\end{enumerate}

\item Анализ предикатов $\mathbb{P}$~(раздел~\ref{sect_predicate_analysis}).
с опциями:
\begin{itemize}
\item {\em Merge=Join}. Объединение первой (условие) и второй (формула перехода) части эффекта окружения.
\item {\em Merge=Eq}. Объединение эффектов окружения при одинаковом условии (то есть, при равных предикатных абстракциях).
\item {\em Merge=Sep}. Не объединять эффекты никогда.
\end{itemize}
\end{itemize}

TODO: Добавить $\mathbb{C_2}$?
%Now only $\mathbb{C_1}$ is presented.

Подходы для сравнения
\begin{enumerate}
\item Варианты анализа с эффектами окружения
\begin{enumerate}
\item {\textbf EmptyLockset} -- отключение условие на проверку множества захваченных блокировок {\em EmptyLockset=true} и {\em Merge=Join} опции в анализе предикатов.
\item Включенная опция {\em EmptyLockset=false} с вариантами объединения для анализа предикатов
\begin{enumerate}
\item {\textbf MergeJoin}. Объединять обе части эффекта окружения({\em Merge=Join}). 
\item {\textbf MergeEq}. Объединять эффекты только для равных условий ({\em Merge=Eq}).
\item {\textbf MergeSep}. Не объединять эффекты ({\em Merge=Sep}). 
\end{enumerate}
\end{enumerate}
\item {\textbf Threading}. Анализ с перебором различных чередований потоков, реализованный в концепции CPA~\cite{MEMICS16-Multi-Threaded}, который использует классический вариант теории(см. раздел~\ref{sect_classic_cpa}).
\item Другие ведущие инструменты YogarCBMC, SMACK, CSeq, ESBMC
\end{enumerate}

%----------------------------------------------------
\section{Запуски на наборе задач SV-COMP}
Категория {\em ConcurrencySafety} содержит множество задач, для которых требуется доказать достижимость некоторого ошибочного состояния. 
В основном, используются т.н. выражения \textit{assert}. Требуется доказать, что они не нарушаются. 
Этот набор задач был подготовлен вручную, и содержит редко встречающиеся конструкции работы с многопоточными программами. В том числе, например, требуется доказать корректность lockFree-алгоритмов, таких, напримре, как алгоритмы Деккера или Петерсона.

Результаты экспериментов представлены в таблице~\ref{table-sv-comp}.

%Для SV-COMP мы должны подготовить witness файл, но при подходе с отдельным рассмотрением потоков взаимодействие между потоками не учитывается, из за этого возможно подготовить трассу только в одном потоке. Чтобы преобразовать две трассы в полный путь, необходимо определить чередование между потоками. 

%{\em Future solution. The witness checker should follow the singlethreaded trace and should do context switches at the points of inference objects. It should explore the remaining threads to find a suitable interleaving.}

%Right now witness checkers do not support thread identifiers in the error witnesses.

\begin{center}
  \begin{table}[h]\footnotesize
  	\label{table-sv-comp}
    \caption{Запуск на наборе задач SV-COMP}
    \begin{tabular}{ | l | c | c | c | c | c | c |}
      \hline
      Подход         & MergeJoin   & MergeEq & MergeSep & EmptyLockset & Threading & Other tool \\ \hline
      Вердикт "ошибка" & 988    & 988        & 988      & 989       & 769       & ?\\ 
  \hspace{0.5cm} из них корректных & 789 & 789 & 789      & 789       & 767       & ?\\ 
  \hspace{0.5cm} из них некорректных & 199 & 199 & 199    & 200       & 2         & ? \\ \hline
      Вердикт "нет ошибки"  & 33      & 33        & 33       & 32        & 163       & ? \\ 
  \hspace{0.5cm} из них корректных & 33 & 33    & 33       & 32        & 163       & ? \\
  \hspace{0.5cm} из них некорректных & 0 & 0    & 0        & 0         & 0         & ? \\ \hline
      Анализ не завершен       & 26     & 26         & 26       & 26        & 115       & ? \\ \hline
      Время CPU (с)   & 28 400 & 38 200     & 46 900  & 39 900    & 63 000    & ? \\ 
      Время (с)  & 17 300 & 24 100     & 29 100   & 23 500    & 38 600    & ? \\
      \hline
    \end{tabular}
  \end{table}
\end{center}

Общие выводы из полученных результатов являются следующими.

Подход с раздельным рассмотрением потоков не выдает ложных вердиктов "нет ошибки", что подтверждает корректность подхода.

Для конфигурации {\textbf EmptyLockset} мы не видим значительно большего количества некорректных вердиктов "ошибка", в сравнении с  другими конфигурациями.
Это объясняется тем, что не так много тестовых примеров используют примитивы синхронизации для обеспечения корректного доступа к данным.

{\textbf MergeJoin}, {\textbf MergeEq} и {\textbf MergeSep} показывают одинаковое число корректных результатов.
{\textbf MergeSep} является наиболее медленным, затем {\textbf MergeEq} немного быстрее, и {\textbf MergeJoin} показывает самые быстрые результаты.

Сравнивая анализ с раздельным рассмотрением потоков с классическим анализом, который рассматривает все возможные чередования ({\textbf Threading}).
Все 33 вердикта "true", доказанных нашим подходом не были доказаны подходом {\textbf Threading}.
Это является одним из важных вкладов данного подхода. 

Подход с раздельным рассмотрением потоков выдает большое количество ложных предупреждений об ошибке. 
Большинство из них (157) связаны с неподдерживаемыми атомарными конструкциями, такими как 'compare and swap' {\em \_\_VERIFIER\_atomic\_CAS}.
В 23 случаях данный подход не способен определить отношение happens-before между созданием потока (дочерний поток не может работать одновременно с родительским до точки своего создания).
Текущие ограничения процедуры уточнения не позволяют определять и расставлять интерполянты на поток, исходный для эффекта окружения.
В 7 случаях требовалось точное рассмотрение переключений между потоками.

%----------------------------------------------------
\section{Запуск на известных ошибках в драйверах Linux}
Мы подготовили 32 тестовых программы на основе 16 известных ошибок, найденных в модулях ядра операционной системы Linux\footnote{в течение GSoC 2017 http://linuxtesting.org/28-08-2017}
Для каждой ошибки доступны два варианта: {\em false} (с достижимой ошибкой) и {\em true} (исправленный вариант).

Задания были подготовлены с помощью системы Klever. В частности, при подготовки заданий были заменены примитивы синхронизации ядра на конструкции библиотеки posix (mutex\_lock и spin\_lock были заменены на pthread\_mutex\_lock), а также добавлена модель окружения драйвера.

Результаты приведены в таблице~\ref{table-linux}.

\begin{center}
  \begin{table}[h]\footnotesize
    \label{table-linux}
    \caption{Сравнение на известных ошибках в драйверах Linux}
    \begin{tabular}{ | l | c | c | c | c | c | c |}
      \hline
       Подход       & MergeJoin   & MergeEq & MergeSep & EmptyLockset & Threading \\ \hline
      Вердикт "ошибка" & 12      & 12          & 12        & 23         & 3 \\ 
  \hspace{0.5cm} из них правильных   & 12 & 12   & 12        & 12         & 2  \\ 
  \hspace{0.5cm} из них неправильных & 0 & 0   & 0        & 11         & 1 \\ \hline
      Вердикт "нет ошибки"  & 12      & 12          & 11        & 1         & 0  \\ 
  \hspace{0.5cm} из них правильных   & 12 & 12    & 11        & 1         & 0  \\ 
  \hspace{0.5cm} из них неправильных & 0 & 0    & 0        & 0         & 0 \\ \hline
      Анализ не завершен корректно       & 8      & 8          & 9        & 8         & 29 \\ \hline
      Время CPU (с)   & 10 200 & 9 960      & 11 000   & 11 000    & 23 500  \\
      Время (с)  & 9 060  & 9 040      & 9 650    & 9 640     & 22 200  \\
      \hline
    \end{tabular}
  \end{table}
\end{center}

{\textbf EmptyLockset} -- без условия на множества захваченных блокировок нельзя доказать условия на глобальные переменные при захваченных блокировках. Это приводит к слишком большому количеству некорректных вердиктов.
На множестве задач sv-comp различие было меньше заметно из-за того, что в тех примерах не так часто использовались примитивы синхронизации на основе блокировок, в том время как на драйверах такая синхронизация активно применяется.

{\textbf MergeJoin}, {\textbf MergeEq}, {\textbf MergeSep} -- все они получают похожие результаты, хотя {\textbf MergeSep} не может доказать один из вердиктов и в целом работает немного медленнее.

%To see how much time/resources is spent on applying inference objects we have collected the following characteristics:
%\begin{itemize}
%\item {\bf inference objects} -- number of inference objects in the final reached set;
%\item {\bf merges} -- number of times when merge for inference objects returns different state;
%\item {\bf refinements} -- of predicate analysis;
%\item {\bf states from objects} -- number of inference object applications in transfer;
%\item {\bf stops} -- stop operator for inference objects returns true;
%\item {\bf passes} -- stop operator for inference objects returns false;
%\item {\bf total states} -- number of states in the final reached set.
%\end{itemize}

%{\em See full tables of results in repository.}

{\textbf Threading} работает слишком медленно для драйверов, поэтому на всех примерах кроме трех возникает таймаут.
%TODO: What is the reason of incorrect false?

%TODO: Preliminary results of the other tools.
Кроме того, предпринимались попытки запуска других инструментов-участников соревнования sv-comp. 
Однако, большинство из них, так или иначе, работали некорректно. 
Так, YogarCBMC падает с ошибкой сегментирования, а SMACK -- получает exception. Последнюю ушибку можно избежать, отключив в конфигурации инструмента один из видов анализа, но после этого возникает таймаут.


\section{Запуски анализа, инвариантного к эффектам окружения}

Как уже отмечалось ранее, анализ, инвариантный к эффектам окружения, менее требовательный к ресурсам, хотя и менее точный.

Был проведен запуск на множестве модулей операционной системе Linux. Его результаты приведены в таблице~\ref{table-linux-full}.

\begin{center}
  \begin{table}[h]\footnotesize
    \caption{Запуск на подсистеме net/wireless/}
    \label{table-linux-full}
    \begin{tabular}{ | l | c | c | c | c | c | c |}
      \hline
      Подход         & CPALockator   & Без ThreadCPA & Без PredicateCPA \\ \hline
      Вердикт "ошибка" & 71    & 107        & 310 \\ 
%  \hspace{0.5cm} из них корректных & 789 & 789 & 789      & 789       & 767       & ?\\ 
%  \hspace{0.5cm} из них некорректных & 199 & 199 & 199    & 200       & 2         & ? \\ \hline
      Вердикт "нет ошибки"  & 51      & 29        & 50  \\ 
%  \hspace{0.5cm} из них корректных & 33 & 33    & 33       & 32        & 163       & ? \\
%  \hspace{0.5cm} из них некорректных & 0 & 0    & 0        & 0         & 0         & ? \\ \hline
      Анализ не завершен       & 49     & 46         & 36    \\ \hline
      Время CPU (ч)   & 6.4 & 5.4     & 2.1  \\ 
      Время (ч)  & 5.9 & 5.1     & 1.8   \\
      \hline
    \end{tabular}
  \end{table}
\end{center}

В результате разметки было получено, что около 30\% полученных предупреждений соответсвуют реальным ошибкам. 
При этом для одного состояния гонки может быть выдано несколько предупреждений на различные переменные, работа с которыми производится похожим образом.
Таким образом, получается, что около 1\% проверенных модулей содержат ошибки, связанные с состоянием гонки.
При этом часть из ошибок находится в неподдерживаемых модулях, и такие ошибки, как правило, не исправляются, даже если и признаются. 
Другая часть ошибок оказывается безобидными, то есть, не способными нанести какой-либо вред.
Такие ошибки, хотя и признаются разработчиками, все равно не исправляются, так как их исправление, как и исправление многих ошибок, связанных с параллельным выполнением кода, требует серьезных изменений кода.
В среднем, только половина найденных ошибок доходит до подготовки патча, исправляющего эту ошибку.

Наиболее важной причиной ложных срабатываний стало несовершенство модели окружений, из-за которой было  получено  более  50\%  ложных  предупреждений.
Например,  некоторые функции-обработчики  драйвера  при  реальном  выполнении  вызываются  под блокировками, в то время как в модели этот факт не учитывается.
Кроме того зачастую  возникают  неявные  зависимости  между  обработчиками  разных структур,  которые  не  позволяют  им  выполняться одновременно  и  которые также  не  учитываются  в  модели  окружения.
Следует  еще  раз  отметить, что модель окружения относится к этапу подготовки задачи, а не к методу анализу непосредственно. 

Возникали  ситуации,  в  которых  структуры  одного  типа  использовались  для разного  назначения,  которое  предполагало  наличие  различных  блокировок. 
Таким образом, упрощенная модель памяти, которую используется в методе, принесла около 10\% ложных предупреждений. 
Еще 10\%  ложных  предупреждений  связаны  с  ситуациями,  в  которых  из разделяемого множества достается объект под блокировками, а работа с ним 
осуществляется  без них.
Около 10\% связаны с  неточностями анализа: это и несовершенство анализа функциональных указателей, и проблемы в анализе примитивов  синхронизации  (в т. ч. отсутствие некоторых  блокировок  в конфигурации), и неточности в анализе разделяемых данных.  

Таким   образом,   представленный   метод   поиска  состояний  гонок в операционных системах продемонстрировал практически значимые результаты
с приемлемым уровнем ложных срабатываний.
Являясь, по сути, легковесным методом, он допускает более гибкую настройку баланса между ресурсами и точностью анализа.
%
%\section{Таблица обыкновенная} \label{sect3_1}
%
%Так размещается таблица:
%
%\begin{table} [htbp]
%  \centering
%  \changecaptionwidth\captionwidth{15cm}
%  \caption{Название таблицы}\label{Ts0Sib}%
%  \begin{tabular}{| p{3cm} || p{3cm} | p{3cm} | p{4cm}l |}
%  \hline
%  \hline
%  Месяц   & \centering $T_{min}$, К & \centering $T_{max}$, К &\centering  $(T_{max} - T_{min})$, К & \\
%  \hline
%  Декабрь &\centering  253.575   &\centering  257.778    &\centering      4.203  &   \\
%  Январь  &\centering  262.431   &\centering  263.214    &\centering      0.783  &   \\
%  Февраль &\centering  261.184   &\centering  260.381    &\centering     $-$0.803  &   \\
%  \hline
%  \hline
%  \end{tabular}
%\end{table}
%
%\begin{table} [htbp]% Пример записи таблицы с номером, но без отображаемого наименования
%	\centering
%	\parbox{9cm}{% чтобы лучше смотрелось, подбирается самостоятельно
%        \captiondelim{}% должен стоять до самого пустого caption
%        \caption{}%
%        \label{tbl:test1}%
%        \begin{SingleSpace}
%    	\begin{tabular}{ | c | c | c | c |}
%    	\hline
%    	Оконная функция	& ${2N}$ & ${4N}$	& ${8N}$	\\ \hline
%    	Прямоугольное 	& 8.72 	 & 8.77		& 8.77		\\ \hline
%    	Ханна		& 7.96 	 & 7.93		& 7.93		\\ \hline
%    	Хэмминга	& 8.72 	 & 8.77		& 8.77		\\ \hline
%    	Блэкмана	& 8.72 	 & 8.77		& 8.77		\\ \hline
%    	\end{tabular}%
%    	\end{SingleSpace}
%	}
%\end{table}
%
%Таблица \ref{tbl:test2} "--- пример таблицы, оформленной в~классическом книжном варианте или~очень близко к~нему. \mbox{ГОСТу} по~сути не~противоречит. Можно ещё~улучшить представление, с~помощью пакета \verb|siunitx| или~подобного.
%
%\begin{table} [htbp]%
%    \centering
%	\caption{Наименование таблицы, очень длинное наименование таблицы, чтобы посмотреть как оно будет располагаться на~нескольких строках и~переноситься}%
%	\label{tbl:test2}% label всегда желательно идти после caption
%    \renewcommand{\arraystretch}{1.5}%% Увеличение расстояния между рядами, для улучшения восприятия.
%    \begin{SingleSpace}
%	\begin{tabular}{@{}@{\extracolsep{20pt}}llll@{}} %Вертикальные полосы не используются принципиально, как и лишние горизонтальные (допускается по ГОСТ 2.105 пункт 4.4.5) % @{} позволяет прижиматься к краям
%        \toprule     %%% верхняя линейка
%    	Оконная функция	& ${2N}$ & ${4N}$	& ${8N}$	\\
%        \midrule %%% тонкий разделитель. Отделяет названия столбцов. Обязателен по ГОСТ 2.105 пункт 4.4.5 
%    	Прямоугольное 	& 8.72 	 & 8.77		& 8.77		\\
%    	Ханна		& 7.96 	 & 7.93		& 7.93		\\
%    	Хэмминга	& 8.72 	 & 8.77		& 8.77		\\
%    	Блэкмана	& 8.72 	 & 8.77		& 8.77		\\
%        \bottomrule %%% нижняя линейка
%	\end{tabular}%
%   	\end{SingleSpace}
%\end{table}

%\newpage
%============================================================================================================================

\clearpage