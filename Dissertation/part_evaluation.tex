\chapter{Результаты экспериментов}
\label{chapter_evaluation}

\newcommand{\theory}{CPALockator-Reach}
\newcommand{\theoryraces}{CPALockator-TM}
\newcommand{\combatmode}{CPALockator-Inv}
% Опции:
% Composite lattice

\section{Общая схема проведения экспериментов}

Основными целями проведения экспериментов являются:
\begin{enumerate}
\item cравнение с ведущими инструментами в области поиска состояний гонки и верификации многопоточных программ;
\item оценка различных конфигураций инструмента.
\end{enumerate}

Сравнение с ведущими инструментами статической верификации будет проводиться на наборе тестовых задач SV-COMP\footnote{https://sv-comp.sosy-lab.org/2020/}.
Категория {\em ConcurrencySafety} состоит из 1082 задач, большая часть из которых являются небольшими примерами около 100 строк кода
Для всех задач требуется доказать достижимость некоторого ошибочного состояния. 
В основном, используются т.н. выражения \textit{assert}, и требуется доказать, что условия в них не нарушаются. 
Этот набор задач содержит редко встречающиеся сложные конструкции работы с многопоточными программами, например, нетривиальные механизмы синхронизации, в том числе алгоритмы Деккера, Петерсона и др.
7 задач были подготовлены на основе драйверов ОС Linux. Все задачи доступны в официальном репозитории SV-COMP\footnote{https://github.com/sosy-lab/sv-benchmarks}.

Сравнение различных конфигураций инструмента будет проводиться на трех множествах задач: набор тестовых задач SV-COMP, набор задач, подготовленных на основе драйверов операционной системы Linux, и задачи, подготовленные на основе ядер закрытых операционных систем реального времени.
Верификационные задачи, основанные на драйверах операционной системы Linux, были подготовлены системой Klever, которая предназначена для верификации различного программного обеспечения~\cite{kleverPsi},~\cite{kleverIsola}.
Она разделяет большой объем целевого исходного кода на отдельные небольшие верификационные задачи.
Для ядра операционной системы Linux верификационная задача соответствует одному модулю.
Система Klever автоматически готовит модель окружения модуля, которая включает в себя модель потоков, модель сердцевины ядра и операций над модулем.
После подготовки верификационной задачи Klever запускает верификацию через общий интерфейс -- BenchExec~\cite{benchexec2019}.
Сравнение проводилось на подсистеме \textit{drivers/net/} ядра операционной системы Linux 4.2.6, для которой Klever подготовил 425 верификационных задач.

Верификационные задачи на основе ядра операционных систем реального времени были подготовлены для двух закрытых операционных систем.
Для этого были вручную выделены и закодированы те активности, которые могут выполняться параллельно при реальой работе ОС, в том числе, обработчики прерываний, системные вызовы, системные потоки и т.д.
Одна задача на основе ядра ОС РВ занимает \todo{строк}, а другая --  \todo{строк}.
Так как эти задачи содержат большое количество предупреждений, в том числе истинных, и в итоге при любой конфигурации

Эксперименты на наборе задач SV-COMP и наборе драйверов проводились с использованием кластера из 191 машины VerifierCloud\footnote{https://vcloud.sosy-lab.org/cpachecker/webclient/master/info}.
В нем специально были выбраны машины с одним типом процессора Intel Xeon E3-1230 v5, 3.40 GHz.
Были использованы ограничения по памяти в 8 Гб и по времени 15 минут.
Эксперименты на задачах, основанных на ядрах операционных систем реального времени были проведены на машинах \todo{...}

Оценка различных конфигураций анализа будет проводиться для следующих настроек:
\begin{itemize}
\item PredicateCPA.
\begin{itemize}
\item Варианты реализации оператора $merge$:
\begin{itemize}
\item Join;
\item Eq;
\item Sep;
\end{itemize}
\item Оптимизация ABE (раздел~\ref{sect_predicate_abe}).
\item Оптимизация с присваиванием неопределенных функций (раздел~\ref{sect_predicate_opt}).
\item Оптимизация с применением только релевантных эффектов (раздел~\ref{sect_predicate_opt});
%\item Использование единственного эффекта "* = *";
\item Игнорирование разделяемых данных в формуле пути (раздел~\ref{sect_predicate_opt});
\item Использование локального уточнения (раздел~\ref{sect_predicate_refinement});
\end{itemize}
\item ThreadCPA.
\begin{itemize}
\item Варианты теории, лежащей в основе.
\begin{itemize}
\item Простой вариант инвариантный к эффектам окружения (раздел~\ref{sect_thread_analysis}).
\item Вариант с эффектами окружения (раздел~\ref{sect_thread_analysis_env}).
\item Сложный вариант инвариантный к эффектам окружения (раздел~\ref{sect_thread_analysis_ext}).
\end{itemize}
\item Варианты обработки повторно создаваемого потока (раздел~\ref{sect_thread_create}).
\begin{itemize}
\item Падение.
\item Игнорирование повторно создаваемого потока.
\item Абстракция от повторно создаваемого потока (создание самопараллельного потока).
\end{itemize}
\end{itemize}
\item LockCPA.
\begin{itemize}
\item Варианты реализации оператора $merge$:
\begin{itemize}
\item Join;
\item Sep;
\end{itemize}
\item Варианты реализации операторов $reduce/expand$ (раздел~\ref{subsect_lock_bam}):
\begin{itemize}
\item Использование абстракции от счетчика рекурсивных захватов блокировки.
\item Использование абстракции от неиспользуемых примитивов синхронизации.
\end{itemize}
\item Использование уточнения.
%\item Остановка анализа при превышении количества максимально-допустимого количества рекурсивных захватов блокировки.
\end{itemize}
\item Использование анализа разделяемых данных (раздел~\ref{sect_shared_analysis}).
% \item Использование ограничения на количество разрешенных уточнений.
\item Использование оптимизации BAM (раздел~\ref{sect_impl_bam}).
\item Использование анализа предикатов (раздел~\ref{sect_impl_predicate}).
% \item Использование различных способов вычисления одинаковых точек программы.
% \item Игнорирование предупреждений о состоянии гонки с пустым множеством блокировок.
\end{itemize}

Как уже было сказано, тестовые программы из набора SV-COMP содержат задачу достижимости, а для программ, построенных на основе драйверов и ядер ОС РВ, решается задача поиска состояний гонки.
Несмотря на то, что основная структура инструмента, в том числе дерево CPA, остается неизменным в обоих случаях, тем не менее, общая конфигурация требует изменений.
Кроме того, некоторые из оптимизаций накладывают дополнительные ограничения на используемую конфигурацию инструмента.
В частности, оптимизация BAM, требует использования CPA, инвариантных к окружению.
Другие опции, наоборот, определяют варианты работы с эффектами окружения, то есть, невозможно использовать единственную начальную конфигурацию инструмента для сравнения всех опций.
Чтобы отличать различные базовые конфигурации инструмента, далее будем использовать обозначение \textit{\theory} для обозначения конфигурации инструмента для решения задачи достижимости, \textit{\theoryraces} -- для обозначения конфигурации инструмента с эффектами окружения для решения задачи поиска гонок, и \textit{\combatmode} -- для обозначения конфигурации инструмента, инвариантного к эффектам окружения, для решения задачи поиска гонок.
Таким образом влияние части опций будет оценено на нескольких конфигурациях, а там, где это невозможно, будет указан тот вариант конфигурации инструмента, который поддерживает ту или иную опцию.

%Было реализовано две основные модификации анализа с раздельным рассмотрением потоков с эффектами окружения
%\begin{enumerate}
%\item $\mathbb{C_1}(\mathbb{L}, \mathbb{CS}, \mathbb{T}, \mathbb{S}, \mathbb{P})$ -- включает анализ потоков, ограниченный количеством создаваемых потоков;
%\item $\mathbb{C_2}(\mathbb{L}, \mathbb{CS}, \mathbb{S}, \mathbb{P})$ -- поддерживает неограниченное создание потоков;
%\end{enumerate}
%с объединением эффектов окружения анализа предикатов $\mathbb{P}$ при равных состояниях другив видов анализа $\mathbb{T}$, $\mathbb{S}$
%(то есть, равных точках программы, стеках вызова, потоках и множествах захваченных блокировок),\\
%где
%\begin{itemize}
%\item Анализ точек программы $\mathbb{L}$~(раздел \ref{sect_location_analysis})
%\item Анализ стеков вызова $\mathbb{CS}$~(служебный анализ, не описан в теории)
%\item Анализ потоков $\mathbb{T}$~(раздел \ref{sect_thread_analysis}),
%\item Анализ примитивов синхронизации $\mathbb{S}$~(раздел \ref{sect_lock_analysis}), 
%с опцией 
%\begin{enumerate}
%\item {\em EmptyLockset=true/false}
%\begin{itemize}
%\item true -- отключить эффекты окружения, используя $empty$ эффект окружения (всегда является совместным)
%\item false -- использовать множества захваченных блокировок, как эффект окружения (проверять пересечение захваченных блокировок при вычислении совместности).
%\end{itemize}
%\end{enumerate}
%
%\item Анализ предикатов $\mathbb{P}$~(раздел~\ref{sect_predicate_analysis}).
%с опциями:
%\begin{itemize}
%\item {\em Merge=Join}. Объединение первой (условие) и второй (формула перехода) части эффекта окружения.
%\item {\em Merge=Eq}. Объединение эффектов окружения при одинаковом условии (то есть, при равных предикатных абстракциях).
%\item {\em Merge=Sep}. Не объединять эффекты никогда.
%\end{itemize}
%\end{itemize}
%
%TODO: Добавить $\mathbb{C_2}$?
%%Now only $\mathbb{C_1}$ is presented.
%
%Подходы для сравнения
%\begin{enumerate}
%\item Варианты анализа с эффектами окружения
%\begin{enumerate}
%\item {\textbf EmptyLockset} -- отключение условие на проверку множества захваченных блокировок {\em EmptyLockset=true} и {\em Merge=Join} опции в анализе предикатов.
%\item Включенная опция {\em EmptyLockset=false} с вариантами объединения для анализа предикатов
%\begin{enumerate}
%\item {\textbf MergeJoin}. Объединять обе части эффекта окружения({\em Merge=Join}). 
%\item {\textbf MergeEq}. Объединять эффекты только для равных условий ({\em Merge=Eq}).
%\item {\textbf MergeSep}. Не объединять эффекты ({\em Merge=Sep}). 
%\end{enumerate}
%\end{enumerate}
%\item {\textbf Threading}. Анализ с перебором различных чередований потоков, реализованный в концепции CPA~\cite{MEMICS16-Multi-Threaded}, который использует классический вариант теории(см. раздел~\ref{sect_classic_cpa}).
%\item Другие ведущие инструменты YogarCBMC, SMACK, CSeq, ESBMC
%\end{enumerate}

%----------------------------------------------------
\section{Сравнение различных инструментов статической верификации}

Для проведения экспериментов были выбраны следующие инструменты:

\begin{itemize}
\item PredicateTM. Реализация подхода с раздельным рассмотрением потоков с использованием анализа предикатов. 
Включает в себя следующие CPA: ThreadModularCPA, ARGCPA, CompositeCPA, LocationCPA, CallstackCPA, LockCPA, ThreadCPA, PredicateCPA.
\item ValueTM. Реализация подхода с раздельным рассмотрением потоков с использованием анализа явных значений. 
Включает в себя следующие CPA: ThreadModularCPA, ARGCPA, CompositeCPA, LocationCPA, CallstackCPA, LockCPA, ThreadCPA, ValueCPA.
\item Threading. Реализация классического варианта анализа с чередованиями потоков~\cite{MEMICS16-Multi-Threaded}. 
Реализован в том же фреймворке CPAchecker, но с использованием классической версии теории.
\item Yogar-CBMC. Победитель соревнования SV-COMP'19, реализует подход ограничиваемой проверки моделей с некоторыми оптимизациями.
\item Lazy-CSeq. Серебряный призер соревнования SV-COMP'19, реализует подход секвенциализации программы.
\end{itemize}

Результаты экспериментов представлены в таблице~\ref{table-sv-comp-tools}.
В ней представлена информация о том, сколько у каждого инструмента было выдано сообщений об ошибке (False вердикт), для скольких тестовых примеров было доказано отсутствие ошибок (True вердикт) и для скольких инструмент не смог определить вердикт.

\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-sv-comp-tools}
    \caption{Запуск на наборе задач SV-COMP}
    \begin{tabular}{ | l | c | c | c | c | c | c |}
      \hline
      		& 		\multicolumn{2}{c|}{\theory} & \multicolumn{3}{c|}{Другие инструменты}  \\
      Подход         				& PredicateTM   & ValueTM 	& Threading & Yogar-CBMC 	& Lazy-CSeq  \\ \hline
      Вердикт "ошибка" 				& 1028    		& 241       & 727      	& 773       	& 811       \\ 
  \hspace{0.5cm} из них корректных 	& 805 			& 59 		& 727      	& 773       	& 811       \\ 
  \hspace{0.5cm} из них некорректных & 223 			& 182 		& 0    		& 0       		& 0          \\ \hline
      Вердикт "нет ошибки"  		& 21      		& 20        & 165       & 284        	& 256     \\ 
  \hspace{0.5cm} из них корректных 	& 21 			& 20    	& 165       & 284        	& 256       \\
  \hspace{0.5cm} из них некорректных & 0 			& 0    		& 0       	& 0         	& 0        \\ \hline
      Анализ не завершен       		& 33     		& 821       & 190      	& 25        	& 15      \\ \hline
      Время CPU (с)   				& 27 600 		& 38 200    & 111 000  	& 7 000    		& 29 000    \\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}

Общие выводы из полученных результатов являются следующими.

Результаты подтверждают, что подход с раздельным анализом потоков не пропускает ошибок при некоторых заранее известных ограничениях.

Конфигурация ValueTM является достаточно простым и быстрым анализом, но иногда она вынуждена рассматривать все возможные варианты значений переменных, что приводит к исчерпанию ресурсов по времени.
В данном эксперименте был использован вариант анализа без уточнения, что привело к значительному повышению количества тестовых примеров, анализ которых был незавершен за отведенный лимит времени. 
Так как данный анализ является достаточно простым и используется, в основном, на модельных примерах, то реализация полноценного варианта с уточнением не была приоритетной задачей.

Классический анализ Threading является корректным и точным и не выдает ложных вердиктов.
Однако, он требует значительного числа ресурсов, это является главным недостатком подхода.
Эта конфигурация решила только один из семи сложных задач, основанных на драйверах операционной системы Linux.
Подход с раздельным анализом потоков (PredicateTM) решает пять из семи таких задач. 

Большая часть новых доказательств корректности, полученных подходом с раздельным рассмотрением потоков, (26 из 27 для PredicateTM) не находились классическим методом (Threading). Это также является одним из важных вкладов данного метода.

Подход с раздельным рассмотрением потоков выдает большое количество ложных предупреждений об ошибке. 
Большинство из них связаны с неподдерживаемыми атомарными конструкциями, такими как 'compare and swap' {\em \_\_VERIFIER\_atomic\_CAS}.
Еще в некоторых случаях данный подход не способен определить отношение happens-before между созданием потока (дочерний поток не может работать одновременно с родительским до точки своего создания).
Текущие ограничения процедуры уточнения не позволяют определять и расставлять интерполянты на поток, исходный для эффекта окружения.
В небольшой части случаях требовалось точное рассмотрение переключений между потоками.

Инструменты, основанные на других подходах, показывают отличные результаты почти на всех тестовых примерах, но ни один из них не справился со сложными задачами, основанными на драйверах ОС Linux. 
Таким образом, это подтверждает тот факт, что для решения задач, основанных на реальных программных системах, такие инструменты не подходят. 

\section{Сравнение различных вариантов анализа предикатов}

\subsection{Сравнение различных реализаций оператора merge}

Для проведения экспериментов были использованы следующие конфигурации:

\begin{itemize}
\item MergeJoin. Реализация оператора $merge_{Join}$.
\item MergeEq. Реализация оператора $merge_{Eq}$.
\item MergeSep. Реализация оператора $merge_{Sep}$.
\end{itemize}

Результаты сравнения на множестве задач SV-COMP представлены в таблице~\ref{table-sv-comp-merge}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе задач SV-COMP}
  	\label{table-sv-comp-merge}
    \begin{tabular}{ | l | c | c | c | }
      \hline
      		& 		\multicolumn{3}{c|}{\theory}  \\
      Подход         				& MergeJoin & MergeEq 	& MergeSep   \\ \hline
      Вердикт "ошибка" 				& 1028    	& 1028		& 988         \\ 
  \hspace{0.5cm} из них корректных 	& 805 		& 805 		& 763      \\ 
  \hspace{0.5cm} из них некорректных & 223 		& 223 		& 225        \\ \hline
      Вердикт "нет ошибки"  		& 21      	& 21        & 21       \\ 
  \hspace{0.5cm} из них корректных 	& 21 		& 21    	& 21        \\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0         \\ \hline
      Анализ не завершен       		& 33     	& 33        & 73       \\ \hline
      Время CPU (с)   				& 27 600 	& 25 200    & 69 400    \\ 
      \hline
    \end{tabular}
  \end{table}

MergeJoin показывает результаты лучше, чем конфигурация MergeSep.
Это происходит, в основном, из-за большого количества переходов в окружении, которые MergeSep рассматривает по одному, что приводит к большому количеству проверок совместности, вызовов операторов $stop$ и $transfer$.
MergeJoin объединяет все эффекты в один и применяет за один раз. Это позволяет сохранить огромное количество времени. Теоретически, это должно было бы привести к падению точности, но даже на таких искусственных примерах данное предположение не подтверждается.
%В то же время MergeSep позволяет избежать некоторых неточностей из-за анализа переходов по-отдельности и выдает меньшее количество ложных сообщений об ошибках. 

Два лишних некорректных результата были получены из-за того, что в данной конфигурации отсутствует падение инструмента при уточнении, которое присутствует в первых двух конфигурациях.
%Подробности?
Небольшое отличие времен работы MergeJoin и MergeEq объясняется некоторыми флуктуациями работы внешнего компонента -- решателя. 
Например, в некоторых примерах при одинаковом количестве уточнений построение абстракции для MergeEq занимает меньше времени, чем для MergeJoin.

Результаты экспериментов на множестве задач \textit{drivers/net/} представлены в таблице~\ref{table-drivers-merge}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе задач \textit{drivers/net/}}
  	\label{table-drivers-merge}
    \begin{tabular}{ | l | c | c | c | }
      \hline
      		& 		\multicolumn{3}{c|}{\theoryraces}  \\
      Подход         				& MergeJoin	& MergeEq 	& MergeSep   \\ \hline
      Вердикт "ошибка" 				& 8	    	& 8  		& 5         \\ 
  \hspace{0.5cm} из них корректных 	& 8 		& 8 		& 5      \\ 
  \hspace{0.5cm} из них некорректных & 0 		& 0 		& 0        \\ \hline
      Вердикт "нет ошибки"  		& 261      	& 260       & 259       \\ 
  \hspace{0.5cm} из них корректных 	& 261 		& 260    	& 259        \\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0         \\ \hline
      Анализ не завершен       		& 148     	& 150        & 154       \\ \hline
      Время CPU (с)   				& 139 000 	& 140 000    & 143 000    \\ 
      \hline
    \end{tabular}
  \end{table}

Данные результаты подтверждают основные выводы, полученные в предыдущем пункте: MergeJoin и MergeEq требуют меньше времени для получения вердикта, а использование конфигурации MergeSep не приводит к более корректным результатам. 
Значительно меньшая разница в затраченном времени между конфигурациями объясняется большим количеством таймаутов, которые возникают для всех трех конфигураций. 
Если же вычислить затраченное время для полученных вердиктов (за исключением задач, для которых анализ не был завершен), в этом случае картина будет более полярной.
Кроме того, следует помнить, что незавершенный анализ не всегда означает именно исчерпание отведенного времени, иногда это могут быть падения инструмента, которые могут случиться на первых секундах.

Основным выводом данного пункта является тот факт, что конфигурация MergeJoin является наиболее оптимальной для большинства задач: как искусственных, так и приближенных к реальным программам. 
Это объясняется тем, что при проверке многопоточной программы к ошибке обычно приводит ситуация, при которой имеет место одновременный доступ к переменной, при этом уже становится неважным, какие еще области памяти были изменены вместе с ней.
Таким образом, перебирать все возможные изменения памяти по одному, как это делает MergeSep, становится бессмысленно.

\subsection{Сравнение влияния оптимизаций}

Для проведения экспериментов были использованы следующие конфигурации:

\begin{itemize}
\item Base. Базовая реализация предикатного анализа с отключенными оптимизациями, в том числе использование SBE (англ. Single Block Encoding).
\item Undef. Оптимизация с присваиванием неопределенного значения.
\item Relevance. Оптимизация с применением только релевантных эффектов.
\item ABE. Оптимизация ABE.
%\item Havoc. Использование единственного эффекта "* = *".
% Проблемы с восстановлением пути для уточнения: какой дугой представить * = *?
\item Havoc. Игнорирование разделяемых данных в формуле пути.
\item Imprecise. Использование локального уточнения.
\end{itemize}

Результаты cравнения на множестве задач SV-COMP представлены в таблице~\ref{table-sv-comp-opt}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение оптимизаций на наборе SV-COMP}
  	\label{table-sv-comp-opt}
    \begin{tabular}{ | l | c | c | c | c | c | c | }
      \hline
      		& 		\multicolumn{6}{c|}{\theory}  \\
      Подход         				& Base 	& Undef 	& Relevance & ABE 	& Havoc 	&  Imprecise \\ \hline
      Вердикт "ошибка" 				& 1027  & 1033  	& 1027      & 1026  & 1052     	& 1052       \\ 
  \hspace{0.5cm} из них корректных 	& 802 	& 805 		& 802     	& 803   & 808    	& 808     	\\ 
  \hspace{0.5cm} из них некорректных & 225 	& 228 		& 225     	& 225  	& 244      	& 244       \\ \hline
      Вердикт "нет ошибки"  		& 21    & 21    	& 21    	& 21   	& 5     	& 2       \\ 
  \hspace{0.5cm} из них корректных 	& 21 	& 21    	& 21     	& 21   	& 5     	& 2       \\
  \hspace{0.5cm} из них некорректных & 0 	& 0    		& 0     	& 0   	& 0     	& 0       \\ \hline
      Анализ не завершен       		& 34     & 28     	& 34     	& 33   	& 25     	& 28      	\\ \hline
      Время CPU, с   				& 30 900 & 21 600 	& 30 100  	& 26 600 & 13 500   & 15 200     	\\ 
      \hline
    \end{tabular}
  \end{table}

Оптимизация Undef, как и следовало ожидать, позволяет достаточно сильно сократить затрачиваемое на анализ время, но это приводит не только к новым корректно найденным ошибкам, но и к ложным предупреждениям.
Ложные предупреждения возникают как раз из-за того, что мы абстрагируемся от конкретных значений, которые могут быть записаны в соответсвующие разделяемые переменные. 

Оптимизация Relevance практически ничего не дает, а небольшое изменение времени находится в рамках погрешности. 
Это связано с тем, что данная оптимизация показывает себя в тех случаях, когда используется достаточно большой набор предикатов для построения абстракции.
В этом случае, вычисление тех предикатов, которые являются релевантными при изменении окружения будет иметь смысл.
Для искусственных примеров SV-COMP обычно требуется лишь несколько предикатов, чтобы отсечь или подтвердить ошибку.

Оптимизация ABE заметно повышает скорость анализа, хотя и не так сильно как оптимизация Undef. Однако, в отличие от нее, ABE не приводит к некорректным результатам. 
Такой результат также является закономерным.

Оптимизации Havoc и Imprecise, по сути, являются двумя реализациями одной и той же идеи: исключение из абстракции разделяемых переменных.
Havoc исключает разделяемые переменные еще на этапе построения формулы в PredicateCPA, а Imprecise -- на этапе уточнения.
Собственно, результаты подтверждают, что исключение данных на более ранних этапах является эффективным.
Однако, что и следовало ожидать, предположение, что все разделяемые данные могут принимать любые значения, не позволяет доказать корректность нескольких примеров, что увеличивает количество ложных предупреждений об ошибках.
Положительным эффектом является обнаружение корректных ошибок в тех примерах, которые раньше приводили к исчерпанию времени в более точных конфигурациях.

Результаты сравнения на множестве драйверов \textit{drivers/net/} представлены в таблицах~\ref{table-drivers-opt},~\ref{table-drivers-opt-2}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе задач \textit{drivers/net/}}
  	\label{table-drivers-opt}
    \begin{tabular}{ | l | c | c | c | c | c | c | c |}
      \hline
      		& 		\multicolumn{6}{c|}{\theoryraces}  \\
      Подход         				& Base 		& Undef		& Relevance & ABE 		& Havoc   	& Imprecise	\\ \hline
      Вердикт "ошибка" 				& 5  		& 5   		& 5       	& 7   		& 18     	& 17		\\ 
  \hspace{0.5cm} из них корректных 	& 5 		& 5 		& 5     	& 7   		& 14     	& 14 		\\ 
  \hspace{0.5cm} из них некорректных & 0 		& 0 		& 0     	& 0  		& 4      	& 3 		\\ \hline
      Вердикт "нет ошибки"  		& 259    	& 259    	& 259     	& 260   	& 255    	& 254		\\ 
  \hspace{0.5cm} из них корректных 	& 259 		& 259    	& 259       & 260   	& 255    	& 254    	\\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0      	& 0   		& 0     	& 0     	\\ \hline
      Анализ не завершен       		& 161    	& 161    	& 161     	& 158   	& 152    	& 154    	\\ \hline
      Время CPU, с   				& 113 000 	& 109 000 	& 109 000  	& 83 500   	& 88 200    & 102 000   \\ 
      \hline
    \end{tabular}
  \end{table}

Интересное отличие от предыдущего пункта заключается в том, что оптимизация Undef не влияет на вердикты.
Это объясняется тем, что в драйверах ОС Linux редко встречается присваивание явных значений во внутренние структуры.
В основном, это может быть инициализация, которая обычно происходит в начале работы в однопоточном режиме.
А все штатные сценарии работы драйвера манипулируют внутренними данными, то есть, вычислить явное их значение при статическом анализе не удается. 
Это означает, что почти все эффекты окружения и так записывают в разделяемую память неопределенное значение, то есть оптимизация Undef теряет смысл.

Оптимизация Relevance в этом наборе более заметна, хотя и не позволяет получить новые вердикты. 
Это связано с тем, что данный набор задач является более сложным, и в некоторых случаях требуется большое количество уточнений, чтобы получить вердикт.
В том случае, если было накоплено большое множество предикатов, данная оптимизация способна ускорить работу.

Для достаточно длинных ошибочных трасс оптимизация ABE вносит более весомый вклад, так как блоки получаются более длинные за счет большого количества работы с локальными данными, чего не было в искусственных примерах SV-COMP.
Это позволяет даже получить несколько дополнительных вердиктов.

Оптимизации Havoc и Imprecise позволяют найти несколько дополнительных ошибок за счет своей скорости, однако приводит к появлению некоторых ложных предупреждений.
Тем не менее, стоит заметить, что ее точности хватает, чтобы доказать отсутствие ошибок у большого множества задач. 
Таким образом, в некоторых случаях имеет смысл жертвовать точностью, отказываясь от точного рассмотрения разделяемых данных для того, чтобы получить новые вердикты.

Сравнение оптимизации ABE на конфигурации \combatmode не проводилось, так как в этом случае бы, по сути, использовалась бы исходная реализация ABE, то есть без каких-либо модификаций, а значит, никакой научной новизны такие результаты не представляют.

%  \begin{table}[h]\footnotesize \centering
%    \caption{Сравнение оптимизаций на наборе задач \textit{drivers/net/}}
%  	\label{table-drivers-opt-2}
%    \begin{tabular}{ | l | c | c |}
%      \hline
%      		& 		\multicolumn{2}{c|}{\combatmode}  \\
%      Подход         				& Base		& ABE	  	\\ \hline
%      Вердикт "ошибка" 				& 19  		& 33   			\\ 
%  \hspace{0.5cm} из них корректных 	& 14 		& 25 		  	\\ 
%  \hspace{0.5cm} из них некорректных & 5 		& 8 		    \\ \hline
%      Вердикт "нет ошибки"  		& 254    	& 255    	    \\ 
%  \hspace{0.5cm} из них корректных 	& 254 		& 255    	  	\\
%  \hspace{0.5cm} из них некорректных & 0 		& 0    		   	\\ \hline
%      Анализ не завершен       		& 152    	& 137    	   	\\ \hline
%      Время CPU, с   				& 114 000 	& 93 400 	 	\\ 
%      \hline
%    \end{tabular}
%  \end{table}
%
%Для конфигурации \combatmode также заметно большое влияние оптимизации ABE, которая позволяет получить много новых вердиктов за счет ускорения.
%
%Результаты сравнения на ядрах ОС РВ представлены в таблицах~\ref{table-os-opt-1},~\ref{table-os-opt-2}.
%
%  \begin{table}[h]\footnotesize \centering
%    \caption{Сравнение оптимизации ABE на ядрах ОС РВ}
%  	\label{table-os-opt-1}
%    \begin{tabular}{ | l | c | c | c | c |}
%      \hline
%      		& 		\multicolumn{4}{c|}{\combatmode / ОС РВ 1}  \\
%      		& 		\multicolumn{2}{c|}{Без уточнения} & \multicolumn{2}{c|}{10 итераций уточнения}  \\
%      Подход         								& Base 	& ABE 	& Base 	& ABE 		\\ \hline
%      Число предупреждений 							& 521  	& 461   & --   	& --  		\\ 
%      Общее время CPU, с							& 586  	& 582   & 10000 & 10000  		\\ 
%\hspace{0.5cm} Время на построение абстракции, с 	& 87 	& 54   	& 87 	& 48   	\\
%\hspace{0.5cm} Время на уточнение, с 				& 0 	& 0   	& 8987 	& 8121   	\\
%      \hline
%    \end{tabular}
%  \end{table}
%  
%\todo{странное отличие на ABE!}
%  
%    \begin{table}[h]\footnotesize \centering
%    \caption{Сравнение оптимизации ABE на ядрах ОС РВ}
%  	\label{table-os-opt-2}
%    \begin{tabular}{ | l | c | c | c | c |}
%      \hline
%      		& 		\multicolumn{4}{c|}{\combatmode / ОС РВ 2}  \\
%      		& 		\multicolumn{2}{c|}{Без уточнения} & \multicolumn{2}{c|}{10 итераций уточнения}  \\
%      Подход         								& Base 	& ABE 	& Base 	& ABE 		\\ \hline
%      Число предупреждений 							& 1037 	& 981   & --   	& 898  		\\ 
%      Общее время CPU, с							& 798  	& 886   & 10000 & 9881  		\\ 
%\hspace{0.5cm} Время на построение абстракции, с 	& 116 	& 71   	& 579 	& 1213   	\\
%\hspace{0.5cm} Время на уточнение, с 				& 0 	& 0   	& 6457 	& 782   	\\
%      \hline
%    \end{tabular}
%  \end{table}
%  
%В обоих случаях применение оптимизации ABE позволяет снизить количество найденных предупреждений.

\section{Сравнение различных вариантов реализации ThreadCPA}

\subsection{Сравнение различных подходов }

Для проведения экспериментов были использованы следующие конфигурации:

\begin{itemize}
\item Simple. Простой вариант инвариантный к эффектам окружения.
\item Env. Вариант с эффектами окружения.
\item Base. Расширенный вариант инвариантный к эффектам окружения.
\end{itemize}

Результаты сравнения представлены в таблице~\ref{table-svcomp-thread}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе SV-COMP}
  	\label{table-svcomp-thread}
    \begin{tabular}{ | l | c | c | c | }
      \hline
      		& 		\multicolumn{3}{c|}{\theory}  \\
      Подход         				& Simple   	& Env 		& Base  	\\ \hline
      Вердикт "ошибка" 				& 982    	& 966       & 1028       \\ 
  \hspace{0.5cm} из них корректных 	& 793 		& 785 		& 805    	\\ 
  \hspace{0.5cm} из них некорректных & 189 		& 181 		& 223     	\\ \hline
      Вердикт "нет ошибки"  		& 9      	& 24        & 21       	\\ 
  \hspace{0.5cm} из них корректных 	& 9 		& 24    	& 21      	\\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0     	\\ \hline
      Анализ не завершен       		& 91     	& 92        & 33    	\\ \hline
      Время CPU, с   				& 28 300 	& 23 800    & 25 600  	\\
      \hline
    \end{tabular}
  \end{table}

Для конфигураций Simple и Env присутствуют некоторое множество падений инструмента в различных частях инструмента, не связанных напрямую с ThreadCPA.
Это приводит к тому, что количество выданных вердиктов уменьшается при том что общее количество затраченного времени практически не меняется.
Тем не менее, можно заключить, что конфигурации Env и Base демонстрируют похожую точность анализа, в то время как Simple не способен доказать отсутствие ошибок для большей части примеров.
% Много падений в Env из-за counterexample could not be ruled out...

Результаты сравнения на наборе \textit{drivers/net/} представлены в таблице~\ref{table-drivers-thread}.

  \begin{table}[h]\footnotesize \centering
  	\label{table-drivers-thread}
    \caption{Сравнение  на наборе \textit{drivers/net/}}
    \begin{tabular}{ | l | c | c | c | c | c |}
      \hline
      					& \multicolumn{3}{c|}{\theoryraces} 			& \multicolumn{2}{c|}{\combatmode} 	\\
      Подход         				& Simple 	& Env 		& Base 		& Simple 	& Base  	\\ \hline
      Вердикт "ошибка" 				& 122    	& 10   		& 11   		& 36        & 36  	 	\\ 
  \hspace{0.5cm} из них корректных 	& 12 		& 10 		& 11   		& 28       	& 28   		\\ 
  \hspace{0.5cm} из них некорректных & 110 		& 0 		& 0   		& 8       	& 8     	\\ \hline
      Вердикт "нет ошибки"  		& 150      	& 262    	& 262    	& 256      	& 255     	\\ 
  \hspace{0.5cm} из них корректных 	& 150 		& 262    	& 262    	& 256       & 255   	\\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0     	& 0         & 0   		\\ \hline
      Анализ не завершен       		& 153     	& 153    	& 152    	& 133      	& 134   	\\ \hline
      Время CPU, с   				& 134 000 	& 132 000 	& 120 000 	& 110 000  	& 110 000   \\ 
      \hline
    \end{tabular}
  \end{table}

Реализация Simple не может точно определить, что некоторые эффекты являются несовместным, и из-за этого выдает лишние предупреждения.
При этом, такая простота реализации никак не помогает при поиске дополнительных ошибок, и время анализа, наоборот, увеличивается, так как много времени тратится на применение большого количества эффектов окружения.

Реализация Env с использованием эффектов окружения потока демонстрирует примерно такие же результаты, как и Base, так как обычно эффектов создания/удаления потока небольшое количество, и их присутствие не усложняет анализ.

Результаты сравнения реализаций ThreadCPA на ОС РВ представлены в таблице~\ref{table-os-thread}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на ядрах ОС РВ}
  	\label{table-os-thread}
    \begin{tabular}{ | l | c | c | c | c |}
      \hline
      		& 		\multicolumn{4}{c|}{\combatmode}  \\
      		& 		\multicolumn{2}{c|}{ОС РВ 1} & \multicolumn{2}{c|}{ОС РВ 2} 	\\
      Подход         					& Simple 	& Base 	& Simple 	& Base 		\\ \hline
      Число предупреждений 				& 461    	& 461   & 981     	& 981  		\\ 
      Общее время CPU, с				& 534      	& 582   & 887     	& 886  		\\ 
  \hspace{0.5cm} время ThreadCPA, с 	& 0,11 		& 0,17  & 0,148    	& 0,213   	\\
      \hline
    \end{tabular}
  \end{table}

В этом случае играет определенную роль свойство исходного кода.
Дело в том, что для ядра ОС РВ искусственно подготавливатся код, который создает все требуемые потоки, которые при реальном выполнении ОС могут быть запущены после каких-нибудь событий, например, после возникновения прерывания.
Все выделенные потоки создаются последовательно в одной функции, и в этом случае даже простой анализ потоков способен справиться, так как доступов к разделяемым данным до создания потока нет.

Основной вывод заключается в том, что в данном случае нет определенно бесполезных конфигураций. 
Env и Base обеспечивают корректные результаты на любых примерах, а конфигурация Simple может использоваться тогда, когда известны дополнительные свойства исходного кода.


\subsection{Сравнение различных вариантов обработки повторно создаваемого потока }

Для проведения экспериментов были использованы следующие конфигурации:

\begin{itemize}
\item Fail. Падение при попытке повторно создать поток.
\item Skip. Игнорирование повторно создаваемого потока.
\item Self. Абстракция от повторно создаваемого потока (создание самопараллельного потока).
\end{itemize}

Результаты сравнения на наборе SV-COMP представлены в таблице~\ref{table-svcomp-thread-create}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе SV-COMP}
  	\label{table-svcomp-thread-create}
    \begin{tabular}{ | l | c | c | c |}
      \hline
      		& 		\multicolumn{3}{c|}{\theory}  \\
      Подход         				& Fail 	& Skip 	& Self  	\\ \hline
      Вердикт "ошибка" 				& 972   & 986   & 1028       \\ 
  \hspace{0.5cm} из них корректных 	& 793 	& 802 	& 805    	\\ 
  \hspace{0.5cm} из них некорректных & 179 	& 184 	& 223     	\\ \hline
      Вердикт "нет ошибки"  		& 19    & 63    & 21       	\\ 
  \hspace{0.5cm} из них корректных 	& 19 	& 60    & 21      	\\
  \hspace{0.5cm} из них некорректных & 0 	& 3    	& 0     	\\ \hline
      Анализ не завершен       		& 91    & 33    & 33    	\\ \hline
      Время CPU, с   				& 26 200 & 26 400 & 28 000  \\ 
      \hline
    \end{tabular}
  \end{table}

Результаты реализации Fail демонструют, что в наборе SV-COMP присутствуют задачи, в которых используется создание потока с присваиванием в уже использованную структуру потока. 
Если игнорировать такие случаи и не создавать такой поток заново, это позволяет успешно доказать отсутствие ошибки для большого количества задач, однако такой подход позволяет пропустить ошибку, если ее появление зависит как раз от взаимодействия таких потоков.
Это демонстрируют три примера, в которых была пропущена ошибка.
Наиболее правильным вариантом в таком случае будет абстракция от количества созданных потоков, то есть конфигурация Self. 
Она не позволяет пропустить ошибку, но может получить большее количество вердиктов, чем конфигурация Fail.

Результаты сравнения на наборе \textit{drivers/net/} представлены в таблице~\ref{table-drivers-thread-create}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе \textit{drivers/net/}}
  	\label{table-drivers-thread-create}
    \begin{tabular}{ | l | c | c | c | c | c | c |}
      \hline
      				& 		\multicolumn{3}{c|}{\theoryraces} 		& \multicolumn{3}{c|}{\combatmode} \\
      Подход         				& Fail 		& Skip 		& Self 		& Fail 	& Skip 		& Self  \\ \hline
      Вердикт "ошибка" 				& 31   		& 32   		& 24   		& 37   	& 36   		& 35   \\ 
  \hspace{0.5cm} из них корректных 	& 23 		& 24 		& 17   		& 29   	& 28   		& 27   \\ 
  \hspace{0.5cm} из них некорректных & 8 		& 8 		& 7   		& 8   	& 8   		& 8   \\ \hline
      Вердикт "нет ошибки"  		& 253    	& 253    	& 253   	& 256   & 255  		& 255   \\ 
  \hspace{0.5cm} из них корректных 	& 253 		& 253    	& 253   	& 256   & 255   	& 255   \\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0     	& 0   	& 0   		& 0   \\ \hline
      Анализ не завершен       		& 141    	& 140    	& 148    	& 132   & 134   	& 135   \\ \hline
      Время CPU, с   				& 120 000 	& 120 000 	& 122 000 	& 110 000 & 110 000 & 116 000   \\ 
      \hline
    \end{tabular}
  \end{table}

Полученные результаты демонстрируют, что для задач из набора \textit{drivers/net/} конфигурация Self является избыточной, хотя и по-прежнему является наиболее точной.
Это объясняется особенностями модели окружения, которая отвечает за создание потоков. 
Дело в том, что для такой конфигурации становится невозможным ситуация, при которой несколько созданных потоков привязываются к одной структуре.
Зная этот факт, мы можем использовать более эффективные конфигурации Fail или Skip, которые становятся равнозначными, так как такие ситуации, приводящие к падению, произойти не могут.

Результаты cравнения на ОС РВ представлены в таблице~\ref{table-os-thread-create}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на ядрах ОС РВ}
  	\label{table-os-thread-create}
    \begin{tabular}{ | l | c | c | c | c | c | c |}
      \hline
      				& 		\multicolumn{3}{c|}{\combatmode} 		& \multicolumn{3}{c|}{\combatmode} \\
      						& 		\multicolumn{3}{c|}{ОС РВ 1} 		& \multicolumn{3}{c|}{ОС РВ 2} \\
      Подход         				& Fail 		& Skip 		& Self 		& Fail 		& Skip 		& Self  \\ \hline
      Число предупреждений			& 461   	& 461  		& 461  		& 981   	& 981   	& 981   \\ 
  	  Общее время CPU, с 			& 582 		& 565 		& 607  		& 886   	& 836	  	& 937   \\ 
\hspace{0.5cm} Время работы ThreadCPA & 0,15	& 0,17 		& 0,12 		& 0,213   	& 0,22 		& 0,16   \\ \hline
      Число созданных потоков  		& 497    	& 497    	& 497   	& 37   		& 37  		& 37   \\ 
      \hline
    \end{tabular}
  \end{table}

Эти результаты демонстрируют тот же эффект, что и результаты  сравнени на наборе \textit{drivers/net/}: используя особенности исходного кода, можно применять более эффективные в данном случае решения.
Однако, следует помнить, что такие конфигурации являются некорректными в общем случае, что подтверждают результаты на наборе SV-COMP.

\section{Сравнение различных вариантов реализации LockCPA}

\subsection{Сравнение вариантов реализации оператора $merge$}

Для проведения экспериментов были использованы следующие конфигурации:

\begin{itemize}
\item Sep. Базовая реализация LockCPA с оператором $merge_{Sep}$, при котором состояния никогда не объединяются.
\item Join. Реализация LockCPA с оператором $merge_{Join}$, при котором объединение состояний задается пересечением их множеств захваченных блокировок.
\end{itemize}

Результаты экспериментов на наборе SV-COMP представлены в таблице~\ref{table-svcomp-lock-merge}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе SV-COMP}
  	\label{table-svcomp-lock-merge}
    \begin{tabular}{ | l | c | c |}
      \hline
      		& 		\multicolumn{2}{c|}{\theory}  \\
      Подход         				&  Sep		& Join 		\\ \hline
      Вердикт "ошибка" 				& 1028   	& 1028   	\\ 
  \hspace{0.5cm} из них корректных 	& 805 		& 805 	 	\\ 
  \hspace{0.5cm} из них некорректных & 223 		& 223 	   	\\ \hline
      Вердикт "нет ошибки"  		& 21    	& 21     	\\ 
  \hspace{0.5cm} из них корректных 	& 21 		& 21    	\\
  \hspace{0.5cm} из них некорректных & 0 		& 0    	  	\\ \hline
      Анализ не завершен       		& 33    	& 33      	\\ \hline
      Время CPU, с   				& 25 600 	& 27 300  	\\ 
      \hline
    \end{tabular}
  \end{table}

Результаты не демонстрируют никакой разницы между подходами.
Это объясняется тем, что задачи в этом наборе достаточно простые, и в них практически невозможны ситуации, при которых в одной и той же точке программы могут быть захвачены различные блокировки.
Более того, почти во всех примерах вообще используется единственная блокировка, в то время как для объединения необходима хотя бы пара отличающихся состояний.

Результаты сравнения на наборе \textit{drivers/net/} представлены в таблице~\ref{table-drivers-lock-merge}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе \textit{drivers/net/}}
  	\label{table-drivers-lock-merge}
    \begin{tabular}{ | l | c | c | c | c | }
      \hline
      		& 		\multicolumn{2}{c|}{\theoryraces} 	& \multicolumn{2}{c|}{\combatmode}  \\
      Подход         				& Sep 		& Join 		& Sep 		& Join   	\\ \hline
      Вердикт "ошибка" 				& 31   		& 31   		& 37   		& 36   		\\ 
  \hspace{0.5cm} из них корректных 	& 23 		& 23 		& 29   		& 28     	\\ 
  \hspace{0.5cm} из них некорректных & 8 		& 8 		& 8   		& 8     	\\ \hline
      Вердикт "нет ошибки"  		& 253    	& 253   	& 256    	& 256      	\\ 
  \hspace{0.5cm} из них корректных 	& 253 		& 253   	& 256    	& 256     	\\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0     	& 0  		\\ \hline
      Анализ не завершен       		& 141    	& 141   	& 132    	& 133     	\\ \hline
      Время CPU, с   				& 121 000 	& 120 000 	& 110 000 	& 110 000   \\ 
      \hline
    \end{tabular}
  \end{table}

В данном случае имеют место минимальные отличия случайного характера, так как в данных задачах также используется небольшое количество блокировок. 
И даже если возможны некоторые ситуации, в которых возникнет отличие работы одного варианта LockCPA от другого, они не будут влиять на общий вердикт задачи.

Результаты сравнения на ядрах ОС РВ представлены в таблице~\ref{table-os-lock-merge}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на ядрах ОС РВ}
  	\label{table-os-lock-merge}
    \begin{tabular}{ | l | c | c | c | c | }
      \hline
      		& 		\multicolumn{4}{c|}{\theory}  \\
      		& 		\multicolumn{2}{c|}{ОС РВ 1} & \multicolumn{2}{c|}{ОС РВ 2}  \\
      Подход         					& Sep 	& Join 	& Sep 	& Join   	\\ \hline
      Число предупреждений				& 461   & 461   & 981   & 981   	\\ 
  	  Общее время CPU (с) 				& 582 	& 592 	& 886   & 889     	\\ 
  \hspace{0.5cm} Время работы LockCPA, с & 1,6 	& 1,3 	& 3,0   & 3,1     	\\ \hline
   	  Операций с блокировками			& 38526 & 41604 & 108367 & 108367      	\\ 
      \hline
    \end{tabular}
  \end{table}

\todo{счетчик захватов}

Несмотря на некоторые отличия в количестве операций, изменение оператора $merge$ снова никак не влияет на результаты.
Таким образом, можно сделать вывод о том, что состояния LockCPA являются слишком малочисленными для каждой конкретной точки программы.
Даже если там возникают несколько состояний, одно из них будет старше по решетке, чем другие, например, не будет содержать блокировок вообще. 
А значит, операции объединения становятся бессмысленными.

\subsection{Сравнение оптимизаций BAM}

\begin{itemize}
\item None. Базовая реализация LockCPA с отключенными оптимизациями.
\item Block. Использование абстракции от счетчика рекурсивных захватов блокировки только для тех абстрактных блоков, где не производится никаких действий с данной блокировкой.
\item All. Использование абстракции от счетчика рекурсивных захватов блокировки для всех абстрактных блоков.
\item Locks. Использование абстракции от неиспользуемых примитивов синхронизации.
\item Block-Locks. Одновременное использование и оптимизации Block, и оптимизации Locks.
\end{itemize}

Результаты сравнения на наборе \textit{drivers/net/} представлены в таблице~\ref{table-drivers-lock-reduce}

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе \textit{drivers/net/}}
  	\label{table-drivers-lock-reduce}
    \begin{tabular}{ | l | c | c | c | c | c |}
      \hline
      		& 		\multicolumn{5}{c|}{\combatmode}  \\
      Подход         				& None 	& Block 	& All 		& Locks 	& Block-Locks \\ \hline
      Вердикт "ошибка" 				& 35   	& 34       	& 35    	& 32       	& 32     \\ 
  \hspace{0.5cm} из них корректных 	& 27 	& 26 		& 27    	& 25       	& 25   \\ 
  \hspace{0.5cm} из них некорректных & 8 	& 8 		& 8     	& 7       	& 7    \\ \hline
      Вердикт "нет ошибки"  		& 255   & 255       & 255   	& 255       & 255     \\ 
  \hspace{0.5cm} из них корректных 	& 255 	& 255    	& 255   	& 255       & 255     \\
  \hspace{0.5cm} из них некорректных & 0 	& 0    		& 0     	& 0       	& 0  \\ \hline
      Анализ не завершен       		& 135    & 136      & 135    	& 138       & 134  \\ \hline
      Время CPU (с)   				& 89 600 & 91 000   & 90 000    & 90 400    & 91 700  \\ 
      \hline
    \end{tabular}
  \end{table}

В данном случае отличия являются минимальными и в рамках погрешности. 
Это объясняется тем, что в драйверах обычно используется небольшое множество примитивов синхронизации, которые редко предполагают возможность рекурсивного захвата.

Результаты сравнения на ядрах ОС РВ представлены в таблицах~\ref{table-os-lock-reduce-1},~\ref{table-os-lock-reduce-2}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на ядре ОС РВ 1}
  	\label{table-os-lock-reduce-1}
    \begin{tabular}{ | l | c | c | c | c | c | c | }
      \hline
      		& 		\multicolumn{5}{c|}{\combatmode}  \\
      Подход         						& None 			& Block 	& All		& Locks 	& Block-Locks	\\ \hline
      Число предупреждений 					& 461   		& 461       & 461   	& 461   	& 461       	\\ 
      Общее время CPU, с 					& 963 			& 759 		& 717   	& 616 		& 606 	 		\\ 
\hspace{0.5cm} Время reduce/expand при анализе, с & 0,3		& 0,4 		& 0,4   	& 0,5 		& 0,6 	  		\\ \hline
% \hspace{0.5cm} Время reduce/expand в конце, с & 0,06		& 0,08 		& 0,08   	& 0,13 		& 0,15 	  		\\ \hline
      Количество попаданий в BAM кэш		& 34305  		& 33893   	& 31656   	& 32893  	& 32893  	\\ 
      										& (47\%)		& (50\%)  	& (48\%)	& (63\%)	& (63\%)	\\
      \hline
    \end{tabular}
  \end{table}

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на ядре ОС РВ 2}
  	\label{table-os-lock-reduce-2}
    \begin{tabular}{ | l | c | c | c | c | c | c | }
      \hline
      		& 		\multicolumn{5}{c|}{\combatmode}  \\
      Подход         						& None 		& Block 	& All 		& Locks 	& Block-Locks 	\\ \hline % & All-Locks	 
      Число предупреждений 					& 981  		& 981      	& 892   	& 981   	& 981  		\\ % & 979  
      Общее время CPU, с 					& 1211 		& 1090 		& 777   	& 909 		& 858 			\\ % & 601  
\hspace{0.5cm} Время reduce/expand
 							при анализе, с	& 1,5 		& 3,7 		& 1,3   	& 1,5 		& 1,7 	 		\\ \hline % & 1,5 
% \hspace{0.5cm} Время reduce/expand в конце, с & ?		& ? 		& ?   		& ? 		& ? 	  		& 	\\ \hline
      Количество попаданий в BAM кэш		& 284253  	& 285655  	& 157505   	& 239473  	& 239473  		\\ % & 148996 	 
      										& (85\%)	& (89\%)	& (87\%)	& (91\%) 	& (91\%) 		\\ % & (91\%)	
      \hline
    \end{tabular}
  \end{table}

Для случая с ОС РВ можно сделать вывод, что использование эффективного варианта реализации $reduce/expand$ является принципиально важным, и может значительно ускорить анализ.
Это объясняется тем, что, в отличие от драйверов, в ядре операционной системе достаточно много сильно связанного кода, который может вызываться под различными блокировками.

Снижение количества найденных предупреждений для варианта All объясняется наличием сложных случаев захвата блокировки под условиями.
Например, в начале функции может быть проверка, если данная блокировка еще не захвачена, то она захватывается. 
Тогда, в случае All состояние на входе в функцию не будет содержать информацию о захваченной ранее блокировке, и она захватится второй раз.
Но на самом деле она будет захвачена дважды, что может сыграть определенную роль при ее освобождении. 

\subsection{Использование уточнения}

\begin{itemize}
\item Base. Базовая реализация LockCPA, которая рассматривает все возможные примитивы синхронизации с самого начала.
\item Refinement. Реализация LockCPA с использованием уточнения.
\end{itemize}

Результаты сравнения на наборе \textit{drivers/net/} представлены в таблице~\ref{table-drivers-lock-refinement}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе \textit{drivers/net/}}
  	\label{table-drivers-lock-refinement}
    \begin{tabular}{ | l | c | c | }
      \hline 
      		& 		\multicolumn{2}{c|}{\combatmode}  \\
      Подход         				& Base   	& Refinement \\ \hline
      Вердикт "ошибка" 				& 33    	& 31       \\ 
  \hspace{0.5cm} из них корректных 	& 25 		& 23 		\\ 
  \hspace{0.5cm} из них некорректных & 8 		& 8 		\\ \hline
      Вердикт "нет ошибки"  		& 255      	& 255       	\\ 
  \hspace{0.5cm} из них корректных 	& 255 		& 255    	\\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		\\ \hline
      Анализ не завершен       		& 137     	& 139        \\ \hline
      Время CPU (с)   				& 95 200 	& 94 100    \\ 
      \hline
    \end{tabular}
  \end{table}

В целом, результаты двух конфигураций на наборе \textit{drivers/net/} отличаются не сильно.
Это объясняется тем, что обычно используется небольшой набор примитивов синхронизации, который может быть легко вычислен за одну дополнительную итерацию уточнения.

Результаты сравнения на ядрах ОС РВ представлены в таблице~\ref{table-os-lock-refinement}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на ядрах ОС РВ}
  	\label{table-os-lock-refinement}
    \begin{tabular}{ | l | c | c | c | c | }
      \hline
      		& 		\multicolumn{4}{c|}{\combatmode}  \\
      		& 			 \multicolumn{2}{c|}{ОС РВ 1} & 		\multicolumn{2}{c|}{ОС РВ 2}\\
      Подход         					& Base  & Refinement  	& Base  & Refinement 	\\ \hline
      Выданные предупреждения			& 461   & 488    		& 981   & 1128  		\\ 
  	  Время CPU, с 						& 582   & 4952 			& 886   & 5170  		\\ 
  \hspace{0.5cm} Время на LockCPA, с	& 1,6   & 15    		& 1,7   & 4,8  			\\ \hline
      Операций с блокировками  			& 38526	& 310422   		& 108367 & 645978  		\\ 
      Количество уточнений  			& 0   	& 10   			& 0   	& 10  			\\ 
      \hline
    \end{tabular}
  \end{table}

В случае ОС РВ отличия становятся более масштабными, так как количество примитивов синхронизации резко возрастает и требуется значительное количество итераций, чтобы исключить все ложные предупреждения об ошибках, которые появились именно из-за неточностей LockCPA.
При этом возможный выигрыш из-за построения менее точной абстракции существенно меньше. 

Таким образом, можно сделать вывод, что реализация LockCPA с использованием уточнения является неэффективной и для небольших программ, и для достаточно объемных.

%На Refinement - таймаут! Поэтому не все unsafe успели уточниться.


\section{Сравнение вклада в точность анализа дополнительных CPA}

\subsection{Оценка эффекта оптимизации BAM}

\begin{itemize}
\item Base. Вариант анализа без использования BAM.
\item BAM. Использование оптимизации BAM.
\end{itemize}

Результаты сравнения на наборе \textit{drivers/net/} представлены в таблице~\ref{table-drivers-bam}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе \textit{drivers/net/}}
  	\label{table-drivers-bam}
    \begin{tabular}{ | l | c | c | }
      \hline
      		& 		\multicolumn{2}{c|}{\combatmode}  \\
      Подход         				& Base  	& BAM 	\\ \hline
      Вердикт "ошибка" 				& 5   		& 37    \\ 
  \hspace{0.5cm} из них корректных 	& 3 		& 29 	\\ 
  \hspace{0.5cm} из них некорректных & 2		& 8 	\\ \hline
      Вердикт "нет ошибки"  		& 248    	& 256    \\ 
  \hspace{0.5cm} из них корректных 	& 248 		& 256    \\
  \hspace{0.5cm} из них некорректных & 0 		& 0    	\\ \hline
      Анализ не завершен       		& 172    	& 132    \\ \hline
      Время CPU (с)   				& 51 500 	& 110 200 \\ 
      \hline
    \end{tabular}
  \end{table}

Результаты наглядно демонстрируют, что оптимизация BAM позволет значительно ускорить анализ, при этом новые ложные вердикты связаны не с самой оптимизацией BAM, а с другими свойствами анализа.
Оптимизация BAM лишь позволяет проявить эти свойства, избежав исчерпания лимита времени или памяти.
Отдельно отметим, что общее время с использованием оптимизации BAM было затрачено больше из-за большого количества падений конфигурации Base из-за нехватки памяти. 
Такие падения происходили достаточно быстро, что сокращало общее время работы.
% Большая часть Out of Memory

Результаты сравнения на ядрах ОС РВ представлены в таблице~\ref{table-os-bam}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на ядрах ОС РВ}
  	\label{table-os-bam}
    \begin{tabular}{ | l | c | c | c | c |  }
      \hline
      		& 		\multicolumn{4}{c|}{\combatmode}  \\
      		& 			 \multicolumn{2}{c|}{ОС РВ 1} & 	\multicolumn{2}{c|}{ОС РВ 2}\\ \hline
      Подход         					& Base  & BAM  		& Base  & BAM 	\\ \hline
      Выданные предупреждения			& 461   & - 	   	& 981   & -  			\\ 
  	  Время CPU, с 						& 582   & 10024		& 886   & 7843  		\\ 
      Проанализированных потоков		& 497   & 92    	& 37   	& 1  			\\ \hline
    \end{tabular}
  \end{table}

Для анализа такого сложного исходного кода, как ядро ОС РВ, оптимизация BAM является принципиально важной.
По количеству проанализированных потоков можно оценить насколько эта оптимизация ускоряет анализ.
Дело в том, что в отличие от драйверов в ядре ОС РВ присутствует большое количество сильно связанного кода, то есть кода, доступного из многих мест. 
Это приводит к большому количеству повторно анализируемых функций, что является очень затратным, если не переиспользовать предыдущие результаты.

%\subsection{Оценка эффекта использования ограничения на количество уточнений}
%
%\begin{itemize}
%\item Unlimit. Вариант анализа без ограничения на количество уточнений.
%\item Limit = 0. Вариант анализа без уточнений.
%\item Limit = 10. Вариант анализа c использованием 10 уточнений.
%\end{itemize}
%
%% график?

\subsection{Оценка эффекта использования анализа разделяемых данных}

\begin{itemize}
\item Base. Конфигурация инструмента без использования анализа разделяемых данных.
\item Shared. Конфигурация инструмента с использованием анализа разделяемых данных.
\end{itemize}

Результаты сравнения на наборе \textit{drivers/net/} представлены в таблице~\ref{table-drivers-shared}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе \textit{drivers/net/}}
  	\label{table-drivers-shared}
    \begin{tabular}{ | l | c | c |}
      \hline
      		& 		\multicolumn{2}{c|}{\combatmode}  \\
      Подход         				& Base 	& Shared 	\\ \hline
      Вердикт "ошибка" 				& 31   	& 33    	\\ 
  \hspace{0.5cm} из них корректных 	& 23 	& 24 		\\ 
  \hspace{0.5cm} из них некорректных & 8 	& 9 		\\ \hline
      Вердикт "нет ошибки"  		& 255   & 254    	\\ 
  \hspace{0.5cm} из них корректных 	& 255 	& 254    	\\
  \hspace{0.5cm} из них некорректных & 0 	& 0    		\\ \hline
      Анализ не завершен       		& 139    & 138     	\\ \hline
      Время CPU (с)   				& 93 300 & 95 100  	\\ 
      \hline
    \end{tabular}
  \end{table}

%Из-за других уточнений наставилось много предикатов.
В данном случае использование анализа разделяемых данных не приводит к значительному улучшению.
Это объясняется тем, что выделение новой памяти и ее инициализация производится обычно на начальном этапе загрузки модуля в однопоточном режиме, и только после этого обработчики драйвера регистрируются в системе и становятся доступными для вызова. 
Таким образом, анализ потоков успешно справляется с задачей исключения таких ложных ситуаций без анализа разделяемых данных.

Некоторое незначитеьлное ухудшение работы связано с тем, что, тем не менее, некоторые пути к доступам к данным, ранее считавшихся разделяемыми, были отброшены в конфигурации Shared.
И вместо отброшенных путей стали рассматриваться другие, которые содержали более сложные условия для анализа предикатов, что привело к более длительной процедуре уточнения и построению более детальной абстракции.

Результаты сравнения на ядрах ОС РВ представлены в таблице~\ref{table-os-shared}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на ядрах ОС РВ}
  	\label{table-os-shared}
    \begin{tabular}{ | l | c | c | c | c |  }
      \hline
      		& 		\multicolumn{4}{c|}{\combatmode}  \\
      		& 			 \multicolumn{2}{c|}{ОС РВ 1} & 	\multicolumn{2}{c|}{ОС РВ 2}\\
      Подход         					& Base  & Shared  	& Base  & Shared 	\\ \hline
      Выданные предупреждения			& 461   & 218    	& 981   & 447  			\\ 
  	  Время CPU, с 						& 582   & 1034  	& 886   & 568  		\\ 
  	  \hspace{0.5cm} Преданализ, с 		& --   	& 21  		& --   	& 19  		\\ 
      \hline
    \end{tabular}
  \end{table}

В данном случае анализ разделяемых данных значительно сокращает количество ложных предупреждений об ошибках, так как отсутствуют секции инициализации данных.
Таким образом, только анализ разделяемых данных может определить, что предупреждения является ложным.

Некоторое увеличения времени анализа не связано напрямую с анализом разделяемых данных, а происходит из-за дополнительных расходов на вычисление статистики.
% Время тратится на вычисления покрытия с BAM внутри restartAlgorithm, в ОС 1 кэш устроен значительно сложнее.
Это время является незначительным для второго случая из-за отличий кода.

\subsection{Оценка эффекта использования предикатного анализа}

\begin{itemize}
\item Predicate. Вариант анализа с использованием предикатной абстракции.
\item Lightweight. Использование анализа без использования предикатной абстракции
\end{itemize}

Результаты экспериментов на наборе SV-COMP представлены в таблице~\ref{table-svcomp-without-predicate}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе SV-COMP}
  	\label{table-svcomp-without-predicate}
    \begin{tabular}{ | l | c | c |}
      \hline
      		& 		\multicolumn{2}{c|}{\combatmode}  \\
      Подход         				&  Predicate	& Lightweight 		\\ \hline
      Вердикт "ошибка" 				& 1028   		& 1058   	\\ 
  \hspace{0.5cm} из них корректных 	& 805 			& 808 	 	\\ 
  \hspace{0.5cm} из них некорректных & 223 			& 250 	   	\\ \hline
      Вердикт "нет ошибки"  		& 21    		& 0     	\\ 
  \hspace{0.5cm} из них корректных 	& 21 			& 0    		\\
  \hspace{0.5cm} из них некорректных & 0 			& 0    	  	\\ \hline
      Анализ не завершен       		& 33    		& 24      	\\ \hline
      Время CPU, с   				& 25 600 		& 8 020  	\\ 
      \hline
    \end{tabular}
  \end{table}

Результаты подтверждают тот факт, что без анализа предикатов невозможно доказать недостижимость ошибочной метки, то есть корректность задачи, так как во всех задачах так или иначе присутствует условие.
Другими словами, все ошибочные метки являются синтаксически достижимыми.
% Сравнивать на sv-comp глупо, так как там всегда есть зависимости по данным

Результаты сравнения на наборе \textit{drivers/net/} представлены в таблице~\ref{table-drivers-predicate}.

  \begin{table}[h]\footnotesize \centering
    \caption{Сравнение на наборе \textit{drivers/net/}}
  	\label{table-drivers-predicate}
    \begin{tabular}{ | l | c | c | c | c |}
      \hline
      & 			 \multicolumn{2}{c|}{\theoryraces} & 	\multicolumn{2}{c|}{\combatmode}\\
      Подход         				& Predicate & Lightweight 	& Predicate & Lightweight\\ \hline
      Вердикт "ошибка" 				& 31   		& 144   	& 37   		& 168  	\\ 
  \hspace{0.5cm} из них корректных 	& 23 		& 86 		& 29   		& 86 	\\ 
  \hspace{0.5cm} из них некорректных & 8 		& 58 		& 8   		& 82 	\\ \hline
      Вердикт "нет ошибки"  		& 253    	& 226    	& 256   	& 226 	\\ 
  \hspace{0.5cm} из них корректных 	& 253 		& 226    	& 256   	& 226 	\\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0   		& 0 	\\ \hline
      Анализ не завершен       		& 128    	& 55    	& 132   	& 31  	\\ \hline
      Время CPU (с)   				& 121 000 	& 37 700 	& 110 000  	& 14 200\\ 
      \hline
    \end{tabular}
  \end{table}

Результаты показывают, что использование анализа предикатов существенно повышает точность анализа, хотя для некоторых примеров оказывается возможным доказать отсутствие состояний гонки и без него.

Результаты сравнения на ядрах ОС РВ представлены в таблице~\ref{table-os-predicate}.

  \begin{table}[h] \footnotesize \centering
    \caption{Сравнение различных вариантов реализации оператора $merge$}
  	\label{table-os-predicate}
    \begin{tabular}{ | l | c | c | c | c |  }
      \hline
      		& 		\multicolumn{4}{c|}{\combatmode}  \\
      		& 			 \multicolumn{2}{c|}{ОС РВ 1} & 	\multicolumn{2}{c|}{ОС РВ 2}\\
      Подход         					& Predicate  & Lightweight 	& Predicate  & Lightweight 	\\ \hline
      Выданные предупреждения			& 461   	& 521    		& 981   	& 1037  			\\ 
  	  Время CPU, с 						& 582   	& 107  			& 886   	& 195  		\\ 
      \hline
    \end{tabular}
  \end{table}
  
Заметим, что даже без использования уточнения предикатный анализ способен сократить количество ложных срабатываний за счет оптимизации ABE, которая способна отсекать недостижимые пути в рамках одного блока, в котором строится полная формула пути.
При этом для дальнейшего отсеивания ложных предупреждений необходмо проведение процедуры уточнения для добавления предикатов.

%----------------------------------------------------
\section{Поиск известных ошибок в драйверах ОС Linux}
Мы подготовили 32 тестовых программы на основе 16 известных ошибок, найденных в модулях ядра операционной системы Linux\footnote{в течение GSoC 2017 http://linuxtesting.org/28-08-2017}
Для каждой ошибки доступны два варианта: {\em false} (с достижимой ошибкой) и {\em true} (исправленный вариант).

Задания были подготовлены с помощью системы Klever. В частности, при подготовки заданий были заменены примитивы синхронизации ядра на конструкции библиотеки posix (mutex\_lock и spin\_lock были заменены на pthread\_mutex\_lock), а также добавлена модель окружения драйвера.

Кроме того, предпринимались попытки запуска других инструментов-участников соревнования sv-comp. 
Однако, большинство из них, так или иначе, работали некорректно. 
Так, YogarCBMC падает с ошибкой сегментирования, а SMACK -- получает exception. Последнюю ушибку можно избежать, отключив в конфигурации инструмента один из видов анализа, но после этого возникает таймаут.


\section{Анализ причин ложных срабатываний}

\subsection{Ложные предупреждения на драйверах ОС Linux}

Анализ ложных предупреждений проводился на драйверах подсистемы \textit{drivers/net/} ОС Linux.
Стоит отметить, что в данном случае рассматривались ложные предупреждения в целом, а не только из-за инструмента CPALockator.
Таким образом, количество ложный предупреждений будет выше, чем при анализе различных конфигураций, так как в тех разделах не учитывались неточности, связанные с подготовкой верификационной задачи.

Было проанализировано \todo{x} предупреждений.

% Linux device drivers
% Benign: 7
%EMG: 9
%Lockator: 25
%LDVVariables: 2
%LockAnalysis: 3
%ad-hoc sync: 2
%ProtectedGet: 1
%MemoryModel: 17
%PredicateAnalysis: 3
%SharedAnalysis: 2

\subsection{Ложные предупреждения на ОС РВ}

%Подозрительное место	210	33,76%
%Некритичное место	57	9,16%
%Один поток	50	8,04%
%intNest	17	2,73%
%shared merge	51	8,20%
%Разные структуры	33	5,31%
%Данные от пользователя	110	17,68%
%Список	5	0,80%
%Уточнение	58	9,32%
%curproc	4	0,64%
%Другое	27	4,34%
%	622	

% старый сервер
% Bugs: 4
%verifier: 16
%intNest: 4
%local: 11
%objAllocate: 8
%thread-local cond: 1
%mqSAFE_UNSET: 1



% Реальные ошибки: 12
%Без тегов: 7
%Benign: 5
%Ложные сообщения об ошибках: 21
%EnvironmentModel: 5
%ThreadCreation: 4
%Verifier: 16
%Lockator: 16
%SharedAnalysis: 6
%SharedMerge: 2
%LockAnalysis: 7
%if-lock: 1
%Signals: 1
%Interrupts: 2
%ProtectedGet: 1
%MemoryModel: 3
%Неизвестно: 3
%Без тегов: 1
%Verifier: 1
%Lockator: 1
%LockAnalysis: 1
%Ad-hoc sync: 1
%Question: 1




%Покрытие!

В результате разметки было получено, что около 30\% полученных предупреждений соответсвуют реальным ошибкам. 
При этом для одного состояния гонки может быть выдано несколько предупреждений на различные переменные, работа с которыми производится похожим образом.
Таким образом, получается, что около 1\% проверенных модулей содержат ошибки, связанные с состоянием гонки.
При этом часть из ошибок находится в неподдерживаемых модулях, и такие ошибки, как правило, не исправляются, даже если и признаются. 
Другая часть ошибок оказывается безобидными, то есть, не способными нанести какой-либо вред.
Такие ошибки, хотя и признаются разработчиками, все равно не исправляются, так как их исправление, как и исправление многих ошибок, связанных с параллельным выполнением кода, требует серьезных изменений кода.
В среднем, только половина найденных ошибок доходит до подготовки патча, исправляющего эту ошибку.

Наиболее важной причиной ложных срабатываний стало несовершенство модели окружений, из-за которой было  получено  более  50\%  ложных  предупреждений.
Например,  некоторые функции-обработчики  драйвера  при  реальном  выполнении  вызываются  под блокировками, в то время как в модели этот факт не учитывается.
Кроме того зачастую  возникают  неявные  зависимости  между  обработчиками  разных структур,  которые  не  позволяют  им  выполняться одновременно  и  которые также  не  учитываются  в  модели  окружения.
Следует  еще  раз  отметить, что модель окружения относится к этапу подготовки задачи, а не к методу анализу непосредственно. 

Возникали  ситуации,  в  которых  структуры  одного  типа  использовались  для разного  назначения,  которое  предполагало  наличие  различных  блокировок. 
Таким образом, упрощенная модель памяти, которую используется в методе, принесла около 10\% ложных предупреждений. 
Еще 10\%  ложных  предупреждений  связаны  с  ситуациями,  в  которых  из разделяемого множества достается объект под блокировками, а работа с ним 
осуществляется  без них.
Около 10\% связаны с  неточностями анализа: это и несовершенство анализа функциональных указателей, и проблемы в анализе примитивов  синхронизации  (в т. ч. отсутствие некоторых  блокировок  в конфигурации), и неточности в анализе разделяемых данных.  

Таким   образом,   представленный   метод   поиска  состояний  гонок в операционных системах продемонстрировал практически значимые результаты
с приемлемым уровнем ложных срабатываний.
Являясь, по сути, легковесным методом, он допускает более гибкую настройку баланса между ресурсами и точностью анализа.


\section{Выводы по результатам экспериментов}

\subsection{Выводы по использованным конфигурациям}

Как невозможно создать универсальный инструмент, способный находить любые ошибки в любых программах, так и невозможно указать универсальную конфигурацию, которая будет лучше для всех задач. 
Однако, имеет смысл обозначить те или иные случаи, в которых будет лучше та или иная конфигурация.

Среди различных видов реализации оператора $merge$ для PredicateCPA в большинстве случаев оказывается достаточным реализация Join. 
Sep является слишком медленной, а ее точность не нужна почти во всех случаях. Реализация Eq близка к Join как по временным показателям, так и по количеству найденных вердиктов.

Оптимизации PredicateCPA обладают различными характеристиками. ABE позволяет ускорить анализ во всех случаях, но для больших задач полученное ускорение становится наиболее заметным. 
Оптимизация с применением релевантных эффектов становится значимой только при большом количестве уточнений, то есть для сложных задач.
Тем не менее, эти оптимизации не снижают точность анализа, а значит, могут применяться в любых случаях.
Оптимизация с присваиванием неопределенных значений ускоряет анализ, но для искусственных тестов это сопровождается снижением точности.
Для исходного кода более сложных задач такое падение точности не наблюдается, а значит, такая оптимизация может применяться в таких случаях.
Оптимизации с игнорированием разделяемых данных значительно снижают точность, но позволяют ускорить анализ.
Но более важное их свойство состоит в том, что они делают анализ предикатов инвариантным к эффектам окружения, что позволяет применять более сложные оптимизации, в том числе, BAM.
Таким образом, они могут быть использованы при анализе большого объема исходного кода, который не позволяет провести полноценный точный анализ.

Реализации ThreadCPA с эффектами окружения и без них практически равнозначны, однако, для использования других оптимизаций выгоднее иметь такой вариант анализа потоков, который будет инвариантным к эффектам окружения.
Простая реализация ThreadCPA является слишком простой для решения задач, в которых предполагается порождение потоков внутри других, однако является достаточным при анализе искуственно подготовленного кода для некоторых ОС РВ.
Повторно создаваемые потоки могут встречаться в различных искусственных тестах, однако это является нетипичным случаем для модели окружения драйверов и ОС РВ.
Таким образом, в общем случае вариант с абстракцией от повторно создаваемого потока поможет обеспечить отсутствие пропуска ошибки, а при решении прикладных задач более эффективным будет вариант с игнорированием таких ситуаций.

Реализации LockCPA с использованием оператора $merge_{Join}$ и с использованием уточнения являются бессмысленными на всех наборах, на которых проводилось исследование. 
Таким образом, эффективнее становится использовать простой вариант анализа примитивов синхронизации, в котором отсутствует объединение состояний.
Реализации $reduce/expand$ становятся значимыми только при анализе большого объема исходного кода.
Тем не менее, существуют вариант реализации этих операторов, которые могут привести к пропуску ошибок в определенных ситуациях, хотя при этом позволяют получить существенное ускорение анализа.

Использование анализа разделяемых данных не приводит к сколько-нибудь заметному снижению скорости анализа, но при этом возможно снижение числа выданных ложных предупреждений об ошибках. 
Это число сильно зависит от возможностей анализа потоков, который также может отсеивать часть ложных сообщений, связанных с инициализацией, поэтому наиболее заметный эффект достигается при анализе кода, который не содержит таких зависимостей (ядро ОС РВ).

Использование оптимизации BAM позволяет существенно сократить требования по расходуемой памяти и времени для проведения анализа.
Существенное ограничение данной оптимизации состоит в том, что она требует инвариантности к эффектам окружения, хотя это и не является принципиальным ограничением.
Другими словами, оптимизация позволяет расширение на случай подхода с раздельным рассмотрением потоков, однако это не является темой данной работы и может быть дальнейшим развитием.

Использование анализа предикатов позволяет существенно повысить точность анализа, однако имеется возможность полностью отказаться от него, что, по сути, является реализацией варианта простого легковесного анализа потоков данных. 
Такой вариант также может иметь место для поиска ошибок в большом объеме исходного кода или в жестких временных рамках.

\subsection{Выводы по результатам анализа предупреждений об ошибках}


%\newpage
%============================================================================================================================

\clearpage