\chapter{Результаты экспериментов}
\label{chapter_evaluation}

% Опции:
% Composite lattice

\section{Общая схема проведения экспериментов}

Основными целями проведения экспериментов являются:
\begin{enumerate}
\item cравнение с ведущими инструментами в области поиска состояний гонки и верификации многопоточных программ;
\item оценка различных конфигураций инструмента.
\end{enumerate}

Сравнение с ведущими инструментами статической верификации будет проводиться на наборе тестовых задач SV-COMP\footnote{https://sv-comp.sosy-lab.org/2020/}.
Категория {\em ConcurrencySafety} состоит из 1082 задач, большая часть из которых являются небольшими примерами около 100 строк кода
Для всех задач требуется доказать достижимость некоторого ошибочного состояния. 
В основном, используются т.н. выражения \textit{assert} и требуется доказать, что условия в них не нарушаются. 
Этот набор задач был подготовлен вручную, и содержит редко встречающиеся конструкции работы с многопоточными программами.
Однако, они содержат в себе нетривиальные механизмы синхронизации, в том числе алгоритмы Деккера, Петерсона и др.
7 задач были подготовлены на основе драйверов ОС Linux. Все задачи доступны в официальном репозитории SV-COMP\footnote{https://github.com/sosy-lab/sv-benchmarks}.

Сравнение различных конфигураций инструмента будет проводиться на трех множествах задач: набор тестовых задач SV-COMP, набор задач, подготовленных на основе драйверов операционной системы Linux, и задачи, подготовленные на основе ядер закрытых операционных систем реального времени.
Верификационные задачи, основанные на драйверах операционной системы Linux, были подготовлены системой Klever, которая предназначена для верификации различного программного обеспечения~\cite{kleverPsi},~\cite{kleverIsola}.
Она разделяет большой объем целевого исходного кода на отдельные небольшие верификационные задачи.
Для ядра операционной системы Linux верификационная задача соответствует одному модулю.
Система Klever автоматически готовит модель окружения модуля, которая включает в себя модель потоков, модель сердцевины ядра и операций над модулем.
После подготовки верификационной задачи Klever запускает верификацию через общий интерфейс -- BenchExec~\cite{benchexec2019}.
Сравнение проводилось на подсистеме drivers/net/ ядра операционной системы Linux 4.2.6, для которой Klever подготовил 425 верификационных задач.

Эксперименты на наборе задач SV-COMP и наборе драйверов проводились с использованием кластера из 191 машины VerifierCloud\footnote{https://vcloud.sosy-lab.org/cpachecker/webclient/master/info}.
В нем специально были выбраны машины с одним типом процессора Intel Xeon E3-1230 v5, 3.40 GHz.
Были использованы ограничения по памяти в 8 Гб и по времени 15 минут.

Эксперименты на задачах, основанных на ядрах операционных систем реального времени были проведены на локальной машине...

Оценка различных конфигураций анализа будет проводиться для следующих настроек:
\begin{itemize}
\item PredicateCPA.
\begin{itemize}
\item Варианты реализации оператора $merge$:
\begin{itemize}
\item Join;
\item Eq;
\item Sep;
\end{itemize}
\item Оптимизация ABE;
\item Оптимизация с присваиванием неопределенных функций;
\item Оптимизация с применением только релевантных эффектов;
\item Использование единственного эффекта "* = *";
\item Игнорирование разделяемых данных в формуле пути;
\item Использование локального уточнения;
\end{itemize}
\item ThreadCPA.
\begin{itemize}
\item Простой вариант инвариантный к эффектам окружения.
\item Вариант с эффектами окружения.
\item Сложный вариант инвариантный к эффектам окружения.
\item Игнорирование повторно создаваемого потока.
\item Абстракция от повторно создаваемого потока (создание самопараллельного потока).
\end{itemize}
\item LockCPA.
\begin{itemize}
\item Варианты реализации оператора $merge$:
\begin{itemize}
\item Join;
\item Sep;
\end{itemize}
\item Использование абстракции от счетчика рекурсивных захватов блокировки.
\item Использование абстракции от неиспользуемых примитивов синхронизации.
\item Использование уточнения.
\item Остановка анализа при превышении количества максимально-допустимого количества рекурсивных захватов блокировки.
\end{itemize}
\item Использование анализа разделяемых данных.
% \item Использование ограничения на количество разрешенных уточнений.
\item Использование оптимизации BAM.
% \item Использование различных способов вычисления одинаковых точек программы.
% \item Игнорирование предупреждений о состоянии гонки с пустым множеством блокировок.
\end{itemize}

%Было реализовано две основные модификации анализа с раздельным рассмотрением потоков с эффектами окружения
%\begin{enumerate}
%\item $\mathbb{C_1}(\mathbb{L}, \mathbb{CS}, \mathbb{T}, \mathbb{S}, \mathbb{P})$ -- включает анализ потоков, ограниченный количеством создаваемых потоков;
%\item $\mathbb{C_2}(\mathbb{L}, \mathbb{CS}, \mathbb{S}, \mathbb{P})$ -- поддерживает неограниченное создание потоков;
%\end{enumerate}
%с объединением эффектов окружения анализа предикатов $\mathbb{P}$ при равных состояниях другив видов анализа $\mathbb{T}$, $\mathbb{S}$
%(то есть, равных точках программы, стеках вызова, потоках и множествах захваченных блокировок),\\
%где
%\begin{itemize}
%\item Анализ точек программы $\mathbb{L}$~(раздел \ref{sect_location_analysis})
%\item Анализ стеков вызова $\mathbb{CS}$~(служебный анализ, не описан в теории)
%\item Анализ потоков $\mathbb{T}$~(раздел \ref{sect_thread_analysis}),
%\item Анализ примитивов синхронизации $\mathbb{S}$~(раздел \ref{sect_lock_analysis}), 
%с опцией 
%\begin{enumerate}
%\item {\em EmptyLockset=true/false}
%\begin{itemize}
%\item true -- отключить эффекты окружения, используя $empty$ эффект окружения (всегда является совместным)
%\item false -- использовать множества захваченных блокировок, как эффект окружения (проверять пересечение захваченных блокировок при вычислении совместности).
%\end{itemize}
%\end{enumerate}
%
%\item Анализ предикатов $\mathbb{P}$~(раздел~\ref{sect_predicate_analysis}).
%с опциями:
%\begin{itemize}
%\item {\em Merge=Join}. Объединение первой (условие) и второй (формула перехода) части эффекта окружения.
%\item {\em Merge=Eq}. Объединение эффектов окружения при одинаковом условии (то есть, при равных предикатных абстракциях).
%\item {\em Merge=Sep}. Не объединять эффекты никогда.
%\end{itemize}
%\end{itemize}
%
%TODO: Добавить $\mathbb{C_2}$?
%%Now only $\mathbb{C_1}$ is presented.
%
%Подходы для сравнения
%\begin{enumerate}
%\item Варианты анализа с эффектами окружения
%\begin{enumerate}
%\item {\textbf EmptyLockset} -- отключение условие на проверку множества захваченных блокировок {\em EmptyLockset=true} и {\em Merge=Join} опции в анализе предикатов.
%\item Включенная опция {\em EmptyLockset=false} с вариантами объединения для анализа предикатов
%\begin{enumerate}
%\item {\textbf MergeJoin}. Объединять обе части эффекта окружения({\em Merge=Join}). 
%\item {\textbf MergeEq}. Объединять эффекты только для равных условий ({\em Merge=Eq}).
%\item {\textbf MergeSep}. Не объединять эффекты ({\em Merge=Sep}). 
%\end{enumerate}
%\end{enumerate}
%\item {\textbf Threading}. Анализ с перебором различных чередований потоков, реализованный в концепции CPA~\cite{MEMICS16-Multi-Threaded}, который использует классический вариант теории(см. раздел~\ref{sect_classic_cpa}).
%\item Другие ведущие инструменты YogarCBMC, SMACK, CSeq, ESBMC
%\end{enumerate}

%----------------------------------------------------
\section{Сравнение различных инструментов статической верификации}

Для проведения экспериментов были выбраны следующие инструменты:

\begin{itemize}
\item PredicateTM. Реализация подхода с раздельным рассмотрением потоков с использованием анализа предикатов. 
Включает в себя следующие CPA: ThreadModularCPA, ARGCPA, CompositeCPA, LocationCPA, CallstackCPA, LockCPA, ThreadCPA, PredicateCPA.
\item ValueTM. Реализация подхода с раздельным рассмотрением потоков с использованием анализа явных значений. 
Включает в себя следующие CPA: ThreadModularCPA, ARGCPA, CompositeCPA, LocationCPA, CallstackCPA, LockCPA, ThreadCPA, ValueCPA.
\item Threading. Реализация классического варианта анализа с чередованиями потоков~\cite{MEMICS16-Multi-Threaded}. 
Реализован в том же фреймворке CPAchecker, но с использованием классической версии теории.
\item Yogar-CBMC. Победитель соревнования SV-COMP'19, реализует подход ограничиваемой проверки моделей с некоторыми оптимизациями.
\item Lazy-CSeq. Серебряный призер соревнования SV-COMP'19, реализует подход секвенциализации программы.
\end{itemize}

Результаты экспериментов представлены в таблице~\ref{table-sv-comp}.

\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-sv-comp-tools}
    \caption{Запуск на наборе задач SV-COMP}
    \begin{tabular}{ | l | c | c | c | c | c | c |}
      \hline
      Подход         				& PredicateTM   & ValueTM 	& Threading & Yogar-CBMC 	& Lazy-CSeq  \\ \hline
      Вердикт "ошибка" 				& 1028    		& 241       & 727      	& 773       	& 811       \\ 
  \hspace{0.5cm} из них корректных 	& 805 			& 59 		& 727      	& 773       	& 811       \\ 
  \hspace{0.5cm} из них некорректных & 223 			& 182 		& 0    		& 0       		& 0          \\ \hline
      Вердикт "нет ошибки"  		& 21      		& 20        & 165       & 284        	& 256     \\ 
  \hspace{0.5cm} из них корректных 	& 21 			& 20    	& 165       & 284        	& 256       \\
  \hspace{0.5cm} из них некорректных & 0 			& 0    		& 0       	& 0         	& 0        \\ \hline
      Анализ не завершен       		& 33     		& 821       & 190      	& 25        	& 15      \\ \hline
      Время CPU (с)   				& 27 600 		& 38 200    & 111 000  	& 7 000    		& 29 000    \\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}

% Value без уточнения!

Общие выводы из полученных результатов являются следующими.

Результаты подтверждают, что подход с раздельным анализом потоков не пропускает ошибок при некоторых заранее известных ограничениях.

Конфигурация ValueTM является достаточно простым и быстрым анализом, но иногда она вынуждена рассматривать все возможные варианты значений переменных, что приводит к исчерпанию ресурсов по времени.

Классический анализ Threading является корректным и точным и не выдает ложных вердиктов.
Однако, он требует значительного числа ресурсов, это является главным недостатком подхода.
Эта конфигурация решила только один из семи сложных задач, основанных на драйверах операционной системы Linux.
Подход с раздельным анализом потоков (PredicateTM) решает пять из семи таких задач. 

Большая часть новых доказательств корректности, полученных подходом с раздельным рассмотрением потоков, (26 из 27 для PredicateTM) не находились классическими методами (Threading). Это также является одним из важных вкладов данного метода.

Подход с раздельным рассмотрением потоков выдает большое количество ложных предупреждений об ошибке. 
Большинство из них связаны с неподдерживаемыми атомарными конструкциями, такими как 'compare and swap' {\em \_\_VERIFIER\_atomic\_CAS}.
Еще в некоторых случаях данный подход не способен определить отношение happens-before между созданием потока (дочерний поток не может работать одновременно с родительским до точки своего создания).
Текущие ограничения процедуры уточнения не позволяют определять и расставлять интерполянты на поток, исходный для эффекта окружения.
В небольшой части случаях требовалось точное рассмотрение переключений между потоками.

\section{Сравнение различных вариантов анализа предикатов}

\subsection{Сравнение различных реализаций оператора merge}

Для проведения экспериментов были выбраны использованы следующие конфигурации:

\begin{itemize}
\item MergeJoin. Реализация оператора $merge_{Join}$.
\item MergeEq. Реализация оператора $merge_{Eq}$.
\item MergeSep. Реализация оператора $merge_{Sep}$.
\end{itemize}

\subsubsection{Сравнение на множестве задач SV-COMP}

Результаты экспериментов представлены в таблице~\ref{table-sv-comp-merge}.

\begin{center}
  \begin{table}[h]\footnotesize \centering
    \caption{Запуск на наборе задач SV-COMP}
  	\label{table-sv-comp-merge}
    \begin{tabular}{ | l | c | c | c | }
      \hline
      Подход         				& MergeJoin & MergeEq 	& MergeSep   \\ \hline
      Вердикт "ошибка" 				& 1028    	& 1028		& 988         \\ 
  \hspace{0.5cm} из них корректных 	& 805 		& 805 		& 763      \\ 
  \hspace{0.5cm} из них некорректных & 223 		& 223 		& 225        \\ \hline
      Вердикт "нет ошибки"  		& 21      	& 21        & 21       \\ 
  \hspace{0.5cm} из них корректных 	& 21 		& 21    	& 21        \\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0         \\ \hline
      Анализ не завершен       		& 33     	& 33        & 73       \\ \hline
      Время CPU (с)   				& 27 600 	& 25 200    & 69 400    \\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}

MergeJoin показывает результаты лучше, чем конфигурация MergeSep.
Это происходит, в основном, из-за большого количества переходов в окружении, которые MergeSep рассматривает по одному.
MergeJoin объединяет их в один и применяет за один раз. Это позволяет сохранить огромное количество времени.
В то же время MergeSep позволяет избежать некоторых неточностей из-за анализа переходов по-отдельности и выдает меньшее количество ложных сообщений об ошибках. 

Два лишних некорректных результата были получены из-за того, что в данной конфигурации отсутствует падение инструмента при уточнении, которое присутствует в первых двух конфигурациях.

%Подробности?
Небольшое отличие времен работы MergeJoin и MergeEq объясняется некоторыми флуктуациями работы внешнего компонента -- решателя. 
Например, в некоторых примерах при одинаковом количестве уточнений построение абстракции для MergeEq занимает меньше времени, чем для MergeJoin.

\subsubsection{Сравнение на множестве драйверов \textit{drivers/net/} }

Результаты экспериментов представлены в таблице~\ref{table-drivers-merge}.

\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-drivers-merge}
    \caption{Сравнение реализаций оператора $merge$ на наборе задач drivers/net}
    \begin{tabular}{ | l | c | c | c | }
      \hline
      Подход         				& MergeJoin	& MergeEq 	& MergeSep   \\ \hline
      Вердикт "ошибка" 				& 24    	& 22  		& 18         \\ 
  \hspace{0.5cm} из них корректных 	& 17 		& 17 		& 13      \\ 
  \hspace{0.5cm} из них некорректных & 7 		& 5 		& 5        \\ \hline
      Вердикт "нет ошибки"  		& 253      	& 253        & 253       \\ 
  \hspace{0.5cm} из них корректных 	& 253 		& 253    	& 253        \\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0         \\ \hline
      Анализ не завершен       		& 148     	& 150        & 154       \\ \hline
      Время CPU (с)   				& 122 000 	& 122 000    & 128 000    \\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}

\subsection{Сравнение влияния оптимизаций}

Для проведения экспериментов были использованы следующие конфигурации:

\begin{itemize}
\item Base. Базовая реализация предикатного анализа с отключенными оптимизациями.
\item Undef. Оптимизация с присваиванием неопределенного значения.
\item Relevance. Оптимизация с применением только релевантных эффектов.
\item ABE. Оптимизация ABE.
%\item Havoc. Использование единственного эффекта "* = *".
% Проблемы с восстановлением пути для уточнения: какой дугой представить * = *?
\item Havoc. Игнорирование разделяемых данных в формуле пути.
\item Imprecise. Использование локального уточнения.
\end{itemize}

\subsubsection{Сравнение на множестве задач SV-COMP}

Результаты экспериментов представлены в таблице~\ref{table-sv-comp-merge}.

\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-sv-comp-opt}
    \caption{Сравнение оптимизаций на наборе SV-COMP}
    \begin{tabular}{ | l | c | c | c | c | c | c | }
      \hline
      Подход         				& Base 	& Undef 	& Relevance & ABE 	& Havoc 	&  Imprecise \\ \hline
      Вердикт "ошибка" 				& 1027  & 1033  	& 1027      & 1026  & 1055     	& 1052       \\ 
  \hspace{0.5cm} из них корректных 	& 802 	& 805 		& 802     	& 803   & 808    	& 808     	\\ 
  \hspace{0.5cm} из них некорректных & 225 	& 228 		& 225     	& 225  	& 244      	& 244       \\ \hline
      Вердикт "нет ошибки"  		& 21    & 21    	& 21    	& 21   	& 5     	& 2       \\ 
  \hspace{0.5cm} из них корректных 	& 21 	& 21    	& 21     	& 21   	& 5     	& 2       \\
  \hspace{0.5cm} из них некорректных & 0 	& 0    		& 0     	& 0   	& 0     	& 0       \\ \hline
      Анализ не завершен       		& 55     & 26     	& 55     	& 54   	& 27     	& 30      	\\ \hline
      Время CPU, с   				& 30 900 & 21 600 	& 30 100  	& 26 600 & 13 500   & 15 200     	\\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}

\subsubsection{Сравнение на множестве драйверов \textit{drivers/net/} }

Результаты экспериментов представлены в таблице~\ref{table-drivers-merge}.

\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-drivers-opt}
    \caption{Сравнение оптимизаций на наборе задач drivers/net}
    \begin{tabular}{ | l | c | c | c | c | c | c |}
      \hline
      Подход         				& Base 		& Undef		& Relevance & ABE 		& Havoc   	\\ \hline
      Вердикт "ошибка" 				& 12  		& 13   		& 13       	& 19   		& 15     	\\ 
  \hspace{0.5cm} из них корректных 	& 9 		& 9 		& 9     	& 14   		& 10     	\\ 
  \hspace{0.5cm} из них некорректных & 3 		& 4 		& 4     	& 5  		& 5      	\\ \hline
      Вердикт "нет ошибки"  		& 253    	& 253    	& 253     	& 253   	& 253    	\\ 
  \hspace{0.5cm} из них корректных 	& 253 		& 253    	& 253       & 253   	& 253    	\\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0      	& 0   		& 0     	\\ \hline
      Анализ не завершен       		& 160    	& 159    	& 159     	& 153   	& 157    	\\ \hline
      Время CPU, с   				& 98 400 	& 98 400 	& 90 500  	& 73 900   	& 87 900    \\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}



\subsubsection{Сравнение на множестве драйверов \textit{drivers/net/}}
Результаты экспериментов представлены в таблице~\ref{table-os-thread}.

\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-drivers-opt}
    \caption{Сравнение оптимизаций на наборе задач drivers/net}
    \begin{tabular}{ | l | c | c |}
      \hline
      Подход         				& Precise	& Imprecise	  	\\ \hline
      Вердикт "ошибка" 				& 7  		& 21   			\\ 
  \hspace{0.5cm} из них корректных 	& 7 		& 16 		  	\\ 
  \hspace{0.5cm} из них некорректных & 0 		& 5 		    \\ \hline
      Вердикт "нет ошибки"  		& 260    	& 254    	    \\ 
  \hspace{0.5cm} из них корректных 	& 260 		& 254    	  	\\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		   	\\ \hline
      Анализ не завершен       		& 158    	& 150    	   	\\ \hline
      Время CPU, с   				& 84 100 	& 71 700 	 	\\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}


\subsubsection{Сравнение на ОС РВ}
Результаты экспериментов представлены в таблице~\ref{table-os-thread}.

\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-os-thread}
    \caption{Сравнение различных вариантов реализации оператора $merge$}
    \begin{tabular}{ | l | c | c | c | c |}
      \hline
      		& 		\multicolumn{2}{|c|}{ОС РВ 1} & \multicolumn{2}{|c|}{ОС РВ 2} \\
      Подход         								& Base 	& ABE 	& Base 	& ABE 		\\ \hline
      Число предупреждений 							& 507  	& 503   & 916   & 918  		\\ 
      Общее время CPU, с							& 591  	& 611   & 485   & 496  		\\ 
\hspace{0.5cm} Время на построение абстракции, с 	& 92 	& 48   	& 82 	& 48   	\\
      \hline
    \end{tabular}
  \end{table}
\end{center}

% нужно сравнить и тот и другой запуск, странное отличие

\section{Сравнение различных вариантов реализации ThreadCPA}

\subsection{Сравнение различных подходов }

\begin{itemize}
\item Simple. Простой вариант инвариантный к эффектам окружения.
\item Env. Вариант с эффектами окружения.
\item Base. Сложный вариант инвариантный к эффектам окружения.
\end{itemize}

\subsubsection{Сравнение на SV-COMP}
Результаты экспериментов представлены в таблице~\ref{table-svcomp-thread}.

\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-svcomp-thread}
    \caption{Сравнение различных вариантов реализации оператора $merge$}
    \begin{tabular}{ | l | c | c | c | }
      \hline
      Подход         				& Simple   	& Env 		& Base  	\\ \hline
      Вердикт "ошибка" 				& 988    	& 966       & 1028       \\ 
  \hspace{0.5cm} из них корректных 	& 789 		& 785 		& 805    	\\ 
  \hspace{0.5cm} из них некорректных & 199 		& 181 		& 223     	\\ \hline
      Вердикт "нет ошибки"  		& 33      	& 24        & 21       	\\ 
  \hspace{0.5cm} из них корректных 	& 33 		& 24    	& 21      	\\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0     	\\ \hline
      Анализ не завершен       		& 26     	& 92        & 33    	\\ \hline
      Время CPU, с   				& 28 400 	& 23 800    & 25 600  	\\
      \hline
    \end{tabular}
  \end{table}
\end{center}

% Много падений в Env из-за counterexample could not be ruled out...

\subsubsection{Сравнение на /drivers/net}
Результаты экспериментов представлены в таблице~\ref{table-drivers-thread}.

\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-drivers-thread}
    \caption{Сравнение различных вариантов реализации оператора $merge$}
    \begin{tabular}{ | l | c | c | c | c | c |}
      \hline
      					& \multicolumn{3}{|c|}{CPALockator-TM} 			& \multicolumn{2}{|c|}{CPALockator} 	\\
      Подход         				& Simple 	& Env 		& Base 		& Simple 	& Base  	\\ \hline
      Вердикт "ошибка" 				& 34    	& 30   		& 31   		& 40        & 36  	 	\\ 
  \hspace{0.5cm} из них корректных 	& 25 		& 22 		& 23   		& 30       	& 28   		\\ 
  \hspace{0.5cm} из них некорректных & 9 		& 8 		& 8   		& 10       	& 8     	\\ \hline
      Вердикт "нет ошибки"  		& 253      	& 253    	& 253    	& 255      	& 255     	\\ 
  \hspace{0.5cm} из них корректных 	& 253 		& 253    	& 253    	& 255       & 255   	\\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0     	& 0         & 0   		\\ \hline
      Анализ не завершен       		& 138     	& 26    	& 141    	& 130      	& 134   	\\ \hline
      Время CPU, с   				& 116 000 	& 120 000 	& 120 000 	& 106 000  	& 110 000   \\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}

\subsubsection{Сравнение на ОС РВ}
Результаты экспериментов представлены в таблице~\ref{table-os-thread}.

\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-os-thread}
    \caption{Сравнение различных вариантов реализации оператора $merge$}
    \begin{tabular}{ | l | c | c | c | c |}
      \hline
      		& 		\multicolumn{2}{|c|}{ОС РВ 1} & \multicolumn{2}{|c|}{ОС РВ 2} \\
      Подход         					& Simple 	& Base 	& Simple 	& Base 		\\ \hline
      Число предупреждений 				& 988    	& 988   & ?       & 979  		\\ 
      Общее время CPU, с				& 33      	& 33    & ?       & 638  		\\ 
  \hspace{0.5cm} время ThreadCPA, с 	& 33 		& 33    & ?      & 0,213   	\\
      \hline
    \end{tabular}
  \end{table}
\end{center}

\subsection{Сравнение различных вариантов обработки повторно создаваемого потока }

\begin{itemize}
\item Fail. Падение при попытке повторно создать поток.
\item Skip. Игнорирование повторно создаваемого потока.
\item Self. Абстракция от повторно создаваемого потока (создание самопараллельного потока).
\end{itemize}

\subsubsection{Сравнение на SV-COMP}
Результаты экспериментов представлены в таблице~\ref{table-svcomp-thread-create}.

\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-svcomp-thread-create}
    \caption{Сравнение различных вариантов реализации оператора $merge$}
    \begin{tabular}{ | l | c | c | c |}
      \hline
      Подход         				& Fail 	& Skip 	& Self  	\\ \hline
      Вердикт "ошибка" 				& 972   & 986   & 1028       \\ 
  \hspace{0.5cm} из них корректных 	& 793 	& 802 	& 805    	\\ 
  \hspace{0.5cm} из них некорректных & 179 	& 184 	& 223     	\\ \hline
      Вердикт "нет ошибки"  		& 19    & 63    & 21       	\\ 
  \hspace{0.5cm} из них корректных 	& 19 	& 60    & 21      	\\
  \hspace{0.5cm} из них некорректных & 0 	& 3    	& 0     	\\ \hline
      Анализ не завершен       		& 91    & 33    & 33    	\\ \hline
      Время CPU, с   				& 26 200 & 26 400 & 28 000  \\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}

\subsubsection{Сравнение на /drivers/net}
Результаты экспериментов представлены в таблице~\ref{table-drivers-thread-create}.

\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-drivers-thread-create}
    \caption{Сравнение различных вариантов реализации оператора $merge$}
    \begin{tabular}{ | l | c | c | c | c | c | c |}
      \hline
      				& 		\multicolumn{3}{|c|}{CPALockator-TM} 		& \multicolumn{3}{|c|}{CPALockator} \\
      Подход         				& Fail 		& Skip 		& Self 		& Fail 	& Skip 		& Self  \\ \hline
      Вердикт "ошибка" 				& 31   		& 32   		& 24   		& 37   	& 36   		& 35   \\ 
  \hspace{0.5cm} из них корректных 	& 23 		& 24 		& 17   		& 29   	& 28   		& 27   \\ 
  \hspace{0.5cm} из них некорректных & 8 		& 8 		& 7   		& 8   	& 8   		& 8   \\ \hline
      Вердикт "нет ошибки"  		& 253    	& 253    	& 253   	& 256   & 255  		& 255   \\ 
  \hspace{0.5cm} из них корректных 	& 253 		& 253    	& 253   	& 256   & 255   	& 255   \\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0     	& 0   	& 0   		& 0   \\ \hline
      Анализ не завершен       		& 141    	& 140    	& 148    	& 132   & 134   	& 135   \\ \hline
      Время CPU, с   				& 120 000 	& 120 000 	& 122 000 	& 110 000 & 110 000 & 116 000   \\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}


\subsubsection{Сравнение на ОС РВ}
Результаты экспериментов представлены в таблице~\ref{table-drivers-thread-create}.

\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-drivers-thread-create}
    \caption{Сравнение различных вариантов реализации оператора $merge$}
    \begin{tabular}{ | l | c | c | c | c | c | c |}
      \hline
      						& 		\multicolumn{3}{|c|}{ОС РВ 1} 		& \multicolumn{3}{|c|}{ОС РВ 2} \\
      Подход         				& Fail 		& Skip 		& Self 		& Fail 		& Skip 		& Self  \\ \hline
      Число предупреждений			& 503   	& 503  		& 503  		& 979   	& 979   	& 979   \\ 
  	  Общее время CPU, с 			& 611 		& 601 		& 601  		& 638   	& 655  		& 610   \\ 
\hspace{0.5cm} Время работы ThreadCPA & 0,15	& 0,17 		& 0,12 		& 0,213   	& 0,22 		& 0,16   \\ \hline
      Число созданных потоков  		& 497    	& 497    	& 497   	& 37   		& 37  		& 37   \\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}

\section{Сравнение различных вариантов реализации LockCPA}

\subsection{Сравнение реализаций оператора $merge$ }

Для проведения экспериментов были использованы следующие конфигурации:

\begin{itemize}
\item Base. Базовая реализация LockCPA с отключенными оптимизациями и $merge = sep$.
\item Join. Реализация LockCPA с отключенными оптимизациями и $merge = join$.
\end{itemize}

\subsubsection{Результаты экспериментов на задачах SV-COMP}

Результаты экспериментов представлены в таблице~\ref{table-svcomp-lock-merge}.

\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-svcomp-lock-merge}
    \caption{Сравнение различных вариантов реализации оператора $merge$}
    \begin{tabular}{ | l | c | c |}
      \hline
      Подход         				& Base 		& Join 		\\ \hline
      Вердикт "ошибка" 				& 1028   	& 1028   	\\ 
  \hspace{0.5cm} из них корректных 	& 805 		& 805 	 	\\ 
  \hspace{0.5cm} из них некорректных & 223 		& 223 	   	\\ \hline
      Вердикт "нет ошибки"  		& 21    	& 21     	\\ 
  \hspace{0.5cm} из них корректных 	& 21 		& 21    	\\
  \hspace{0.5cm} из них некорректных & 0 		& 0    	  	\\ \hline
      Анализ не завершен       		& 26    	& 26      	\\ \hline
      Время CPU, с   				& 25 600 	& 27 300  	\\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}

\subsubsection{Результаты экспериментов на /drivers/net}

Результаты экспериментов представлены в таблице~\ref{table-drivers-lock-merge}.

\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-drivers-lock-merge}
    \caption{Сравнение различных вариантов реализации оператора $merge$}
    \begin{tabular}{ | l | c | c | c | c | }
      \hline
      		& 		\multicolumn{2}{|c|}{CPALockator-TM} 	& \multicolumn{2}{|c|}{CPALockator}  \\
      Подход         				& Base 		& Join 		& Base 		& Join   	\\ \hline
      Вердикт "ошибка" 				& 31   		& 31   		& 37   		& 36   		\\ 
  \hspace{0.5cm} из них корректных 	& 23 		& 23 		& 29   		& 28     	\\ 
  \hspace{0.5cm} из них некорректных & 8 		& 8 		& 8   		& 8     	\\ \hline
      Вердикт "нет ошибки"  		& 253    	& 253   	& 256    	& 256      	\\ 
  \hspace{0.5cm} из них корректных 	& 253 		& 253   	& 256    	& 256     	\\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0     	& 0  		\\ \hline
      Анализ не завершен       		& 128    	& 128   	& 132    	& 133     	\\ \hline
      Время CPU, с   				& 121 000 	& 120 000 	& 110 000 	& 110 000   \\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}

\subsubsection{Результаты экспериментов на ОС РВ}

Результаты экспериментов представлены в таблице~\ref{table-os-lock-merge}.

\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-os-lock-merge}
    \caption{Сравнение различных вариантов реализации оператора $merge$}
    \begin{tabular}{ | l | c | c | c | c | }
      \hline
      		& 		\multicolumn{2}{|c|}{ОС РВ 1} & \multicolumn{2}{|c|}{ОС РВ 2}  \\
      Подход         					& Base 	& Join 	& Base 	& Join   	\\ \hline
      Число предупреждений				& 503   & 503   & 979   & \todo{918 ??}   	\\ 
  	  Общее время CPU (с) 				& 592 	& 600 	& 593   & 542     	\\ 
  \hspace{0.5cm} Время работы LockCPA, с & 1,6 	& 1,3 	& 1,7   & 1,7     	\\ \hline
   	  Операций с блокировками			& 38526 & 38526 & 63764 & 57859      	\\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}

\subsection{Сравнение оптимизаций BAM}

\begin{itemize}
\item None. Базовая реализация LockCPA с отключенными оптимизациями.
\item Counters. Использование абстракции от счетчика рекурсивных захватов блокировки.
\item Locks. Использование абстракции от неиспользуемых примитивов синхронизации.
\end{itemize}

\subsubsection{Сравнение на /drivers/net}
\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-drivers-lock-merge}
    \caption{Сравнение различных вариантов реализации оператора $merge$}
    \begin{tabular}{ | l | c | c | c | c | c |}
      \hline
      		& 		 \multicolumn{3}{|c|}{/drivers/net/} \\
      Подход         				& None 	& BlockCounters & AllCounters 	& Locks 	& Both \\ \hline
      Вердикт "ошибка" 				& 35   	& 34       		& 35    		& 32       	& 32     \\ 
  \hspace{0.5cm} из них корректных 	& 27 	& 26 			& 27    		& 25       	& 25   \\ 
  \hspace{0.5cm} из них некорректных & 8 	& 8 			& 8     		& 7       	& 7    \\ \hline
      Вердикт "нет ошибки"  		& 255   & 255        	& 255   		& 255       & 255     \\ 
  \hspace{0.5cm} из них корректных 	& 255 	& 255    		& 255   		& 255       & 255     \\
  \hspace{0.5cm} из них некорректных & 0 	& 0    			& 0     		& 0       	& 0  \\ \hline
      Анализ не завершен       		& 135    & 136        	& 135    		& 138       & 134  \\ \hline
      Время CPU (с)   				& 89 600 & 91 000   	& 90 000    	& 90 400    & 91 700  \\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}

\subsubsection{Сравнение на ОС РВ}

%oc3000
\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-drivers-lock-merge}
    \caption{Сравнение различных вариантов реализации оператора $merge$}
    \begin{tabular}{ | l | c | c | c | c | c | c | }
      \hline
      Подход         						& None 			& Block 	& All		& Locks 	& Block-Locks	\\ \hline
      Число предупреждений 					& 503   		& 503       & 503   	& 503   	& 503       	\\ 
      Общее время CPU, с 					& 867 			& 660 		& 613   	& 521 		& 647 	 		\\ 
\hspace{0.5cm} Время reduce/expand при анализе, с & 0,3		& 0,4 		& 0,4   	& 0,5 		& 0,6 	  		\\ \hline
% \hspace{0.5cm} Время reduce/expand в конце, с & 0,06		& 0,08 		& 0,08   	& 0,13 		& 0,15 	  		\\ \hline
      Количество попаданий в BAM кэш		& 34305  		& 33893   	& 31656   	& 32893  	& 32893  	\\ 
      										& (47\%)		& (50\%)  	& (48\%)	& (63\%)	& (63\%)	\\
      \hline
    \end{tabular}
  \end{table}
\end{center}

%ose
\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-drivers-lock-merge}
    \caption{Сравнение различных вариантов реализации оператора $merge$}
    \begin{tabular}{ | l | c | c | c | c | c | c | }
      \hline
      Подход         						& None 		& Block 	& All 		& Locks 	& Block-Locks 	\\ \hline % & All-Locks	 
      Число предупреждений 					& 1074  	& 1074      & 979   	& 1074   	& 1074  		\\ % & 979  
      Общее время CPU, с 					& 2288 		& 2195 		& 904   	& 953 		& 1019 			\\ % & 601  
\hspace{0.5cm} Время reduce/expand
 							при анализе, с	& 1,5 		& 3,7 		& 1,3   	& 1,5 		& 1,7 	 		\\ \hline % & 1,5 
% \hspace{0.5cm} Время reduce/expand в конце, с & ?		& ? 		& ?   		& ? 		& ? 	  		& 	\\ \hline
      Количество попаданий в BAM кэш		& 352276  	& 349179  	& 199428   	& 267023  	& 267023  		\\ % & 148996 	 
      										& (84\%)	& (89\%)	& (87\%)	& (91\%) 	& (91\%) 		\\ % & (91\%)	
      \hline
    \end{tabular}
  \end{table}
\end{center}

% Проблемы для случая CheckLock - Acquire. Появляется лишняя блокировка.


\subsection{Использование уточнения}

\begin{itemize}
\item Base. Базовая реализация LockCPA, которая рассматривает все возможные примитивы синхронизации.
\item Refinement. Реализация LockCPA с использованием уточнения.
%\item stopAfterLimit. Остановка анализа при превышении количества максимально-допустимого количества рекурсивных захватов блокировки.
\end{itemize}

\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-drivers-lock-refinement}
    \caption{Сравнение различных вариантов реализации оператора $merge$}
    \begin{tabular}{ | l | c | c | }
      \hline 
      Подход         				& Base   	& Refinement \\ \hline
      Вердикт "ошибка" 				& 262    	& 262       \\ 
  \hspace{0.5cm} из них корректных 	& 255 		& 255 		\\ 
  \hspace{0.5cm} из них некорректных & 7 		& 7 		\\ \hline
      Вердикт "нет ошибки"  		& 26      	& 24       	\\ 
  \hspace{0.5cm} из них корректных 	& 26 		& 24    	\\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		\\ \hline
      Анализ не завершен       		& 137     	& 139        \\ \hline
      Время CPU (с)   				& 93 200 	& 92 600    \\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}


\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-drivers-lock-refinement}
    \caption{Сравнение различных вариантов реализации оператора $merge$}
    \begin{tabular}{ | l | c | c | c | c | }
      \hline
      		& 			 \multicolumn{2}{|c|}{ОС РВ 1} & 		\multicolumn{2}{|c|}{ОС РВ 2}\\
      Подход         					& Base  & Refinement  	& Base  & Refinement 	\\ \hline
      Выданные предупреждения			& 503   & 501    		& 979   & 1075  		\\ 
  	  Время CPU, с 						& 592   & 8066 			& 593   & 1810  		\\ 
  \hspace{0.5cm} Время на LockCPA, с	& 1,6   & 27    		& 1,7   & 4,8  			\\ \hline
      Операций с блокировками  			& 38526	& 576707   		& 63764 & 147519  		\\ 
      Количество уточнений  			& 0   	& 20   			& 0   	& \todo{2}  	\\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}

%На Refinement - таймаут! Поэтому не все unsafe успели уточниться.


\section{Сравнение оптимизаций для поиска состояний гонки}

\subsection{Оценка эффекта оптимизации BAM}

\begin{itemize}
\item Base. Вариант анализа без использования BAM.
\item BAM. Использование оптимизации BAM.
\end{itemize}

\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-drivers-lock-refinement}
    \caption{Сравнение различных вариантов реализации оператора $merge$}
    \begin{tabular}{ | l | c | c | }
      \hline
      		& 		 \multicolumn{2}{|c|}{/drivers/net/} \\
      Подход         				& Base  	& BAM 	\\ \hline
      Вердикт "ошибка" 				& 5   		& 37    \\ 
  \hspace{0.5cm} из них корректных 	& 3 		& 29 	\\ 
  \hspace{0.5cm} из них некорректных & 2		& 8 	\\ \hline
      Вердикт "нет ошибки"  		& 248    	& 256    \\ 
  \hspace{0.5cm} из них корректных 	& 248 		& 256    \\
  \hspace{0.5cm} из них некорректных & 0 		& 0    	\\ \hline
      Анализ не завершен       		& 172    	& 132    \\ \hline
      Время CPU (с)   				& 51 500 	& 110 200 \\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}

% Большая часть Out of Memory

\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-drivers-lock-refinement}
    \caption{Сравнение различных вариантов реализации оператора $merge$}
    \begin{tabular}{ | l | c | c | c | c |  }
      \hline
      		& 			 \multicolumn{2}{|c|}{ОС РВ 1} & 	\multicolumn{2}{|c|}{ОС РВ 2}\\
      Подход         					& Base  & BAM  		& Base  & BAM 	\\ \hline
      Выданные предупреждения			& 503   & - 	   	& 979   & -  			\\ 
  	  Время CPU, с 						& 611   & 10024		& 593   & 2000  		\\ 
      Созданных потоков					& 497   & 92    	& 37   	& 1  			\\ \hline
      \hline
    \end{tabular}
  \end{table}
\end{center}

%\subsection{Оценка эффекта использования ограничения на количество уточнений}
%
%\begin{itemize}
%\item Unlimit. Вариант анализа без ограничения на количество уточнений.
%\item Limit = 0. Вариант анализа без уточнений.
%\item Limit = 10. Вариант анализа c использованием 10 уточнений.
%\end{itemize}
%
%% график?

\subsection{Оценка эффекта использования анализа разделяемых данных}

\begin{itemize}
\item Base. Вариант анализа с отключенными оптимизациями.
\item Shared. Использование анализа разделяемых данных.
\end{itemize}


\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-drivers-lock-refinement}
    \caption{Сравнение различных вариантов реализации оператора $merge$}
    \begin{tabular}{ | l | c | c |}
      \hline
      Подход         				& Base 	& Shared 	\\ \hline
      Вердикт "ошибка" 				& 988   & 988    	\\ 
  \hspace{0.5cm} из них корректных 	& 789 	& 789 		\\ 
  \hspace{0.5cm} из них некорректных & 199 	& 199 		\\ \hline
      Вердикт "нет ошибки"  		& 33    & 33    	\\ 
  \hspace{0.5cm} из них корректных 	& 33 	& 33    	\\
  \hspace{0.5cm} из них некорректных & 0 	& 0    		\\ \hline
      Анализ не завершен       		& 26    & 26     	\\ \hline
      Время CPU (с)   				& 28 400 & 38 200  	\\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}


\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-drivers-lock-refinement}
    \caption{Сравнение различных вариантов реализации оператора $merge$}
    \begin{tabular}{ | l | c | c | c | c |  }
      \hline
      		& 			 \multicolumn{2}{|c|}{ОС РВ 1} & 	\multicolumn{2}{|c|}{ОС РВ 2}\\
      Подход         					& Base  & Shared  	& Base  & Shared 	\\ \hline
      Выданные предупреждения			& 503   & 245    	& 979   & 460  			\\ 
  	  Время CPU, с 						& 611   & 1384  ???	& 593   & 568  		\\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}


\subsection{Оценка эффекта использования предикатного анализа}

\begin{itemize}
\item Predicate. Вариант анализа с использованием предикатной абстракции.
\item Lightweight. Использование анализа без использования предикатной абстракции
\end{itemize}

% Сравнивать на sv-comp глупо, так как там всегда есть зависимости по данным


\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-drivers-lock-refinement}
    \caption{Сравнение различных вариантов реализации оператора $merge$}
    \begin{tabular}{ | l | c | c | c | c |}
      \hline
      & 			 \multicolumn{2}{|c|}{CPALockator-TM} & 	\multicolumn{2}{|c|}{CPALockator}\\
      Подход         				& Predicate & Lightweight 	& Predicate & Lightweight\\ \hline
      Вердикт "ошибка" 				& 31   		& 144   	& 37   		& 168  	\\ 
  \hspace{0.5cm} из них корректных 	& 23 		& 86 		& 29   		& 86 	\\ 
  \hspace{0.5cm} из них некорректных & 8 		& 58 		& 8   		& 82 	\\ \hline
      Вердикт "нет ошибки"  		& 253    	& 226    	& 256   	& 226 	\\ 
  \hspace{0.5cm} из них корректных 	& 253 		& 226    	& 256   	& 226 	\\
  \hspace{0.5cm} из них некорректных & 0 		& 0    		& 0   		& 0 	\\ \hline
      Анализ не завершен       		& 128    	& 55    	& 132   	& 31  	\\ \hline
      Время CPU (с)   				& 121 000 	& 37 700 	& 110 000  	& 14 200\\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}


\begin{center}
  \begin{table}[h] \footnotesize \centering
  	\label{table-drivers-lock-refinement}
    \caption{Сравнение различных вариантов реализации оператора $merge$}
    \begin{tabular}{ | l | c | c | c | c |  }
      \hline
      		& 			 \multicolumn{2}{|c|}{ОС РВ 1} & 	\multicolumn{2}{|c|}{ОС РВ 2}\\
      Подход         					& Predicate  & Lightweight 	& Predicate  & Lightweight 	\\ \hline
      Выданные предупреждения			& 503   	& 507    		& 918   	& 916  			\\ 
  	  Время CPU, с 						& 611   	& 107  			& 513   	& 133  		\\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}

% Вопросы остаются с lightweight

%----------------------------------------------------
\section{Поиск известных ошибок в драйверах ОС Linux}
Мы подготовили 32 тестовых программы на основе 16 известных ошибок, найденных в модулях ядра операционной системы Linux\footnote{в течение GSoC 2017 http://linuxtesting.org/28-08-2017}
Для каждой ошибки доступны два варианта: {\em false} (с достижимой ошибкой) и {\em true} (исправленный вариант).

Задания были подготовлены с помощью системы Klever. В частности, при подготовки заданий были заменены примитивы синхронизации ядра на конструкции библиотеки posix (mutex\_lock и spin\_lock были заменены на pthread\_mutex\_lock), а также добавлена модель окружения драйвера.

Кроме того, предпринимались попытки запуска других инструментов-участников соревнования sv-comp. 
Однако, большинство из них, так или иначе, работали некорректно. 
Так, YogarCBMC падает с ошибкой сегментирования, а SMACK -- получает exception. Последнюю ушибку можно избежать, отключив в конфигурации инструмента один из видов анализа, но после этого возникает таймаут.


\section{Анализ причин ложных срабатываний}

\subsection{Ложные предупреждения на драйверах ОС Linux}

\subsection{Ложные предупреждения на ОС РВ}

% oc3000
%Подозрительное место	210	33,76%
%Некритичное место	57	9,16%
%Один поток	50	8,04%
%intNest	17	2,73%
%shared merge	51	8,20%
%Разные структуры	33	5,31%
%Данные от пользователя	110	17,68%
%Список	5	0,80%
%Уточнение	58	9,32%
%curproc	4	0,64%
%Другое	27	4,34%
%	622	


% старый сервер
% Bugs: 4
%verifier: 16
%intNest: 4
%local: 11
%objAllocate: 8
%thread-local cond: 1
%mqSAFE_UNSET: 1



% ose
% Реальные ошибки: 12
%Без тегов: 7
%Benign: 5
%Ложные сообщения об ошибках: 21
%EnvironmentModel: 5
%ThreadCreation: 4
%Verifier: 16
%Lockator: 16
%SharedAnalysis: 6
%SharedMerge: 2
%LockAnalysis: 7
%if-lock: 1
%Signals: 1
%Interrupts: 2
%ProtectedGet: 1
%MemoryModel: 3
%Неизвестно: 3
%Без тегов: 1
%Verifier: 1
%Lockator: 1
%LockAnalysis: 1
%Ad-hoc sync: 1
%Question: 1


% Linux device drivers
% Benign: 7
%EMG: 9
%Lockator: 25
%LDVVariables: 2
%LockAnalysis: 3
%ad-hoc sync: 2
%ProtectedGet: 1
%MemoryModel: 17
%PredicateAnalysis: 3
%SharedAnalysis: 2



%Покрытие!

В результате разметки было получено, что около 30\% полученных предупреждений соответсвуют реальным ошибкам. 
При этом для одного состояния гонки может быть выдано несколько предупреждений на различные переменные, работа с которыми производится похожим образом.
Таким образом, получается, что около 1\% проверенных модулей содержат ошибки, связанные с состоянием гонки.
При этом часть из ошибок находится в неподдерживаемых модулях, и такие ошибки, как правило, не исправляются, даже если и признаются. 
Другая часть ошибок оказывается безобидными, то есть, не способными нанести какой-либо вред.
Такие ошибки, хотя и признаются разработчиками, все равно не исправляются, так как их исправление, как и исправление многих ошибок, связанных с параллельным выполнением кода, требует серьезных изменений кода.
В среднем, только половина найденных ошибок доходит до подготовки патча, исправляющего эту ошибку.

Наиболее важной причиной ложных срабатываний стало несовершенство модели окружений, из-за которой было  получено  более  50\%  ложных  предупреждений.
Например,  некоторые функции-обработчики  драйвера  при  реальном  выполнении  вызываются  под блокировками, в то время как в модели этот факт не учитывается.
Кроме того зачастую  возникают  неявные  зависимости  между  обработчиками  разных структур,  которые  не  позволяют  им  выполняться одновременно  и  которые также  не  учитываются  в  модели  окружения.
Следует  еще  раз  отметить, что модель окружения относится к этапу подготовки задачи, а не к методу анализу непосредственно. 

Возникали  ситуации,  в  которых  структуры  одного  типа  использовались  для разного  назначения,  которое  предполагало  наличие  различных  блокировок. 
Таким образом, упрощенная модель памяти, которую используется в методе, принесла около 10\% ложных предупреждений. 
Еще 10\%  ложных  предупреждений  связаны  с  ситуациями,  в  которых  из разделяемого множества достается объект под блокировками, а работа с ним 
осуществляется  без них.
Около 10\% связаны с  неточностями анализа: это и несовершенство анализа функциональных указателей, и проблемы в анализе примитивов  синхронизации  (в т. ч. отсутствие некоторых  блокировок  в конфигурации), и неточности в анализе разделяемых данных.  

Таким   образом,   представленный   метод   поиска  состояний  гонок в операционных системах продемонстрировал практически значимые результаты
с приемлемым уровнем ложных срабатываний.
Являясь, по сути, легковесным методом, он допускает более гибкую настройку баланса между ресурсами и точностью анализа.


\section{Выводы по результатам экспериментов}


%\newpage
%============================================================================================================================

\clearpage