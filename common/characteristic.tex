
{\actuality} Информационные технологии являются важной составляющей инфраструктуры современного общества.
Они позволяют автоматизировать различные процессы жизнедеятельности человека и обеспечить возможность коммуникации.
В настоящее время невозможно представить себе высокотехнологичное производство или сервис услуг, которые бы обходились без использования информационных технологий.
Более того, сейчас активно развиваются технологии, которые позволяют автоматизировать бытовые потребности человека.
%К таким технологиям относится «интернет вещей» (англ. Internet of Things, IoT).
Это означает, что жизнь человека становится все более и более зависимой от программных систем.

Информационные системы непрерывно развиваются и усложняются. 
С ростом сложности программных продуктов росло и количество ошибок в них.
Повышение роли программного обеспечения в жизнедеятельности человека приводит к увеличению величины последствий от отказа или некорректного поведения.
Некоторые ошибки способны сильно исказить правильное выполнение программы и привести к серьезным последствиям.
В 2017 году компания Coverity опубликовала очередной отчет, в котором были приведены результаты исследования изучения 760 млн строк кода.
В среднем, в программном продукте содержится около 1.4 ошибок на 1000 строк кода.
Это число ошибок значительно вырасло по сравнению с отчетами предыдущих лет.
Таким образом, число проблем в проекте размером миллион строк кода исчисляется тысячами.
Степень критичности ошибки также зависит и от той области, в которой применяется программное обеспечение.
Ошибки в программных системах, используемых в авиации или на атомных электростанциях, могут привести к значительным человеческим жертвам или колоссальным финансовым затратам.
Известно множество случаев, в которых ошибки в программном обеспечении приводили к серьезным последствиям, например, случаи с аппаратом лучевой терапии Therac-25 и с космическим аппаратом
\ifsynopsis
Phobos.
\else
Phobos~\cite{Leveson:1995}.
\fi
Таким образом, с момента возникновения первых вычислительных систем перед людьми всегда стояла задача проверки правильности программы. 

%Под верификацией будем понимать проверку соответствия одних создаваемых в ходе разработки и сопровождения программного обеспечения сущностей другим, ранее созданным или используемым в качестве исходных данных, а также соответствие этих сущностей и процессов их разработки правилам и стандартам [4]. В качестве сущностей могут выступать непосредственно программы, модели, документы и др.
%Существует несколько методов верификации: экспертиза, статический анализ, формальные методы, динамические методы, синтетические методы. 

%Поэтому с самого начала развития информатики развиваются и совершенствуются методы проверки программ и доказательства их корректности. Их уже достаточно много: от ручных математических доказательств, до динамического тестирования. Они прошли долгий путь от формальных математических доказательств, которые были доступны только специалистам, обладающим хорошим математическим образованием, до прикладных инструментов, понятных даже инженерам и разработчикам прикладного программного обеспечения.

Развитие параллельных вычислений привело к быстрому разрастанию кода, который предполагает параллельное исполнение.
%Цифры? 
Параллельные алгоритмы позволяют более эффективно использовать доступные вычислительные ресурсы.
Основной сложностью таких алгоритмов является обеспечение синхронизации между потоками и корректным использованием разделяемых ресурсов.
В связи с этим появляются новые типы ошибок, характерные только для параллельно исполняемого кода. 

Основными классами ошибок в параллельных программах являются состояния гонок и состояния взаимных блокировок.
В общем случае состоянием гонки называют ситуацию, при которой поведение программы зависит от порядка или времени выполнения некоторых неконтролируемых событий.
Важное уточнение заключается в том, что такое выполнение не всегда является ошибкой.
Проблемы возникают тогда, когда разработчик не предусматривает некоторое из возможных поведений программы.
Часто рассматривают более узкий класс — состояния гонки по данным. Эта ситуация возникает при одновременном доступе к данным из разных потоков (процессов).
%Здесь и далее не будем различать потоки и процессы, так как их различия не имеют отношения к теме работы.
Состояния гонки по данным становятся опасными в случае, если имеет место хотя бы один доступ на запись в разделяемую область памяти.
%Пример!
В этом случае результирующее значение переменной зависит от порядка выполнения инструкций, а в параллельно выполняемом коде последовательность выполнения инструкций не определена. 

%Стоит упомянуть о высокоуровневых состояниях гонки по данным.
%Такие состояния гонки по данным отличается тем, что доступ производится к разным разделяемым данным, которые тем не менее являются семантически связанными.
%Например, это может быть реализация сложных структур данных, таких как двусвязные списки, деревья, графы и т. п.
%В случае модификации такой структуры данных должна быть обеспечена атомарность, в противном случае, данные могут стать неконсистентными, например, не нарушится целостность списка. 
 
Состояния взаимных блокировок являются вторым большим классом ошибок в многопоточных программах.
Они возникают при некорректном использовании блокирующих механизмов синхронизации.
В этом случае все потоки системы находятся в ожидании некоторого разблокирующего действия от других потоков и не могут продолжить свое выполнение. 

Ошибки, связанные с параллельным исполнением кода искать и исправлять гораздо сложнее, чем ошибки в последовательном коде, так как необходимо представлять все возможные сценарии взаимодействия потоков.
Поиск и исправление таких ошибок осложняется случайным характером их проявлений -- ошибка может проявляться очень редко.
Это связано с тем, что для проявления ошибки необходимы некоторая конкретная последовательность и порядок действий различных потоков. 

В прикладных пользовательских программах бывает достаточно провести тщательное тестирование, возможно, с помощью инструментов динамического анализа, чтобы проверить основные сценарии поведения программы.
%Однако, такое тестирование не дает гарантий корректного поведения даже при тех же самых условиях и входных данных, что для пользовательских приложений является приемлемым вариантом.
В случае же системного программного обеспечения цена пропущенной ошибки может быть слишком велика, поэтому необходим более тщательный анализ программного кода.
Кроме того, устройство системного программного обеспечения отличается от прикладных программ, что затрудняет анализ, так как далеко не все методы принимают во внимание специфику системного программного обеспечения.

В ядре операционной системы может одновременно выполняться большое число (несколько десятков) совершенно различных функций: обработчики прерываний, системные вызовы от пользовательских программ, внутренние службы ядра, например, планировщик, драйвера внешних устройств.
Для синхронизации всех этих функций используются не только обыкновенные примитивы синхронизации, но и специальные низкоуровневые, которые характерны только для системного программного обеспечения, например, запреты прерываний и планирования. 
Различные исследования показывают, что ошибки, связанные с параллельным выполнением, в системном программном обеспечении являются достаточно многочисленными, например, к ним относятся около 20\% всех ошибок в файловых
\ifsynopsis
системах.
\else
системах~\cite{Palix11}.
\fi

%В частности, анализ типовых ошибок, исправленных за год в ядре операционной системы Linux, показал, что ошибки, связанные с состоянием гонки образуют самый многочисленный класс и составляют около 17\% от всех 
%\ifsynopsis
%ошибок.
%\else
%ошибок~\cite{commit_analysis_12}.
%\fi

Таким образом, задача поиска ошибок синхронизации в ядрах операционных систем, в том числе, состояний гонки по данным, является важной и актуальной задачей.

\ifsynopsis
%Этот абзац появляется только в~автореферате.
\else

%Динамический анализ системного программного обеспечения не обеспечивает должного качества для применения целевого ПО в критически важных областях. В таких случаях необходимо применение формальных методов верификации. Основной сложностью данного подхода является высокая сложность точного моделирования системного программного обеспечения, так как неизбежно возникает проблема комбинаторного взрыва. Тем не менее, сейчас активно применяется формальная верификация для доказательств корректности отдельных подсистем (модулей) программной системы с формулировкой требований на корректное использование его интерфейсов другими частями системы.

Даже при анализе одного потока сложной программной системы возникают сложности с анализом циклов, битовых операций, адресной арифметики. 
На сколько учитывать окружение и другие потоки?
\fi

% {\progress} 
% Этот раздел должен быть отдельным структурным элементом по
% ГОСТ, но он, как правило, включается в описание актуальности
% темы. Нужен он отдельным структурынм элемементом или нет ---
% смотрите другие диссертации вашего совета, скорее всего не нужен.

{\aim} данной работы является разработка метода поиска состояний гонок, который будет масштабироваться на большие объемы кода, будет обладать приемлемым уровнем ложных предупреждений и будет учитывать специфику ядра операционных систем.

Для~достижения поставленной цели необходимо было решить следующие {\tasks}:
\begin{enumerate}
  \item Разработать общий алгоритм, позволяющий реализовать подход к верификации программного обеспечения с раздельным анализом потоков, и доказать его корректность;
  \item Разработать метод поиска состояний гонки, как частный случай общего алгоритма, который может эффективно применяться к большим объемам исходного кода, и доказать его корректность;
  \item Реализовать разработанные алгоритмы;
  \item Провести эксперименты и сравнить результаты с другими инструментами статической верификации;
\end{enumerate}

{\novelty}
\begin{enumerate}
  \item Был предложен новый алгоритм, который является обобщением существующего алгоритма CPA, и доказана его корректность;
  \item Был предложен частный случай обобщенного алгоритма, который реализует подход с раздельным анализом потоков, и доказана его корректность;
  \item Разработан метод поиска состояний гонки и доказана его корректность;
  \item Были проведены запуски инструмента на модулях ядра операционной системы Linux, а также на двух операционных системах реального времени;
\end{enumerate}

%{\influence} \ldots

%{\methods} \ldots

%{\defpositions}
\textbf{Положения, выносимые на публичное представление}
\begin{enumerate}
  \item Обобщенный алгоритм анализа программ, позволяющий определять различные ввиды анализа, и доказательство его корректности;
  \item Алгоритм, позволяющий проводить раздельный анализ потоков многопоточных программ, и доказательство его корректности;
  \item Метод поиска состояний гонки в многопоточных программах.
\end{enumerate}

%{\reliability} полученных результатов обеспечивается \ldots \ Результаты находятся в соответствии с результатами, полученными другими авторами.

{\probation}
Основные результаты работы докладывались~на:
\begin{itemize}
  \item Весенний коллоквиум молодых исследователей в области программной инженерии (SYRCoSE: Spring Young Researchers Colloquium on Software Engineering), Санкт-Петербург, 2014 г.;
  \item Научно-исследовательский семинар лаборатории «Software and Computational Systems Lab» Университета Пассау, Германия, 2014 г.
  \item Международная научно-практическая конференция "Инструменты и методы анализа программ" (TMPA: Tools and Methods for Program Analysis), Кострома, 2014 г.
  \item Международный семинар разработчиков CPAchecker, Москва, 2015 г.
  \item Летняя научная школа компании Microsoft (Microsoft Summer School), Кэмбридж, Англия, 2015 г.
  \item Научно-практическая Открытая конференция ИСП РАН, Москва, 2016 г.
  \item Научно-исследовательский семинар лаборатории «Software and Computational Systems Lab» Университета Пассау, Германия, 2016 г.
  \item Международная научно-практическая конференция "Инструменты и методы анализа программ" (TMPA: Tools and Methods for Program Analysis), Москва, 2017 г.
  \item Международный семинар разработчиков CPAchecker, Падерборн, 2017 г.
\end{itemize}

% {\contribution} Автор принимал активное участие \ldots

\publications\ Основные результаты по теме диссертации изложены в 5 печатных изданиях~\cite{lockatorVAK,lockatorVAK2,TMPA2017,lockatorSyrcose,lockatorTMPA}, 
    3 из которых изданы в журналах, рекомендованных ВАК~\cite{lockatorVAK,lockatorVAK2,TMPA2017}, из них 1 находится в базе Scopus~\cite{TMPA2017},
    2 "--- в тезисах докладов~\cite{lockatorSyrcose,lockatorTMPA}.

В статье~\cite{lockatorVAK} автором описана основная идея метода (глава 3) и его реализация (глава 5).
В статье~\cite{lockatorVAK2} автором написаны разделы, посвященные общей идее метода (глава 3), его реализации (глава 4), процессу уточнения (глава 5) и анализу потоков (глава 6).
В статье~\cite{TMPA2017} автором написаны разделы, посвященные разработанному методу и его реализации (главы 3--6).
В статье~\cite{lockatorSyrcose} автором написаны разделы, в которых описывается ключевые особенности метода (главы 3--5).
В статье~\cite{lockatorTMPA} автором написаны разделы, посвященные разработанному методу (главы 3--5).

