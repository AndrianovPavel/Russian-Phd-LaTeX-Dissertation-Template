
{\actuality} Информационные технологии являются важной составляющей инфраструктуры современного общества. Они позволяют автоматизировать различные процессы жизнедеятельности человека и обеспечить возможность коммуникации. В настоящее время невозможно представить себе высокотехнологичное производство или сервис услуг, которые бы обходились без использования информационных технологий. Более того, сейчас активно развиваются технологии, которые позволяют автоматизировать бытовые потребности человека. К таким технологиям относится «интернет вещей» (англ. Internet of Things, IoT). Это означает, что жизнь человека становится все более и более зависимой от программных систем.

Информационные системы непрерывно развиваются и усложняются. Однако развитие аппаратной части определяется физическими свойствами и законами. Сложность программной части информационной системы тоже зависит от физических свойств, но в значительно меньшей степени и больше определяется возможностями разработчика-программиста. В начале развития компьютерной техники на долю программной части системы приходилось около 5\% стоимости, а остальное занимала аппаратная часть. Но постепенно, с усложнением программного обеспечения, его доля в общей стоимости системы выросла до 90\% [1]. Также на это влияет тот факт, что производство аппаратных решений требует значительных ресурсов, что возможно только в крупной компании, которых не так уж много. Производство программных продуктов возможно и в небольшом коллективе исполнителей. 

С ростом сложности программных продуктов росло и количество ошибок в них. Повышение роли программного обеспечения в жизнедеятельности человека приводит к увеличению величины последствий от отказа или некорректного поведения. Некоторые из них безобидны, другие способны сильно исказить правильное выполнение программы и привести к серьезным последствиям. В 2011 году компания Coverity опубликовала отчет [3], в котором были приведены результаты исследования изучения 450 млн строк кода. В среднем, в программном продукте содержится около 0.68 ошибок на 1000 строк кода. Таким образом, число проблем в проекте размером миллион строк кода исчисляется тысячами. Степень критичности ошибки также зависит и от той области, в которой применяется программное обеспечение. Ошибки в программных системах, используемых в авиации или на атомных электростанциях, могут привести к значительным человеческим жертвам или колоссальным финансовым затратам. Известно множество случаев, в которых ошибки в программном обеспечении приводили к серьезным последствиям, например, случай с аппаратом лучевой терапии Therac-25 [2] и с космическим аппаратом Phobos [3]. Таким образом, с момента возникновения первых вычислительных систем перед людьми всегда стояла задача проверки правильности программы. 

%Под верификацией будем понимать проверку соответствия одних создаваемых в ходе разработки и сопровождения программного обеспечения сущностей другим, ранее созданным или используемым в качестве исходных данных, а также соответствие этих сущностей и процессов их разработки правилам и стандартам [4]. В качестве сущностей могут выступать непосредственно программы, модели, документы и др.
%Существует несколько методов верификации: экспертиза, статический анализ, формальные методы, динамические методы, синтетические методы. 

%Поэтому с самого начала развития информатики развиваются и совершенствуются методы проверки программ и доказательства их корректности. Их уже достаточно много: от ручных математических доказательств, до динамического тестирования. Они прошли долгий путь от формальных математических доказательств, которые были доступны только специалистам, обладающим хорошим математическим образованием, до прикладных инструментов, понятных даже инженерам и разработчикам прикладного программного обеспечения.

Развитие параллельных вычислений привело к быстрому разрастанию кода, который предполагает параллельное исполнение. Цифры? Параллельные алгоритмы позволяют более эффективно использовать доступные ресурсы. Основной сложностью таких алгоритмов является обеспечение синхронизации между потоками и корректным использованием разделяемых ресурсов. В связи с этим появляются новые типы ошибок, характерные только для параллельно исполняемого кода. 

Основными классами ошибок в параллельных программах являются состояния гонок и состояния взаимных блокировок. В общем случае состоянием гонки называют ситуацию, при которой поведение программы зависит от порядка или времени выполнения некоторых неконтролируемых событий. Важное уточнение заключается в том, что такое выполнение не всегда является ошибкой. Проблемы возникают тогда, когда разработчик не предусматривает некоторое из возможных поведений программы. Часто рассматривают более узкий класс — состояния гонки по данным. Эта ситуация возникает при одновременном доступе к данным из разных потоков (процессов). Здесь и далее не будем различать потоки и процессы, так как их различия не имеют отношения к теме работы. Состояния гонки по данным становятся опасными в случае, если имеет место хотя бы один доступ на запись в разделяемую область памяти. Пример! В этом случае результирующее значение переменной зависит от порядка выполнения инструкций. 
Стоит упомянуть о высокоуровневых состояниях гонки по данным. Такие состояния гонки по данным отличается тем, что доступ производится к разным разделяемым данным, которые тем не менее являются семантически связанными. Например, это может быть реализация сложных структур данных, таких как двусвязные списки, деревья, графы и т. п. В случае модификации такой структуры данных должна быть обеспечена атомарность, в противном случае, данные могут стать неконсистентными, например, не нарушится целостность списка. 
 
Состояния взаимных блокировок являются вторым большим классом ошибок в многопоточных программах. Они возникают при некорректном использовании блокирующих механизмов синхронизации. В этом случае все потоки системы находятся в ожидании некоторого разблокирующего действия от других потоков и не могут продолжить свое выполнение. 

Ошибки, связанные с параллельным исполнением кода искать и исправлять гораздо сложнее, чем общезначимые ошибки, так как необходимо представлять все возможные сценарии взаимодействия потоков. Поиск и исправление таких ошибок осложняется случайным характером их проявлений: даже на одинаковых входных данных ошибка может проявляться очень редко. Это связано с тем, что для проявления ошибки необходимы некоторая конкретная последовательность и порядок действий различных потоков. 

В прикладных пользовательских программах бывает достаточно провести тщательное тестирование, возможно, с помощью инструментов динамического анализа, чтобы проверить основные сценарии поведения программы. Однако, такое тестирование не дает гарантий корректного поведения даже при тех же самых условиях и входных данных, что для пользовательских приложений является приемлемым вариантом. В случае же системного программного обеспечения цена пропущенной ошибки может быть слишком велика. Кроме того, системное программное обеспечение устроено значительно сложнее, чем прикладное программное обеспечение. 

В ядре операционной системы могут быть одновременно присутствовать большое число (несколько десятков) совершенно различных активностей: обработчики прерываний, системные вызовы от пользовательских программ, внутренние службы ядра, например, планировщик, драйвера внешних устройств. Для синхронизации всех этих активностей используются не только обыкновенные примитивы синхронизации, но и специальные низкоуровневые, которые характерны только для системного программного обеспечения, например, запреты прерываний и планирования. 
Различные исследования показывают, что ошибки, связанные с параллельным выполнением, в системном программном обеспечении являются достаточно многочисленными и, например, занимают около 20\% всех ошибок в файловых системах [15]. В частности, анализ типовых ошибок, исправленных за год в ядре операционной системы Linux, показал, что ошибки, связанные с состоянием гонки образуют самый многочисленный класс и составляют около 17\% от всех ошибок [16]. 

%Динамический анализ системного программного обеспечения не обеспечивает должного качества для применения целевого ПО в критически важных областях. В таких случаях необходимо применение формальных методов верификации. Основной сложностью данного подхода является высокая сложность точного моделирования системного программного обеспечения, так как неизбежно возникает проблема комбинаторного взрыва. Тем не менее, сейчас активно применяется формальная верификация для доказательств корректности отдельных подсистем (модулей) программной системы с формулировкой требований на корректное использование его интерфейсов другими частями системы.

Даже при анализе одного потока сложной программной системы возникают сложности с анализом циклов, битовых операций, адресной арифметики. 
На сколько учитывать окружение и другие потоки?
Остается вопрос о том, как именно необходимо формулировать требования к программе. Одно и то же свойство можно записать по-разному. Можно искать состояние гонки, как некоторую пару доступов к одной памяти из разных потоков. В то же время можно потребовать от программы, чтобы значения ни одной разделяемой переменной не могло быть изменено сразу после его чтения или записи. Оба этих условия являются попыткой формализации условия отсутствия состояний гонки. Однако, ни одного из таких условий оказывается недостаточно для полного описания требований к программе. Например, такие условия не позволяют формализовать требование к отсутствию таких ошибок, как высокоуровневые гонки. Также становится невозможным доказывать корректность различных алгоритмах, которые не требуют синхронизации (lock-free). И что?
В настоящее время существует большое число академических инструментов, реализующих различные подходы для проверки корректности программных систем. Динамические? Проводятся соревнования по статической верификации. Реальных примеров там почти нет. В категории, в которую входят многопоточные программы нет реальных примеров совсем. Если вручную подготовить лостаточно сложный пример, ни один инструмент не работает. 

\ifsynopsis
Этот абзац появляется только в~автореферате.
Для формирования блоков, которые будут обрабатываться только в~автореферате,
заведена проверка условия \verb!\!\verb!ifsynopsis!.
Значение условия задаётся в~основном файле документа (\verb!synopsis.tex! для
автореферата).
\else
Этот абзац появляется только в~диссертации.
Через проверку условия \verb!\!\verb!ifsynopsis!, задаваемого в~основном файле
документа (\verb!dissertation.tex! для диссертации), можно сделать новую
команду, обеспечивающую появление цитаты в~диссертации, но~не~в~автореферате.
\fi

% {\progress} 
% Этот раздел должен быть отдельным структурным элементом по
% ГОСТ, но он, как правило, включается в описание актуальности
% темы. Нужен он отдельным структурынм элемементом или нет ---
% смотрите другие диссертации вашего совета, скорее всего не нужен.

{\aim} данной работы является \ldots

Для~достижения поставленной цели необходимо было решить следующие {\tasks}:
\begin{enumerate}
  \item Исследовать, разработать, вычислить и~т.\:д. и~т.\:п.
  \item Исследовать, разработать, вычислить и~т.\:д. и~т.\:п.
  \item Исследовать, разработать, вычислить и~т.\:д. и~т.\:п.
  \item Исследовать, разработать, вычислить и~т.\:д. и~т.\:п.
\end{enumerate}


{\novelty}
\begin{enumerate}
  \item Впервые \ldots
  \item Впервые \ldots
  \item Было выполнено оригинальное исследование \ldots
\end{enumerate}

%{\influence} \ldots

%{\methods} \ldots

{\defpositions}
\begin{enumerate}
  \item Первое положение
  \item Второе положение
  \item Третье положение
  \item Четвертое положение
\end{enumerate}
В папке Documents можно ознакомиться в решением совета из Томского ГУ
в~файле \verb+Def_positions.pdf+, где обоснованно даются рекомендации
по~формулировкам защищаемых положений. 

{\reliability} полученных результатов обеспечивается \ldots \ Результаты находятся в соответствии с результатами, полученными другими авторами.


{\probation}
Основные результаты работы докладывались~на:
перечисление основных конференций, симпозиумов и~т.\:п.

{\contribution} Автор принимал активное участие \ldots

%\publications\ Основные результаты по теме диссертации изложены в ХХ печатных изданиях~\cite{Sokolov,Gaidaenko,Lermontov,Management},
%Х из которых изданы в журналах, рекомендованных ВАК~\cite{Sokolov,Gaidaenko}, 
%ХХ --- в тезисах докладов~\cite{Lermontov,Management}.

\ifnumequal{\value{bibliosel}}{0}{% Встроенная реализация с загрузкой файла через движок bibtex8
    \publications\ Основные результаты по теме диссертации изложены в XX печатных изданиях, 
    X из которых изданы в журналах, рекомендованных ВАК, 
    X "--- в тезисах докладов.%
}{% Реализация пакетом biblatex через движок biber
%Сделана отдельная секция, чтобы не отображались в списке цитированных материалов
    \begin{refsection}[vak,papers,conf]% Подсчет и нумерация авторских работ. Засчитываются только те, которые были прописаны внутри \nocite{}.
        %Чтобы сменить порядок разделов в сгрупированном списке литературы необходимо перетасовать следующие три строчки, а также команды в разделе \newcommand*{\insertbiblioauthorgrouped} в файле biblio/biblatex.tex
        \printbibliography[heading=countauthorvak, env=countauthorvak, keyword=biblioauthorvak, section=1]%
        \printbibliography[heading=countauthorconf, env=countauthorconf, keyword=biblioauthorconf, section=1]%
        \printbibliography[heading=countauthornotvak, env=countauthornotvak, keyword=biblioauthornotvak, section=1]%
        \printbibliography[heading=countauthor, env=countauthor, keyword=biblioauthor, section=1]%
        \nocite{%Порядок перечисления в этом блоке определяет порядок вывода в списке публикаций автора
                vakbib1,vakbib2,%
                confbib1,confbib2,%
                bib1,bib2,%
        }%
        \publications\ Основные результаты по теме диссертации изложены в~\arabic{citeauthor}~печатных изданиях, 
        \arabic{citeauthorvak} из которых изданы в журналах, рекомендованных ВАК, 
        \arabic{citeauthorconf} "--- в~тезисах докладов.
    \end{refsection}
    \begin{refsection}[vak,papers,conf]%Блок, позволяющий отобрать из всех работ автора наиболее значимые, и только их вывести в автореферате, но считать в блоке выше общее число работ
        \printbibliography[heading=countauthorvak, env=countauthorvak, keyword=biblioauthorvak, section=2]%
        \printbibliography[heading=countauthornotvak, env=countauthornotvak, keyword=biblioauthornotvak, section=2]%
        \printbibliography[heading=countauthorconf, env=countauthorconf, keyword=biblioauthorconf, section=2]%
        \printbibliography[heading=countauthor, env=countauthor, keyword=biblioauthor, section=2]%
        \nocite{vakbib2}%vak
        \nocite{bib1}%notvak
        \nocite{confbib1}%conf
    \end{refsection}
}
При использовании пакета \verb!biblatex! для автоматического подсчёта
количества публикаций автора по теме диссертации, необходимо
их~здесь перечислить с использованием команды \verb!\nocite!.
